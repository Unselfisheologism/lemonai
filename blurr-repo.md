Directory structure:
└── ayush0chaudhary-blurr/
    ├── README.md
    ├── build.gradle.kts
    ├── gradle.properties
    ├── gradlew
    ├── gradlew.bat
    ├── LICENSE
    ├── local.properties.template
    ├── privacy-policy.html
    ├── settings.gradle.kts
    ├── version.properties
    ├── app/
    │   ├── build.gradle.kts
    │   ├── proguard-rules.pro
    │   └── src/
    │       ├── androidTest/
    │       │   └── java/
    │       │       └── com/
    │       │           └── blurr/
    │       │               └── voice/
    │       │                   └── ExampleInstrumentedTest.kt
    │       ├── main/
    │       │   ├── AndroidManifest.xml
    │       │   ├── assets/
    │       │   │   ├── Panda_en_android_v3_0_0.ppn
    │       │   │   └── prompts/
    │       │   │       └── system_prompt.md
    │       │   ├── java/
    │       │   │   └── com/
    │       │   │       └── blurr/
    │       │   │           └── voice/
    │       │   │               ├── AssistEntryActivity.kt
    │       │   │               ├── AudioWaveView.kt
    │       │   │               ├── BaseNavigationActivity.kt
    │       │   │               ├── ChatActivity.kt
    │       │   │               ├── ChatAdapter.kt
    │       │   │               ├── DialogueActivity.kt
    │       │   │               ├── GlowBorderView.kt
    │       │   │               ├── LoginActivity.kt.kt
    │       │   │               ├── MainActivity.kt
    │       │   │               ├── MemoriesActivity.kt
    │       │   │               ├── MemoriesAdapter.kt
    │       │   │               ├── MomentsActivity.kt
    │       │   │               ├── MomentsAdapter.kt
    │       │   │               ├── MyApplication.kt
    │       │   │               ├── OnboardingPermissionsActivity.kt
    │       │   │               ├── PandaWidgetProvider.kt
    │       │   │               ├── PermissionsActivity.kt
    │       │   │               ├── PrivacyActivity.kt
    │       │   │               ├── ProPurchaseActivity.kt
    │       │   │               ├── RoleRequestActivity.kt
    │       │   │               ├── ScreenInteractionService.kt
    │       │   │               ├── SettingsActivity.kt
    │       │   │               ├── agents/
    │       │   │               │   └── ClarificationAgent.kt
    │       │   │               ├── api/
    │       │   │               │   ├── EmbeddingService.kt
    │       │   │               │   ├── Eyes.kt
    │       │   │               │   ├── Finger.kt
    │       │   │               │   ├── GeminiApi.kt
    │       │   │               │   ├── GoogleTTS.kt
    │       │   │               │   ├── MemoryService.kt
    │       │   │               │   ├── PicovoiceKeyManager.kt
    │       │   │               │   ├── PorcupineWakeWordDetector.kt
    │       │   │               │   ├── TavilyApi.kt
    │       │   │               │   └── WakeWordDetector.kt
    │       │   │               ├── crawler/
    │       │   │               │   ├── AppMap.kt
    │       │   │               │   ├── DrawDebugLabeller.kt
    │       │   │               │   └── SemanticParser.kt
    │       │   │               ├── data/
    │       │   │               │   ├── AppDatabase.kt
    │       │   │               │   ├── Memory.kt
    │       │   │               │   ├── MemoryDao.kt
    │       │   │               │   ├── MemoryExtractor.kt
    │       │   │               │   ├── MemoryManager.kt
    │       │   │               │   └── TaskHistoryItem.kt
    │       │   │               ├── intents/
    │       │   │               │   ├── AppIntent.kt
    │       │   │               │   ├── IntentRegistry.kt
    │       │   │               │   └── impl/
    │       │   │               │       ├── DialIntent.kt
    │       │   │               │       ├── EmailComposeIntent.kt
    │       │   │               │       ├── ShareTextIntent.kt
    │       │   │               │       └── ViewUrlIntent.kt
    │       │   │               ├── services/
    │       │   │               │   ├── EnhancedWakeWordService.kt
    │       │   │               │   ├── FloatingPandaButtonService.kt
    │       │   │               │   └── WakeWorkService.kt
    │       │   │               ├── triggers/
    │       │   │               │   ├── BootReceiver.kt
    │       │   │               │   ├── ChargingStateReceiver.kt
    │       │   │               │   ├── PandaNotificationListenerService.kt
    │       │   │               │   ├── PermissionUtils.kt
    │       │   │               │   ├── Trigger.kt
    │       │   │               │   ├── TriggerManager.kt
    │       │   │               │   ├── TriggerMonitoringService.kt
    │       │   │               │   ├── TriggerReceiver.kt
    │       │   │               │   └── ui/
    │       │   │               │       ├── AppAdapter.kt
    │       │   │               │       ├── ChooseTriggerTypeActivity.kt
    │       │   │               │       ├── CreateTriggerActivity.kt
    │       │   │               │       ├── TriggerAdapter.kt
    │       │   │               │       └── TriggersActivity.kt
    │       │   │               ├── ui/
    │       │   │               │   ├── DeltaSymbolView.kt
    │       │   │               │   ├── SmallDeltaGlowView.kt
    │       │   │               │   └── theme/
    │       │   │               │       ├── Color.kt
    │       │   │               │       ├── Theme.kt
    │       │   │               │       └── Type.kt
    │       │   │               ├── utilities/
    │       │   │               │   ├── ApiKeyManager.kt
    │       │   │               │   ├── AppContextUtility.kt
    │       │   │               │   ├── DeltaStateColorMapper.kt
    │       │   │               │   ├── DeltaSymbolAnimator.kt
    │       │   │               │   ├── DeltaSymbolTestUtil.kt
    │       │   │               │   ├── FreemiumManager.kt
    │       │   │               │   ├── LLMHelperFunctions.kt
    │       │   │               │   ├── Logger.kt
    │       │   │               │   ├── NetworkConnectivityManager.kt
    │       │   │               │   ├── NetworkNotifier.kt
    │       │   │               │   ├── OnboardingManager.kt
    │       │   │               │   ├── PandaState.kt
    │       │   │               │   ├── PandaStateManager.kt
    │       │   │               │   ├── PermissionManager.kt
    │       │   │               │   ├── Persistent.kt
    │       │   │               │   ├── ServicePermissionManager.kt
    │       │   │               │   ├── SpeechCoordinator.kt
    │       │   │               │   ├── STTManager.kt
    │       │   │               │   ├── STTVisualizer.kt
    │       │   │               │   ├── TTSManager.kt
    │       │   │               │   ├── TtsVisualizer.kt
    │       │   │               │   ├── UserIdManager.kt
    │       │   │               │   ├── UserInputManager.kt
    │       │   │               │   ├── UserProfileManager.kt
    │       │   │               │   ├── VideoAssetManager.kt
    │       │   │               │   ├── VisualFeedbackManager.kt
    │       │   │               │   ├── VoicePreferenceManager.kt
    │       │   │               │   └── WakeWordManager.kt
    │       │   │               └── v2/
    │       │   │                   ├── Agent.kt
    │       │   │                   ├── AgentModel.kt
    │       │   │                   ├── AgentService.kt
    │       │   │                   ├── PromptBuilder.kt
    │       │   │                   ├── actions/
    │       │   │                   │   ├── Action.kt
    │       │   │                   │   └── ActionExecutor.kt
    │       │   │                   ├── fs/
    │       │   │                   │   └── FileSystem.kt
    │       │   │                   ├── llm/
    │       │   │                   │   ├── GeminiAPI.kt
    │       │   │                   │   └── models.kt
    │       │   │                   ├── message_manager/
    │       │   │                   │   ├── MessageManager.kt
    │       │   │                   │   └── models.kt
    │       │   │                   └── perception/
    │       │   │                       ├── Perception.kt
    │       │   │                       ├── ScreenAnalysis.kt
    │       │   │                       └── SemanticParser.kt
    │       │   └── res/
    │       │       ├── anim/
    │       │       │   ├── glow_animation.xml
    │       │       │   └── pulse_animation.xml
    │       │       ├── drawable/
    │       │       │   ├── bg_solid.xml
    │       │       │   ├── btn_with_border.xml
    │       │       │   ├── edit_text_border.xml
    │       │       │   ├── feature_check_background.xml
    │       │       │   ├── floating_button_background.xml
    │       │       │   ├── floating_panda_text_background.xml
    │       │       │   ├── glass_background.xml
    │       │       │   ├── ic_accessibility.xml
    │       │       │   ├── ic_add.xml
    │       │       │   ├── ic_arrow_back.xml
    │       │       │   ├── ic_check_circle.xml
    │       │       │   ├── ic_delta_large.xml
    │       │       │   ├── ic_delta_small.xml
    │       │       │   ├── ic_delta_symbol.xml
    │       │       │   ├── ic_home_triangle.xml
    │       │       │   ├── ic_launcher_background.xml
    │       │       │   ├── ic_launcher_foreground.xml
    │       │       │   ├── ic_login.xml
    │       │       │   ├── ic_mic.xml
    │       │       │   ├── ic_microphone.xml
    │       │       │   ├── ic_moments.xml
    │       │       │   ├── ic_overlay.xml
    │       │       │   ├── ic_upgrade.xml
    │       │       │   ├── input_box_background.xml
    │       │       │   ├── outline_hourglass_bottom_24.xml
    │       │       │   ├── outline_settings_24.xml
    │       │       │   ├── picker_divider_transparent.xml
    │       │       │   ├── pricing_card_background.xml
    │       │       │   ├── pro_badge_background.xml
    │       │       │   ├── purchase_button_background.xml
    │       │       │   ├── rounded_background.xml
    │       │       │   ├── rounded_button.xml
    │       │       │   ├── rounded_button_bg.xml
    │       │       │   ├── rounded_button_secondary.xml
    │       │       │   ├── selection_window_background.xml
    │       │       │   ├── status_background_denied.xml
    │       │       │   ├── status_background_granted.xml
    │       │       │   ├── status_tag_background.xml
    │       │       │   ├── voice_input_button_bg.xml
    │       │       │   └── warning_background.xml
    │       │       ├── font/
    │       │       │   ├── megrim.xml
    │       │       │   ├── oxanium.xml
    │       │       │   ├── oxanium_extralight.xml
    │       │       │   ├── playfair_display.xml
    │       │       │   └── roboto.xml
    │       │       ├── layout/
    │       │       │   ├── activity_base_navigation.xml
    │       │       │   ├── activity_chat.xml
    │       │       │   ├── activity_choose_trigger_type.xml
    │       │       │   ├── activity_create_trigger.xml
    │       │       │   ├── activity_dialogue.xml
    │       │       │   ├── activity_main_content.xml
    │       │       │   ├── activity_memories.xml
    │       │       │   ├── activity_moments.xml
    │       │       │   ├── activity_moments_content.xml
    │       │       │   ├── activity_onboarding.xml
    │       │       │   ├── activity_onboarding_stepper.xml
    │       │       │   ├── activity_permissions.xml
    │       │       │   ├── activity_privacy.xml
    │       │       │   ├── activity_pro_purchase.xml
    │       │       │   ├── activity_settings.xml
    │       │       │   ├── activity_triggers.xml
    │       │       │   ├── assistant_session_view.xml
    │       │       │   ├── dialog_add_memory.xml
    │       │       │   ├── dialog_wake_word_failure.xml
    │       │       │   ├── floating_panda_button.xml
    │       │       │   ├── item_app.xml
    │       │       │   ├── item_memory.xml
    │       │       │   ├── item_message.xml
    │       │       │   ├── item_task_history.xml
    │       │       │   ├── item_trigger.xml
    │       │       │   ├── overlay_input_box.xml
    │       │       │   ├── overlay_input_container.xml
    │       │       │   ├── panda_widget_layout.xml
    │       │       │   ├── pro_upgrade_banner.xml
    │       │       │   ├── spinner_closed_item.xml
    │       │       │   └── spinner_dropdown_item.xml
    │       │       ├── menu/
    │       │       │   └── menu_memories.xml
    │       │       ├── mipmap-anydpi-v26/
    │       │       │   ├── ic_launcher.xml
    │       │       │   └── ic_launcher_round.xml
    │       │       ├── mipmap-hdpi/
    │       │       │   ├── ic_launcher.webp
    │       │       │   └── ic_launcher_round.webp
    │       │       ├── mipmap-mdpi/
    │       │       │   ├── ic_launcher.webp
    │       │       │   └── ic_launcher_round.webp
    │       │       ├── mipmap-xhdpi/
    │       │       │   ├── ic_launcher.webp
    │       │       │   └── ic_launcher_round.webp
    │       │       ├── mipmap-xxhdpi/
    │       │       │   ├── ic_launcher.webp
    │       │       │   └── ic_launcher_round.webp
    │       │       ├── mipmap-xxxhdpi/
    │       │       │   ├── ic_launcher.webp
    │       │       │   └── ic_launcher_round.webp
    │       │       ├── values/
    │       │       │   ├── colors.xml
    │       │       │   ├── dimens.xml
    │       │       │   ├── font_certs.xml
    │       │       │   ├── preloaded_fonts.xml
    │       │       │   ├── strings.xml
    │       │       │   └── themes.xml
    │       │       ├── values-night/
    │       │       │   ├── colors.xml
    │       │       │   └── themes.xml
    │       │       └── xml/
    │       │           ├── accessibility_service_config.xml
    │       │           ├── backup_rules.xml
    │       │           ├── data_extraction_rules.xml
    │       │           ├── network_security_config.xml
    │       │           ├── panda_widget_info.xml
    │       │           ├── shortcuts.xml
    │       │           └── voice_interaction_service.xml
    │       └── test/
    │           └── java/
    │               └── com/
    │                   └── blurr/
    │                       └── voice/
    │                           ├── ConversationalAgentServiceTest.kt
    │                           ├── ExampleUnitTest.kt
    │                           ├── VersionManagementTest.kt
    │                           ├── WakeWordButtonRelocationTest.kt
    │                           ├── agent/
    │                           │   └── v2/
    │                           │       └── SystemPromptTest.kt
    │                           └── utilities/
    │                               └── PandaStateManagerTest.kt
    ├── docs/
    │   ├── ACCESSIBILITY_DISCLOSURE_IMPROVEMENTS.md
    │   ├── AUTOMATED_VERSION_MANAGEMENT.md
    │   ├── DIRECT_APP_OPENING.md
    │   ├── INTERACTIVE_DIALOGUE_SYSTEM.md
    │   ├── MEMORY_STATUS.md
    │   ├── PORCUPINE_SETUP.md
    │   ├── SPEECH_COORDINATOR_IMPLEMENTATION.md
    │   ├── STT_IMPLEMENTATION.md
    │   ├── STT_MULTIPLE_ATTEMPTS_UPDATE.md
    │   ├── STT_THREAD_SAFETY_FIX.md
    │   ├── STT_USER_INPUT_IMPLEMENTATION.md
    │   ├── TRIGGER_SYSTEM.md
    │   ├── TTS_DEBUG_MODE.md
    │   └── WAKE_WORD_BUTTON_RELOCATION.md
    ├── gradle/
    │   ├── libs.versions.toml
    │   └── wrapper/
    │       └── gradle-wrapper.properties
    ├── .github/
    │   └── copilot-instructions.md
    └── .kiro/
        └── specs/
            └── main-ui-redesign/
                ├── design.md
                ├── requirements.md
                └── tasks.md

================================================
FILE: README.md
================================================
# 🐼 Panda: Your Personal AI Phone Operator  
**You touch grass. I'll touch your glass.**  
[![Join Discord](https://img.shields.io/badge/Join%20Discord-5865F2?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/b2hxFNXvWk)
<a href='https://play.google.com/store/apps/details?id=com.blurr.voice&hl=en_US&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img alt='Get it on Google Play' src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png' width=250/></a>
[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/Ayush0Chaudhary/blurr)
---

# Demos:

#### Explaining all the triggers of Panda
 [![Watch the video](https://img.youtube.com/vi/IDvuqmPyKZs/hqdefault.jpg)](https://www.youtube.com/embed/IDvuqmPyKZs)

#### Sending Welcome message to all the new Connections on Linkedin
 [![Watch the video](https://img.youtube.com/vi/JO_EWFYJJjA/hqdefault.jpg)](https://www.youtube.com/embed/JO_EWFYJJjA)

#### 5 task demo: 
https://github.com/user-attachments/assets/cf76bb00-2bf4-4274-acad-d9f4c0d47188


**Panda** is a proactive, on-device AI agent for Android that autonomously understands natural language commands and operates your phone's UI to achieve them. Inspired by the need to make modern technology more accessible, Panda acts as your personal operator, capable of handling complex, multi-step tasks across different applications.

[![Project Status: WIP](https://img.shields.io/badge/project%20status-wip-yellow.svg)](https://wip.vost.pt/)
[![License: Personal Use](https://img.shields.io/badge/License-Personal%20Use%20Only-red.svg)](./LICENSE)
[![Kotlin Version](https://img.shields.io/badge/Kotlin-1.9.22-7F52FF.svg?logo=kotlin)](https://kotlinlang.org)

## Core Capabilities

* 🧠 **Intelligent UI Automation:** Panda sees the screen, understands the context of UI elements, and performs actions like tapping, swiping, and typing to navigate apps and complete tasks.
* 📢 **High Qaulity voice:** Panda have high quality voice by GCS's Chirp  
* 💾 **Persistent & Personalized local Memory:** ⚠️ **Temporarily Disabled** - Panda memory is turned off as of yet. Memory functionality will be restored in a future update.

## Architecture Overview

Panda is built on a sophisticated multi-agent system written entirely in Kotlin. This architecture separates responsibilities, allowing for more complex and reliable reasoning.

* **Eyes & Hands (The Actuator):** The **Android Accessibility Service** serves as the agent's physical connection to the device, providing the low-level ability to read the screen element hierarchy and programmatically perform touch gestures.
* **The Brain (The LLM):** All high-level reasoning, planning, and analysis are powered by **LLM** models. This is where decisions are made.
* **The Agent:**
    * **Operator:** This is executor with Notepad.


## 🚀 Getting Started

### Prerequisites
* Android Studio (latest version recommended)
* An Android device or emulator with API level 26+
* Some Gemini keys, sample ENV
```python
# the name of these keys donot mean you need google cloud, you can use any servers that can accept requests, i will improve the developer experience in the future by making openapi compatible
GCLOUD_PROXY_URL=<url-of-any-backend-that-accept-responses-like-below-payload>
GCLOUD_PROXY_URL_KEY=<any-password-you-wanna-set-or-leave-empty>
```
`payload`
```
{
  "modelName": "model-name",
  "messages": [
    {
      "role": "user",
      "parts": [
        {
          "text": "Hello, what can you do?"
        }
      ]
    },
    {
      "role": "model",
      "parts": [
        {
          "text": "I can help you with a variety of tasks. What do you need assistance with today?"
        }
      ]
    }
  ]
}
```
or
```
//you can also add gemini keys to play around

GEMINI_API_KEYS=
```




### Installation

1.  **Clone the repository:**
    ```bash
    git clone [https://github.com/ayush0chaudhary/blurr.git](https://github.com/ayush0chaudhary/blurr.git)
    cd blurr
    ```

2.  **Build & Run:**
    * Open the project in Android Studio.
    * Let Gradle sync all the dependencies.
    * Run the app on your selected device or emulator.

3.  **Enable Accessibility Service:**
    * On the first run, the app will prompt you to grant Accessibility permission.
    * Click "Grant Access" and enable the "Panda" service in your phone's settings. This is required for the agent to see and control the screen.

## 🗺️ What's Next for Panda (Roadmap)

Panda is currently a powerful proof-of-concept, and the roadmap is focused on making it a truly indispensable assistant.

* [ ] **NOT UPDATED:** List not updated

## 🤝 Contributing

Contributions are welcome! If you have ideas for new features or improvements, feel free to open an issue or submit a pull request.

## 📜 License

This project is licensed under a Personal Use License - see the [LICENSE](LICENSE) file for details.

**Personal & Educational Use:** Free to use, modify, and distribute for personal, educational, and non-commercial purposes.

**Commercial Use:** Requires a separate commercial license. Please contact Panda AI for commercial licensing terms.

### A small video to help you understand what the project is about. 
https://github.com/user-attachments/assets/b577072e-2f7f-42d2-9054-3a11160cf87d

Write you api key in in local.properties, more keys you use, better is the speed 😉

# View logs in real-time
adb logcat | grep GeminiApi

## Star History

[![Star History Chart](https://api.star-history.com/svg?repos=Ayush0Chaudhary/blurr&type=Timeline)](https://www.star-history.com/#Ayush0Chaudhary/blurr&Timeline)



================================================
FILE: build.gradle.kts
================================================
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false
    id("com.google.gms.google-services") version "4.4.3" apply false
    id("com.google.firebase.crashlytics") version "3.0.6" apply false

}


================================================
FILE: gradle.properties
================================================
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true


================================================
FILE: gradlew
================================================
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"



================================================
FILE: gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: LICENSE
================================================
PERSONAL USE LICENSE

Copyright (c) 2025 Panda AI

GRANT OF LICENSE

Subject to the terms and conditions of this license, Panda AI hereby grants you a non-exclusive, non-transferable license to use, copy, modify, and distribute this software and its associated documentation (the "Software") for personal, educational, and non-commercial purposes only.

RESTRICTIONS

1. COMMERCIAL USE PROHIBITED: You may not use the Software or any derivative works for any commercial purpose, including but not limited to:
   - Selling the Software or derivative works
   - Using the Software in a commercial product or service
   - Using the Software to generate revenue
   - Incorporating the Software into commercial applications

2. DISTRIBUTION: You may distribute the Software provided that:
   - This license notice is included in all copies
   - The distribution is for non-commercial purposes only
   - Recipients are bound by the same license terms

3. MODIFICATION: You may modify the Software for personal and non-commercial use, provided that any distribution of modified versions includes this license and clearly indicates the modifications made.

COMMERCIAL LICENSING

For commercial use, including but not limited to integration into commercial products, resale, or any revenue-generating activities, you must obtain a separate commercial license from Panda AI. Please contact Panda AI for commercial licensing terms.

DISCLAIMER

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

TERMINATION

This license automatically terminates if you breach any of its terms. Upon termination, you must cease all use and distribution of the Software and destroy all copies in your possession.



================================================
FILE: local.properties.template
================================================
# This is a template for local.properties
# Copy this file to local.properties and add your actual Picovoice access key

# Add your Picovoice access key here
# Get it from: https://console.picovoice.ai/
PICOVOICE_ACCESS_KEY=your_actual_access_key_here

# Other Android SDK properties (these are usually auto-generated)
# sdk.dir=/path/to/your/android/sdk 


================================================
FILE: privacy-policy.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Policy for Panda</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3 {
            font-weight: 600;
        }
        code {
            background-color: #f6f8fa;
            padding: 3px 5px;
            border-radius: 5px;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<h1>Privacy Policy for Panda</h1>
<p><strong>Effective Date:</strong> August 9, 2025</p>
<p>Thank you for using Panda ("the App"), your personal AI phone operator. This Privacy Policy explains what information we collect, how we use and share it, and your choices regarding your information.</p>
<h2>1. Information We Collect</h2>
<p>To function as an on-device AI agent, Panda requires access to certain information. We are committed to transparency and only collecting what is necessary to provide and improve the service.</p>
<p><strong>a) Screen Content (via Accessibility Service)</strong><br>
    To understand your requests and operate your phone's user interface, the app uses the Android Accessibility Service. This service allows Panda to collect:</p>
<ul>
    <li><strong>UI Element Information:</strong> Text, content descriptions, and resource IDs of elements on your screen.</li>
    <li><strong>Screen Structure:</strong> The hierarchical layout of your screen (as XML data).</li>
    <li><strong>Screenshots:</strong> The app has the capability to take screenshots to provide visual context to its AI models.</li>
    <li><strong>This information is collected to understand the current state of your device to perform actions like tapping, swiping, and typing on your behalf.</strong></li>
</ul>
<p><strong>b) Audio Information (via Microphone Permission)</strong><br>
    The app requires the <code>RECORD_AUDIO</code> permission to:</p>
<ul>
    <li><strong>Process Voice Commands:</strong> When you speak a command, the audio is processed to convert it into text.</li>
    <li><strong>Wake Word Detection:</strong> The app listens for the "Panda" wake word to activate. This processing is done <strong>entirely on your device</strong> by the Picovoice Porcupine engine; your ambient audio is not sent to the cloud for wake word detection.</li>
</ul>
<p><strong>c) User Instructions &amp; Conversations</strong><br>
    We collect the text of your typed or spoken commands and the history of your conversation with Panda during a session to understand your goals and provide relevant responses.</p>
<p><strong>d) Installed Applications Information</strong><br>
    The app uses the <code>QUERY_ALL_PACKAGES</code> permission to get a list of your installed applications. This information is used solely to identify apps by name so Panda can open them for you more quickly and reliably.</p>
<p><strong>e) User-Created Memories (On-Device Storage)</strong></p>
<ul>
    <li><strong>Automatic Extraction:</strong> Facts may be extracted from your conversations to personalize your experience (e.g., remembering your brother's name if you mention it). This analysis is performed by Google's Gemini AI.</li>
    <li><strong>Manual Creation:</strong> You can manually add facts in the "My Memories" section.</li>
    <li><strong>All extracted and created memories are stored in a secure, private database on your device.</strong> They are not accessible by other applications.</li>
</ul>
<p><strong>f) Unique User Identifier</strong><br>
    The app generates a random, anonymous Unique User ID (UUID) that is stored on your device. This helps in managing your memories and sessions without using any personal identifiers like your name or email.</p>
<p><strong>g) Log Data for Debugging</strong><br>
    To diagnose and fix issues, we log some interaction data with our third-party AI services. This data is sent to Google Firebase Firestore and includes the AI prompt, the AI's response, the AI model used, and success/error status. This log data is not linked to your personal identity.</p>
<h2>2. How We Use Your Information</h2>
<ul>
    <li><strong>To Provide Core Functionality:</strong> To understand your commands and automate actions on your device.</li>
    <li><strong>To Personalize Your Experience:</strong> To use your stored memories to provide more context-aware and helpful responses.</li>
    <li><strong>To Improve the Service:</strong> To analyze anonymized log data to debug issues and enhance the app's performance and reliability.</li>
</ul>
<h2>3. Data Sharing and Third-Party Services</h2>
<p>Panda is a complex AI system and relies on a few specialized third-party services to function. We do not sell your data.</p>
<ul>
    <li><strong>Google (Gemini AI Models):</strong> Your conversations, screen content (XML or screenshots), and text from new memories are sent to Google's Generative AI services for processing, reasoning, and analysis. This is essential for the AI to understand context and generate responses. Your data is subject to <a href="https://policies.google.com/privacy">Google's Privacy Policy</a>.</li>
    <li><strong>Google (Firebase Firestore):</strong> Anonymized log data of AI interactions is stored in Google's Firestore for debugging and service improvement, as described in section 1(g).</li>
    <li><strong>Tavily (Search API):</strong> If a task requires web research, a search query derived from your instruction is sent to the Tavily Search API to find information. This is subject to <a href="https://tavily.com/privacy">Tavily's Privacy Policy</a>.</li>
    <li><strong>Picovoice (Porcupine Wake Word):</strong> As stated in section 1(b), wake word detection is processed <strong>100% on your device</strong>. No audio is sent to Picovoice's servers.</li>
</ul>
<h2>4. Your Control and Choices</h2>
<p>You are in control of your data.</p>
<ul>
    <li><strong>Managing Memories:</strong> You can view, add, and permanently delete any or all of your memories at any time from the "My Memories" screen within the app.</li>
    <li><strong>Revoking Permissions:</strong> You can revoke the Accessibility Service, Microphone, and Overlay permissions at any time through your device's Android Settings. Please note that revoking these permissions will limit or disable Panda's core functionality.</li>
</ul>
<h2>5. Changes to This Privacy Policy</h2>
<p>We may update this policy from time to time. We will notify you of any changes by posting the new policy in this section of the app.</p>
<h2>6. Contact Us</h2>
<p>If you have any questions about this Privacy Policy, please contact us at: <strong>ayush0000ayush@gmail.com</strong></p>

</body>
</html>


================================================
FILE: settings.gradle.kts
================================================
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
        maven("https://jitpack.io")
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}

rootProject.name = "blurr"
include(":app")
 


================================================
FILE: version.properties
================================================
# Version configuration for Blurr Android App
# This file is automatically updated during release builds
# Do not modify manually - use Gradle tasks to update versions

# Current version code (integer - increments by 1 each release)
VERSION_CODE=51

# Current version name (semantic version - increments patch number each release)
VERSION_NAME=1.0.51


================================================
FILE: app/build.gradle.kts
================================================
import java.util.Properties
import java.io.FileInputStream
import java.io.FileOutputStream

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    id("com.google.gms.google-services")
    alias(libs.plugins.ksp)
    id("org.jetbrains.kotlin.plugin.serialization") version "2.2.10"
    id("com.google.firebase.crashlytics")

}

val localProperties = Properties()
val localPropertiesFile = rootProject.file("local.properties")
if (localPropertiesFile.exists()) {
    localProperties.load(FileInputStream(localPropertiesFile))
}

// Load version properties
val versionProps = Properties()
val versionPropsFile = rootProject.file("version.properties")
if (versionPropsFile.exists()) {
    versionProps.load(FileInputStream(versionPropsFile))
}

android {
    namespace = "com.blurr.voice"
    compileSdk = 35

    // Common API keys and configuration - extracted to avoid duplication
    val apiKeys = localProperties.getProperty("GEMINI_API_KEYS") ?: ""
    val tavilyApiKeys = localProperties.getProperty("TAVILY_API") ?: ""
    val mem0ApiKey = localProperties.getProperty("MEM0_API") ?: ""
    val picovoiceApiKey = localProperties.getProperty("PICOVOICE_ACCESS_KEY") ?: ""
    val googleTtsApiKey = localProperties.getProperty("GOOGLE_TTS_API_KEY") ?: ""
    val googlecloudGatewayPicovoice = localProperties.getProperty("GCLOUD_GATEWAY_PICOVOICE_KEY") ?: ""
    val googlecloudGatewayURL = localProperties.getProperty("GCLOUD_GATEWAY_URL") ?: ""
    val googlecloudProxyURL = localProperties.getProperty("GCLOUD_PROXY_URL") ?: ""
    val googlecloudProxyURLKey = localProperties.getProperty("GCLOUD_PROXY_URL_KEY") ?: ""
    val revenueCatSDK = localProperties.getProperty("REVENUE_CAT_PUBLIC_URL") ?: ""
    val revenueCatApiKey = localProperties.getProperty("REVENUECAT_API_KEY") ?: ""

    val debugSha1 = "D0:A1:49:03:FD:B5:37:DF:B5:36:51:B1:66:AE:70:11:E2:59:08:33"

    defaultConfig {
        applicationId = "com.blurr.voice"
        minSdk = 24
        targetSdk = 35
        versionCode = versionProps.getProperty("VERSION_CODE", "13").toInt()
        versionName = versionProps.getProperty("VERSION_NAME", "1.0.13")

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        
        // Common build config fields - applies to all build types
        buildConfigField("String", "GEMINI_API_KEYS", "\"$apiKeys\"")
        buildConfigField("String", "TAVILY_API", "\"$tavilyApiKeys\"")
        buildConfigField("String", "MEM0_API", "\"$mem0ApiKey\"")
        buildConfigField("String", "PICOVOICE_ACCESS_KEY", "\"$picovoiceApiKey\"")
        buildConfigField("boolean", "ENABLE_DIRECT_APP_OPENING", "true")
        buildConfigField("boolean", "SPEAK_INSTRUCTIONS", "true")
        buildConfigField("String", "GOOGLE_TTS_API_KEY", "\"$googleTtsApiKey\"")
        buildConfigField("String", "GCLOUD_GATEWAY_PICOVOICE_KEY", "\"$googlecloudGatewayPicovoice\"")
        buildConfigField("String", "GCLOUD_GATEWAY_URL", "\"$googlecloudGatewayURL\"")
        buildConfigField("String", "GCLOUD_PROXY_URL", "\"$googlecloudProxyURL\"")
        buildConfigField("String", "GCLOUD_PROXY_URL_KEY", "\"$googlecloudProxyURLKey\"")
        buildConfigField("boolean", "ENABLE_LOGGING", "true")

    }

    buildTypes {
        release {
            firebaseCrashlytics {
                nativeSymbolUploadEnabled = true
            }
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            // Debug-specific field only
            buildConfigField("String", "SHA1_FINGERPRINT", "\"$debugSha1\"")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        compose = true
        viewBinding = true
        buildConfig = true
    }
}
val libsuVersion = "6.0.0"

dependencies {

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.appcompat)
    implementation(libs.generativeai)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    implementation("com.google.android.material:material:1.11.0") // or latest

    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    implementation("com.squareup.okhttp3:okhttp:5.0.0-alpha.16")
    implementation("com.squareup.moshi:moshi:1.15.0")
    implementation("com.google.code.gson:gson:2.13.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
    // https://mvnrepository.com/artifact/androidx.test.uiautomator/uiautomator
    implementation("androidx.test.uiautomator:uiautomator:2.3.0")

    // Porcupine Wake Word Engine
    implementation("ai.picovoice:porcupine-android:3.0.2")

    implementation("com.google.firebase:firebase-analytics")

    // Room database dependencies
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    ksp("androidx.room:room-compiler:2.6.1")
    // Import the Firebase BoM
    implementation(platform(libs.firebase.bom))

    // Add the dependency for the Firebase Authentication library
    implementation(libs.firebase.auth)

    // Add the dependency for the Google Play services library
    implementation(libs.play.services.auth)

    implementation("com.google.firebase:firebase-analytics")
    implementation("com.google.firebase:firebase-crashlytics-ndk")
    implementation(libs.firebase.firestore)
    implementation("androidx.recyclerview:recyclerview:1.3.2")
    implementation("com.android.billingclient:billing-ktx:7.0.0")
}

// Task to increment version for release builds
tasks.register("incrementVersion") {
    doLast {
        val versionFile = rootProject.file("version.properties")
        val props = Properties()
        props.load(FileInputStream(versionFile))
        
        val currentVersionCode = props.getProperty("VERSION_CODE").toInt()
        val currentVersionName = props.getProperty("VERSION_NAME")
        
        // Increment version code
        val newVersionCode = currentVersionCode + 1
        
        // Increment patch version in semantic versioning (x.y.z -> x.y.z+1)
        val versionParts = currentVersionName.split(".")
        val newPatchVersion = if (versionParts.size >= 3) {
            versionParts[2].toInt() + 1
        } else {
            1
        }
        val newVersionName = if (versionParts.size >= 2) {
            "${versionParts[0]}.${versionParts[1]}.$newPatchVersion"
        } else {
            "1.0.$newPatchVersion"
        }
        
        // Update properties
        props.setProperty("VERSION_CODE", newVersionCode.toString())
        props.setProperty("VERSION_NAME", newVersionName)
        
        // Save back to file with comments
        val output = FileOutputStream(versionFile)
        output.use { fileOutput ->
            fileOutput.write("# Version configuration for Blurr Android App\n".toByteArray())
            fileOutput.write("# This file is automatically updated during release builds\n".toByteArray())
            fileOutput.write("# Do not modify manually - use Gradle tasks to update versions\n\n".toByteArray())
            fileOutput.write("# Current version code (integer - increments by 1 each release)\n".toByteArray())
            fileOutput.write("VERSION_CODE=$newVersionCode\n\n".toByteArray())
            fileOutput.write("# Current version name (semantic version - increments patch number each release)\n".toByteArray())
            fileOutput.write("VERSION_NAME=$newVersionName".toByteArray())
        }
        
        println("Version incremented to: versionCode=$newVersionCode, versionName=$newVersionName")
    }
}

// Make release builds automatically increment version
tasks.whenTaskAdded {
    if (name == "assembleRelease" || name == "bundleRelease") {
        dependsOn("incrementVersion")
    }
}


================================================
FILE: app/proguard-rules.pro
================================================
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile


================================================
FILE: app/src/androidTest/java/com/blurr/voice/ExampleInstrumentedTest.kt
================================================
package com.blurr.voice

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.blurr.app", appContext.packageName)
    }
}


================================================
FILE: app/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- All Permissions from your app -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE"/>
<!--    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE" />-->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />

    <application
        android:name=".MyApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@drawable/panda_logo_v1_512"
        android:label="@string/app_name"
        android:networkSecurityConfig="@xml/network_security_config"
        android:roundIcon="@drawable/panda_logo_v1_512"
        android:supportsRtl="true"
        android:theme="@style/Theme.Blurr"
        tools:targetApi="31">

        <!-- Your Activities -->
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:launchMode="singleTop"
            android:theme="@style/Theme.Blurr">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <meta-data
                android:name="android.app.shortcuts"
                android:resource="@xml/shortcuts" />
        </activity>

        <activity android:name=".LoginActivity" android:exported="true" android:label="Login_activity" android:theme="@style/Theme.Blurr">
            <intent-filter android:autoVerify="true">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.BROWSABLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data
                    android:scheme="https"
                    android:host="black-radius-341415.firebaseapp.com"
                    android:pathPrefix="/__/auth/links" />
            </intent-filter>
        </activity>
        <activity android:name=".ChatActivity" android:exported="true" android:label="@string/app_name" android:theme="@style/Theme.Blurr" />
        <activity android:name=".DialogueActivity" android:exported="false" android:label="@string/app_name" android:theme="@style/Theme.Blurr" android:windowSoftInputMode="adjustResize" />
        <activity android:name=".SettingsActivity" android:exported="false" android:label="@string/settings" android:theme="@style/Theme.Blurr" />
        <activity android:name=".OnboardingPermissionsActivity" android:exported="false" android:label="onboarding" android:theme="@style/Theme.Blurr" />
        <activity android:name=".PermissionsActivity" android:exported="false" android:label="@string/permissions_explained_title" android:theme="@style/Theme.Blurr" />
        <activity android:name=".MemoriesActivity" android:exported="false" android:label="My Memories" android:theme="@style/Theme.Blurr" />
        <activity android:name=".PrivacyActivity" android:exported="false" android:label="How Panda Remembers" android:theme="@style/Theme.Blurr" />
        <activity
            android:name=".RoleRequestActivity"
            android:exported="false"
            android:launchMode="singleTop"
            android:excludeFromRecents="true"
            android:theme="@style/Theme.Blurr" />

        <activity
            android:name=".AssistEntryActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:excludeFromRecents="true">
            <intent-filter>
                <action android:name="android.intent.action.ASSIST" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

        <activity android:name=".triggers.ui.TriggersActivity" android:exported="false" android:label="Triggers" android:theme="@style/Theme.Blurr" />
        <activity android:name=".triggers.ui.CreateTriggerActivity" android:exported="false" android:label="Create Trigger" android:theme="@style/Theme.Blurr" android:windowSoftInputMode="adjustResize" />
        <activity android:name=".triggers.ui.ChooseTriggerTypeActivity" android:exported="false" android:label="Choose Trigger Type" android:theme="@style/Theme.Blurr" />
        <activity android:name=".ProPurchaseActivity" android:exported="false" android:label="Upgrade to Pro" android:theme="@style/Theme.Blurr" />
        <activity android:name=".MomentsActivity" android:exported="false" android:label="Moments" android:theme="@style/Theme.Blurr" />


        <!-- Your Other Services -->
        <service
            android:name=".ScreenInteractionService"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
            android:label="@string/accessibility_service_label"
            android:exported="false">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/accessibility_service_config" />
        </service>

<!--        <service-->
<!--            android:name=".ContentModerationService"-->
<!--            android:exported="false"-->
<!--            android:foregroundServiceType="dataSync" />-->

<!--        <service-->
<!--            android:name=".services.AgentTaskService"-->
<!--            android:exported="false"-->
<!--            android:foregroundServiceType="connectedDevice" />-->

        <service
            android:name=".v2.AgentService"
            android:exported="false"
            android:foregroundServiceType="specialUse" />

        <service
            android:name=".triggers.TriggerMonitoringService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="specialUse" />

        <service android:name=".services.EnhancedWakeWordService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="microphone" />

        <service
            android:name=".ConversationalAgentService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="microphone" />

        <service
            android:name=".services.FloatingPandaButtonService"
            android:enabled="true"
            android:exported="false" />

        <service
            android:name=".triggers.PandaNotificationListenerService"
            android:label="@string/app_name"
            android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"
            android:exported="true">
            <intent-filter>
                <action android:name="android.service.notification.NotificationListenerService" />
            </intent-filter>
        </service>

        <!-- Your Widget Provider -->
        <receiver
            android:name=".PandaWidgetProvider"
            android:exported="false">
            <intent-filter>
                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
            </intent-filter>
            <meta-data
                android:name="android.appwidget.provider"
                android:resource="@xml/panda_widget_info" />
        </receiver>

        <!-- Central receiver for all app triggers -->
        <receiver
            android:name=".triggers.TriggerReceiver"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.blurr.voice.action.EXECUTE_TASK" />
            </intent-filter>
        </receiver>

        <!-- Receiver to reschedule alarms on device reboot -->
        <receiver
            android:name=".triggers.BootReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
        <meta-data
            android:name="preloaded_fonts"
            android:resource="@array/preloaded_fonts" />

    </application>

</manifest>



================================================
FILE: app/src/main/assets/Panda_en_android_v3_0_0.ppn
================================================
[Binary file]


================================================
FILE: app/src/main/assets/prompts/system_prompt.md
================================================
```
You are a tool-using AI agent designed operating in an iterative loop to automate Phone tasks. Your ultimate goal is accomplishing the task provided in <user_request>.

<intro>
You excel at following tasks:
1. Navigating complex apps and extracting precise information
2. Automating form submissions and interactive app actions
3. Gathering and saving information 
4. Using your filesystem effectively to decide what to keep in your context
5. Operate effectively in an agent loop
6. Efficiently performing diverse phone tasks
</intro>

<language_settings>
- Working language: **English**
  </language_settings>

<input>
At every step, you will be given a state with: 
1. Agent History: A chronological event stream including your previous actions and their results. This may be partially omitted.
2. User Request: This is your ultimate objective and always remains visible.
3. Agent State: Current progress, and relevant contextual memory.
4. Android State: Contains current App-Activity, open apps, interactive elements indexed for actions, visible screen content, and (sometimes) screenshots.
5. Read State: If your previous action involved reading a file or extracting content (e.g., from an app screen), the full result will be included here. This data is **only shown in the current step** and will not appear in future Agent History. You are responsible for saving or interpreting the information appropriately during this step into your file system.
</input>

<agent_history>
Agent history will be given as a list of step information as follows:

Step step_number:
Evaluation of Previous Step: Assessment of last action
Memory: Agent generated memory of this step
Actions: Agent generated actions
Action Results: System generated result of those actions
</agent_history>

<user_request>
USER REQUEST: This is your ultimate objective and always remains visible.
- This has the highest priority. Make the user happy.
- If the user request is very specific - then carefully follow each step and dont skip or hallucinate steps.
- If the task is open ended you can plan more yourself how to get it done.
  </user_request>

<agent_state>
Agent State will be given as follows:

File System: A summary of your available files in the format:
- file_name — num_lines lines

Current Step: The step in the agent loop.

Timestamp: Current date.
</agent_state>

<android_state>
1. Android State will be given as:

Current App-Activity: App-Activity name you are currently viewing.
Open Apps: Open Apps in recent apps with index.

Interactive Elements: All interactive elements will be provided in format as [index] text:<element_text> <resource_id> <element_state> <element_type>
- index: Numeric identifier for interaction
- element_text: Text inside the XML component for example "Albums"
- resource_id: This is basically the id used by developer of current app to make app interactive, might be useful to identify the element's task sometime. this field is Not always present.
- element_state: Basically state information of this particular element. for ex. (This element is clickable, enabled, focusable.)
- element_type: This is basically which android widget is this. for ex. (widget.TextView)

Examples:
* [13] text:"Albums" <> <This element is clickable, enabled, focusable.> <widget.TextView>

Note that:
- Only elements with numeric indexes in [] are interactive
- (stacked) indentation (with \t (tab)) is important and means that the element is a (XML) child of the element above (with a lower index)
- Pure text elements without [] are not interactive.
  </android_state>

<read_state>
1. This section will be displayed only if your previous action was one that returns transient data to be consumed.
2. You will see this information **only during this step** in your state. ALWAYS make sure to save this information if it will be needed later.
</read_state>

<android_rules>
Strictly follow these rules while using the Android Phone and navigating the apps:
- Only interact with elements that have a numeric [index] assigned.
- Only use indexes that are explicitly provided.
- If you need to use any app, open them by "open_app" action. More details in action desc.
- If the "open_app" is not working, just use the app drawer, by scrolling up, "open_app" might not work for some apps.
- Use system-level actions like back, switch_app, speak, and home to navigate the OS. The back action is your primary way to return to a previous screen. More will be defined.
- If the screen changes after, for example, an input text action, analyse if you need to interact with new elements, e.g. selecting the right option from the list.
- By default, only elements in the visible viewport are listed. Use swiping tools if you suspect relevant content is offscreen which you need to interact with. SWIPE ONLY if there are more pixels below or above the screen. The extract content action gets the full loaded screen content.
- If a captcha appears, attempt solving it if possible. If not, use fallback strategies (e.g., alternative app, backtrack).
- If expected elements are missing, try refreshing, swiping, or navigating back.
- Use multiple actions where no screen transition is expected (e.g., fill multiple fields then tap submit).
- If the screen is not fully loaded, use the wait action.
- If you fill an input field and your action sequence is interrupted, most often something changed e.g. suggestions popped up under the field.
- If the USER REQUEST includes specific screen information such as product type, rating, price, location, etc., try to apply filters to be more efficient. Sometimes you need to swipe to see all filter options.
- The USER REQUEST is the ultimate goal. If the user specifies explicit steps, they have always the highest priority.
</android_rules>

<file_system>
- You have access to a persistent file system which you can use to track progress, store results, and manage long tasks.
- Your file system is initialized with two files:
    1. `todo.md`: Use this to keep a checklist for known subtasks. Update it to mark completed items and track what remains. This file should guide your step-by-step execution when the task involves multiple known entities (e.g., a list of apps or items to visit). The contents of this file will be also visible in your state. ALWAYS use `write_file` to rewrite entire `todo.md` when you want to update your progress. NEVER use `append_file` on `todo.md` as this can explode your context.
    2. `results.md`: Use this to accumulate extracted or generated results for the user. Append each new finding clearly and avoid duplication. This file serves as your output log but If user asked explicitly to summarize the screen, you will have to speak the summary using speak action, DONT JUST ADD THE RESULT, you are interacting with human too.
- You can read, write, and append to files.
- Note that `write_file` rewrites the entire file, so make sure to repeat all the existing information if you use this action.
- When you `append_file`, ALWAYS put newlines in the beginning and not at the end.
- Always use the file system as the source of truth. Do not rely on memory alone for tracking task state.
</file_system>

<task_completion_rules>
You must call the `done` action in one of two cases:
- When you have fully completed the USER REQUEST.
- When you reach the final allowed step (`max_steps`), even if the task is incomplete.
- If it is ABSOLUTELY IMPOSSIBLE to continue.

The `done` action is your opportunity to terminate and share your findings with the user.
- Set `success` to `true` only if the full USER REQUEST has been completed with no missing components.
- If any part of the request is missing, incomplete, or uncertain, set `success` to `false`.
- You are ONLY ALLOWED to call `done` as a single action. Don't call it together with other actions.
- If the user asks for specified format, such as "return JSON with following structure", "return a list of format...", MAKE sure to use the right format in your answer.
</task_completion_rules>

<action_rules>
- You are allowed to use a maximum of {max_actions} actions per step.

If you are allowed multiple actions:
- You can specify multiple actions in the list to be executed sequentially (one after another). But always specify only one action name per item.
- If the app-screen changes after an action, the sequence is interrupted and you get the new state. You might have to repeat the same action again so that your changes are reflected in the new state.
- ONLY use multiple actions when actions should not change the screen state significantly.
- If you think something needs to communicated with the user, please use speak command. For example request like summarize the current screen.
- If user have question about the current screen, don't go to another app.

If you are allowed 1 action, ALWAYS output only 1 most reasonable action per step. If you have something in your read_state, always prioritize saving the data first.
</action_rules>

<reasoning_rules>
You must reason explicitly and systematically at every step in your `thinking` block.

Exhibit the following reasoning patterns to successfully achieve the <user_request>:
- Reason about <agent_history> to track progress and context toward <user_request>.
- Analyze the most recent "Next Goal" and "Action Result" in <agent_history> and clearly state what you previously tried to achieve.
- Analyze all relevant items in <agent_history>, <android_state>, <read_state>, <file_system>, <read_state> and the screenshot to understand your state.
- Explicitly judge success/failure/uncertainty of the last action.
- If todo.md is empty and the task is multi-step, generate a stepwise plan in todo.md using file tools.
- Analyze `todo.md` to guide and track your progress.
- If any todo.md items are finished, mark them as complete in the file.
- Analyze the <read_state> where one-time information are displayed due to your previous action. Reason about whether you want to keep this information in memory and plan writing them into a file if applicable using the file tools.
- If you see information relevant to <user_request>, plan saving the information into a file.
- Decide what concise, actionable context should be stored in memory to inform future reasoning.
- When ready to finish, state you are preparing to call done and communicate completion/results to the user.
- When you user ask you to sing, or do any task that require production of sound, just use the speak action
  </reasoning_rules>

<available_actions>
You have the following actions available. You MUST ONLY use the actions and parameters defined here.

{available_actions}
</available_actions>

<output>
You must ALWAYS respond with a valid JSON in this exact format.

To execute multiple actions in a single step, add them as separate objects to the action list. Actions are executed sequentially in the order they are provided.

Single Action Example:
{
"thinking": "...",
"evaluation_previous_goal": "...",
"memory": "...",
"next_goal": "...",
"action": [
{"tap_element": {"element_id": 123}}
]
}

Multiple Action Example:
{
"thinking": "The user wants me to log in. I will first type the username into the username field [25], then type the password into the password field [30], and finally tap the login button [32].",
"evaluation_previous_goal": "The previous step was successful.",
"memory": "Ready to input login credentials.",
"next_goal": "Enter username and password, then tap login.",
"action": [
{"type": {"text": "my_username"}},
{"type": {"text": "my_super_secret_password"}},
{"tap_element": {"element_id": 32}}
]
}

Your response must follow this structure:
{
"thinking": "A structured <think>-style reasoning block...",
"evaluationPreviousGoal": "One-sentence analysis of your last action...",
"memory": "1-3 sentences of specific memory...",
"nextGoal": "State the next immediate goals...",
"action": [
{"action_name_1": {"parameter": "value"}},
{"action_name_2": {"parameter": "value"}}
]
}
The action list must NEVER be empty.
IMPORTANT: Your entire response must be a single JSON object, starting with { and ending with }. Do not include any text before or after the JSON object.
</output>

{intents_catalog}
```


================================================
FILE: app/src/main/java/com/blurr/voice/AssistEntryActivity.kt
================================================
package com.blurr.voice

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.util.Log
import androidx.core.content.ContextCompat

class AssistEntryActivity : Activity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        handleAssistLaunch(intent)
        // No UI — finish immediately
        finish()
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        handleAssistLaunch(intent)
        finish()
    }

    private fun handleAssistLaunch(intent: Intent?) {
        Log.d("AssistEntryActivity", "Assistant invoked via ACTION_ASSIST, intent=$intent")

        // If agent already running, you can signal it to focus/show UI instead of starting again
        if (!ConversationalAgentService.isRunning) {
            val serviceIntent = Intent(this, ConversationalAgentService::class.java).apply {
                action = "com.blurr.voice.ACTION_START_FROM_ASSIST"
                putExtra("source", "assist_gesture")       // optional metadata
            }
            ContextCompat.startForegroundService(this, serviceIntent)
        } else {
            // e.g., tell the service to bring its overlay/mic UI to front
            sendBroadcast(Intent("com.blurr.voice.ACTION_SHOW_OVERLAY"))
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/AudioWaveView.kt
================================================
package com.blurr.voice

import android.animation.ValueAnimator
import android.content.Context
import android.graphics.*
import android.util.AttributeSet
import android.view.View
import android.view.animation.AccelerateDecelerateInterpolator
import android.view.animation.LinearInterpolator
import androidx.core.graphics.toColorInt
import kotlin.math.pow
import kotlin.math.sin
import kotlin.random.Random

class AudioWaveView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs) {

    // --- Configuration Constants ---
    companion object {
        // Added for converting raw audio dB to a normalized value
        private const val MIN_DB_VALUE = -60f
        private const val MAX_DB_VALUE = -5f
    }

    private val waveCount = 7
    private val minIdleAmplitude = 0.15f
    private val maxWaveHeightScale = 0.25f
    // Corrected and swapped durations for more logical behavior
    private val targetAmplitudeTransitionDuration = 500L
    private val realtimeAmplitudeTransitionDuration = 100L
    private val maxSpeedIncrease = 4.0f
    private val jitterAmount = 0.1f

    private val waveColors = intArrayOf(
        "#8A2BE2".toColorInt(), "#4169E1".toColorInt(), "#FF1493".toColorInt(),
        "#9370DB".toColorInt(), "#00BFFF".toColorInt(), "#FF69B4".toColorInt(),
        "#DA70D6".toColorInt()
    )

    private var amplitudeAnimator: ValueAnimator? = null
    private val wavePaints = mutableListOf<Paint>()
    private val wavePaths = mutableListOf<Path>()
    private val waveFrequencies: FloatArray
    private val wavePhaseShifts: FloatArray
    private val waveSpeeds: FloatArray
    private val waveAmplitudeMultipliers: FloatArray

    private var audioAmplitude = minIdleAmplitude

    init {
        setLayerType(LAYER_TYPE_HARDWARE, null)

        waveFrequencies = FloatArray(waveCount)
        wavePhaseShifts = FloatArray(waveCount)
        waveSpeeds = FloatArray(waveCount)
        waveAmplitudeMultipliers = FloatArray(waveCount)

        val blurFilter = BlurMaskFilter(15f, BlurMaskFilter.Blur.NORMAL)

        for (i in 0 until waveCount) {
            waveFrequencies[i] = Random.nextFloat() * 0.6f + 0.8f
            wavePhaseShifts[i] = Random.nextFloat() * (Math.PI * 2).toFloat()
            waveSpeeds[i] = Random.nextFloat() * 0.02f + 0.01f
            waveAmplitudeMultipliers[i] = Random.nextFloat() * 0.5f + 0.8f

            wavePaints.add(Paint(Paint.ANTI_ALIAS_FLAG).apply {
                style = Paint.Style.FILL
                color = waveColors[i % waveColors.size]
                alpha = 120
                maskFilter = blurFilter
            })
            wavePaths.add(Path())
        }

        ValueAnimator.ofFloat(0f, 1f).apply {
            interpolator = LinearInterpolator()
            duration = 5000
            repeatCount = ValueAnimator.INFINITE
            addUpdateListener {
                val speedFactor = 1.0f + (audioAmplitude * maxSpeedIncrease)
                for (i in 0 until waveCount) {
                    wavePhaseShifts[i] += (waveSpeeds[i] * speedFactor)
                }
                invalidate()
            }
            start()
        }
    }

    /**
     * NEW: Call this from your audio processing code with the raw dB value.
     * It normalizes the value and updates the wave animation in real-time.
     * @param rmsdB The Root Mean Square decibel level of the current audio buffer.
     */
    fun updateAmplitude(rmsdB: Float) {
        // Normalize the decibel level to a 0.0 to 1.0 range
        val normalizedAmplitude = ((rmsdB - MIN_DB_VALUE) / (MAX_DB_VALUE - MIN_DB_VALUE)).coerceIn(0f, 2.0f)

        // Call the existing method to update the wave's appearance
        setRealtimeAmplitude(normalizedAmplitude)
    }


    /**
     * Instantly sets the amplitude for real-time visualization.
     * @param amplitude The raw amplitude from the visualizer (0.0 to 1.0).
     */
    fun setRealtimeAmplitude(amplitude: Float) {
        val scaledAmplitude = amplitude.pow(1.5f).coerceIn(0.0f, 1.0f)
        val targetAmplitude = minIdleAmplitude + (scaledAmplitude * maxWaveHeightScale)
        amplitudeAnimator?.cancel()
        amplitudeAnimator = ValueAnimator.ofFloat(audioAmplitude, targetAmplitude).apply {
            duration = realtimeAmplitudeTransitionDuration // Use short duration for responsiveness
            interpolator = AccelerateDecelerateInterpolator()
            addUpdateListener { animation ->
                audioAmplitude = animation.animatedValue as Float
            }
            start()
        }
    }

    /**
     * Smoothly animates the wave's amplitude to a new target level.
     * Used for non-realtime effects like a "power up" sequence.
     * @param target The target amplitude level (0.0f for idle, 1.0f for full).
     */
    fun setTargetAmplitude(target: Float) {
        val targetAmplitude = minIdleAmplitude + (target * maxWaveHeightScale)
        amplitudeAnimator?.cancel()
        amplitudeAnimator = ValueAnimator.ofFloat(audioAmplitude, targetAmplitude).apply {
            duration = targetAmplitudeTransitionDuration // Use longer duration for smooth transitions
            interpolator = AccelerateDecelerateInterpolator()
            addUpdateListener { animation ->
                audioAmplitude = animation.animatedValue as Float
            }
            start()
        }
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        for(i in 0 until waveCount) {
            val paint = wavePaints[i]
            val color = waveColors[i % waveColors.size]
            paint.shader = LinearGradient(
                0f, h / 2f, 0f, h.toFloat(),
                color, Color.TRANSPARENT, Shader.TileMode.CLAMP
            )
        }
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        for (i in 0 until waveCount) {
            wavePaths[i].reset()
            wavePaths[i].moveTo(0f, height.toFloat())
            val waveMaxHeight = height * audioAmplitude * waveAmplitudeMultipliers[i]
            val currentJitter = (Random.nextFloat() - 0.5f) * waveMaxHeight * jitterAmount
            for (x in 0..width step 5) {
                val sineInput = (x * (Math.PI * 2 / width) * waveFrequencies[i]) + wavePhaseShifts[i]
                val sineOutput = (sin(sineInput) * 0.5f + 0.5f)
                val y = height - (waveMaxHeight * sineOutput) + currentJitter
                wavePaths[i].lineTo(x.toFloat(), y.toFloat())
            }
            wavePaths[i].lineTo(width.toFloat(), height.toFloat())
            wavePaths[i].close()
            canvas.drawPath(wavePaths[i], wavePaints[i])
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/BaseNavigationActivity.kt
================================================
package com.blurr.voice

import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity

abstract class BaseNavigationActivity : AppCompatActivity() {

    protected abstract fun getContentLayoutId(): Int
    protected abstract fun getCurrentNavItem(): NavItem

    enum class NavItem {
        HOME, TRIGGERS, MOMENTS, UPGRADE, SETTINGS
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Disable any default activity transitions
        disableTransitions()
    }
    
    override fun setContentView(layoutResID: Int) {
        super.setContentView(R.layout.activity_base_navigation)
        
        // Inflate the child activity's content into the content container
        val contentContainer = findViewById<LinearLayout>(R.id.content_container)
        layoutInflater.inflate(layoutResID, contentContainer, true)
        
        setupBottomNavigation()
    }

    private fun setupBottomNavigation() {
        val currentItem = getCurrentNavItem()
        
        findViewById<LinearLayout>(R.id.nav_triggers).apply {
            setOnClickListener {
                if (currentItem != NavItem.TRIGGERS) {
                    navigateToActivity(com.blurr.voice.triggers.ui.TriggersActivity::class.java, currentItem)
                }
            }
            alpha = if (currentItem == NavItem.TRIGGERS) 1.0f else 0.7f
        }
        
        findViewById<LinearLayout>(R.id.nav_moments).apply {
            setOnClickListener {
                if (currentItem != NavItem.MOMENTS) {
                    navigateToActivity(MomentsActivity::class.java, currentItem)
                }
            }
            alpha = if (currentItem == NavItem.MOMENTS) 1.0f else 0.7f
        }
        
        findViewById<LinearLayout>(R.id.nav_home).apply {
            setOnClickListener {
                if (currentItem != NavItem.HOME) {
                    navigateToActivity(MainActivity::class.java, currentItem)
                }
            }
            alpha = if (currentItem == NavItem.HOME) 1.0f else 0.7f
        }
        
        findViewById<LinearLayout>(R.id.nav_upgrade).apply {
            setOnClickListener {
                if (currentItem != NavItem.UPGRADE) {
                    navigateToActivity(ProPurchaseActivity::class.java, currentItem)
                }
            }
            alpha = if (currentItem == NavItem.UPGRADE) 1.0f else 0.7f
        }
        
        findViewById<LinearLayout>(R.id.nav_settings).apply {
            setOnClickListener {
                if (currentItem != NavItem.SETTINGS) {
                    navigateToActivity(SettingsActivity::class.java, currentItem)
                }
            }
            alpha = if (currentItem == NavItem.SETTINGS) 1.0f else 0.7f
        }
    }
    
    private fun navigateToActivity(activityClass: Class<*>, currentItem: NavItem) {
        val intent = Intent(this, activityClass)
        startActivity(intent)
        // Disable transition animations
        disableTransitions()
        if (currentItem != NavItem.HOME) {
            finish()
            // Also disable animations when finishing
            disableTransitions()
        }
    }
    
    override fun finish() {
        super.finish()
        // Disable animations when finishing
        disableTransitions()
    }
    
    @Suppress("DEPRECATION")
    private fun disableTransitions() {
        // Use the legacy method for all Android versions since the new API
        // requires more complex setup and this works reliably
        overridePendingTransition(0, 0)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/ChatActivity.kt
================================================
package com.blurr.voice

import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView

class ChatActivity : AppCompatActivity() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var editText: EditText
    private lateinit var sendButton: Button
    private val messages = mutableListOf<Message>()
    private lateinit var chatAdapter: ChatAdapter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_chat)

        recyclerView = findViewById(R.id.recyclerView)
        editText = findViewById(R.id.editText)
        sendButton = findViewById(R.id.sendButton)

        // Get the custom message from the intent
        val customMessage = intent.getStringExtra("custom_message") ?: "Hello! How can I helpy?"

        // Set up the RecyclerView
        recyclerView.layoutManager = LinearLayoutManager(this)
        chatAdapter = ChatAdapter(messages)
        recyclerView.adapter = chatAdapter

        // Display the custom message or default message
        messages.add(Message(customMessage, isUserMessage = false))
        chatAdapter.notifyItemInserted(messages.size - 1)

        // Handle sending messages
        sendButton.setOnClickListener {
            val messageContent = editText.text.toString()
            if (messageContent.isNotEmpty()) {
                // Add the user's message
                messages.add(Message(messageContent, isUserMessage = true))
                chatAdapter.notifyItemInserted(messages.size - 1)
                recyclerView.scrollToPosition(messages.size - 1) // Scroll to the latest message

                // Clear the input field
                editText.text.clear()

                // Optionally, send a default bot response
                messages.add(Message("This is a default bot response.", isUserMessage = false))
                chatAdapter.notifyItemInserted(messages.size - 1)
                recyclerView.scrollToPosition(messages.size - 1)
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/ChatAdapter.kt
================================================
package com.blurr.voice

import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import android.graphics.Color
import androidx.recyclerview.widget.RecyclerView

data class Message(val content: String, val isUserMessage: Boolean)


class ChatAdapter(private val messages: List<Message>) : RecyclerView.Adapter<ChatAdapter.ChatViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ChatViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_message, parent, false)
        return ChatViewHolder(view)
    }

    override fun onBindViewHolder(holder: ChatViewHolder, position: Int) {
        val message = messages[position]
        holder.bind(message)
    }

    override fun getItemCount(): Int = messages.size

    class ChatViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val messageText: TextView = itemView.findViewById(R.id.messageText)

        fun bind(message: Message) {
            messageText.text = message.content
            // Style the text depending on whether it's a user message or not
            if (message.isUserMessage) {
                messageText.setBackgroundColor(Color.LTGRAY)
                messageText.gravity = Gravity.END
            } else {
                messageText.setBackgroundColor(Color.WHITE)
                messageText.gravity = Gravity.START
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/DialogueActivity.kt
================================================
package com.blurr.voice

import android.content.Intent
import android.os.Bundle
import android.view.MotionEvent
import android.view.inputmethod.EditorInfo
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.blurr.voice.utilities.TTSManager
import com.blurr.voice.utilities.STTManager
import kotlinx.coroutines.*
import kotlinx.coroutines.delay

class DialogueActivity : AppCompatActivity() {

    private lateinit var questionText: TextView
    private lateinit var answerInput: EditText
    private lateinit var submitButton: Button
    private lateinit var voiceInputButton: ImageButton
    private lateinit var voiceStatusText: TextView
    private lateinit var progressText: TextView
    private lateinit var cancelButton: Button

    private lateinit var ttsManager: TTSManager
    private lateinit var sttManager: STTManager

    private var questions: List<String> = emptyList()
    private var answers: MutableList<String> = mutableListOf()
    private var currentQuestionIndex = 0
    private var originalInstruction: String = ""

    companion object {
        const val EXTRA_ORIGINAL_INSTRUCTION = "original_instruction"
        const val EXTRA_QUESTIONS = "questions"
        const val EXTRA_ANSWERS = "answers"
        const val EXTRA_ENHANCED_INSTRUCTION = "enhanced_instruction"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_dialogue)

        // Initialize UI components
        questionText = findViewById(R.id.questionText)
        answerInput = findViewById(R.id.answerInput)
        submitButton = findViewById(R.id.submitButton)
        voiceInputButton = findViewById(R.id.voiceInputButton)
        voiceStatusText = findViewById(R.id.voiceStatusText)
        progressText = findViewById(R.id.progressText)
        cancelButton = findViewById(R.id.cancelButton)

        // Initialize managers
        ttsManager = TTSManager.getInstance(this)
        sttManager = STTManager(this)

        // Get data from intent
        originalInstruction = intent.getStringExtra(EXTRA_ORIGINAL_INSTRUCTION) ?: ""
        questions = intent.getStringArrayListExtra(EXTRA_QUESTIONS) ?: arrayListOf()

        setupUI()
        setupVoiceInput()
        setupClickListeners()

        // Start with first question
        if (questions.isNotEmpty()) {
            showQuestion(0)
        } else {
            finishWithResult()
        }
    }

    private fun setupUI() {
        // Set up progress indicator
        updateProgress()
        
        // Set up cancel button
        cancelButton.setOnClickListener {
            setResult(RESULT_CANCELED)
            finish()
        }
    }

    private fun setupVoiceInput() {
        voiceInputButton.setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    startVoiceInput()
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    stopVoiceInput()
                    true
                }
                else -> false
            }
        }
    }

    private fun setupClickListeners() {
        submitButton.setOnClickListener {
            val answer = answerInput.text.toString().trim()
            if (answer.isNotEmpty()) {
                submitAnswer(answer)
            } else {
                Toast.makeText(this, "Please provide an answer", Toast.LENGTH_SHORT).show()
            }
        }

        // Handle Enter key in input field
        answerInput.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == EditorInfo.IME_ACTION_DONE) {
                val answer = answerInput.text.toString().trim()
                if (answer.isNotEmpty()) {
                    submitAnswer(answer)
                }
                true
            } else {
                false
            }
        }
    }

    private fun startVoiceInput() {
        voiceStatusText.text = getString(R.string.listening)
        voiceInputButton.isPressed = true
        
        // Show a toast to indicate automatic voice activation
        Toast.makeText(this, "Listening for your answer...", Toast.LENGTH_SHORT).show()
        
        sttManager.startListening(
            onResult = { recognizedText ->
                runOnUiThread {
                    voiceStatusText.text = getString(R.string.hold_to_speak)
                    voiceInputButton.isPressed = false
                    answerInput.setText(recognizedText)
                    Toast.makeText(this, "Recognized: $recognizedText", Toast.LENGTH_SHORT).show()

                    // Automatically submit the answer after a short delay
                    lifecycleScope.launch {
                        delay(1000) // Wait 1 second for user to see the recognized text
                        submitAnswer(recognizedText)
                    }
                }
            },
            onError = { errorMessage ->
                runOnUiThread {
                    voiceStatusText.text = getString(R.string.hold_to_speak)
                    voiceInputButton.isPressed = false
                    Toast.makeText(this, "Error: $errorMessage", Toast.LENGTH_SHORT).show()

                    // If there was an error, restart voice input after a delay
                    lifecycleScope.launch {
                        delay(2000)
                        startVoiceInput()
                    }
                }
            },
            onListeningStateChange = { isListening ->
                runOnUiThread {
                    voiceInputButton.isPressed = isListening
                    voiceStatusText.text = if (isListening) getString(R.string.listening) else getString(R.string.hold_to_speak)
                }
            },
            // ADD THIS CALLBACK
            onPartialResult = { partialText ->
                runOnUiThread {
                    answerInput.setText(partialText)
                    answerInput.setSelection(partialText.length) // Keep cursor at the end
                }
            }
        )
    }

    private fun stopVoiceInput() {
        sttManager.stopListening()
        voiceStatusText.text = getString(R.string.hold_to_speak)
        voiceInputButton.isPressed = false
    }

    private fun showQuestion(index: Int) {
        if (index < questions.size) {
            currentQuestionIndex = index
            val question = questions[index]
            
            questionText.text = question
            answerInput.text.clear()
            answerInput.requestFocus()
            
            // Speak the question
            lifecycleScope.launch {
                ttsManager.speakText(question)
                
                // Wait for TTS to complete, then start voice input automatically
                delay(1000) // Wait 1 second after question is displayed
                runOnUiThread {
                    startVoiceInput()
                }
            }
            
            updateProgress()
        } else {
            finishWithResult()
        }
    }

    private fun submitAnswer(answer: String) {
        answers.add(answer)
        
        // Move to next question
        val nextIndex = currentQuestionIndex + 1
        if (nextIndex < questions.size) {
            showQuestion(nextIndex)
        } else {
            finishWithResult()
        }
    }

    private fun updateProgress() {
        val progress = "${currentQuestionIndex + 1} of ${questions.size}"
        progressText.text = progress
    }

    private fun finishWithResult() {
        // Create enhanced instruction with answers
        val enhancedInstruction = createEnhancedInstruction()
        
        val resultIntent = Intent().apply {
            putExtra(EXTRA_ORIGINAL_INSTRUCTION, originalInstruction)
            putExtra(EXTRA_ANSWERS, ArrayList(answers))
            putExtra(EXTRA_ENHANCED_INSTRUCTION, enhancedInstruction)
        }
        
        setResult(RESULT_OK, resultIntent)
        finish()
    }

    private fun createEnhancedInstruction(): String {
        var enhanced = originalInstruction
        
        // Add answers to the instruction
        if (answers.isNotEmpty()) {
            enhanced += "\n\nAdditional information:"
            questions.forEachIndexed { index, question ->
                if (index < answers.size) {
                    enhanced += "\n- $question: ${answers[index]}"
                }
            }
        }
        
        return enhanced
    }

    override fun onDestroy() {
        super.onDestroy()
        sttManager.shutdown()
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/GlowBorderView.kt
================================================
package com.blurr.voice

import android.content.Context
import android.graphics.*
import android.util.AttributeSet
import android.view.View
import androidx.core.graphics.toColorInt

class GlowBorderView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs) {

    private val borderPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.STROKE
        strokeWidth = 16f
        maskFilter = BlurMaskFilter(30f, BlurMaskFilter.Blur.NORMAL)
    }

    // --- THIS IS THE SECTION THAT HAS CHANGED ---

    // 1. We're back to a simple, looping array of colors.
    // The first color (Red) is repeated at the end to create a seamless loop.
    private val gradientColors = intArrayOf(
        "#FF0000".toColorInt(), // Red
        "#FF7F00".toColorInt(), // Orange
//        "#FFFF00".toColorInt(), // Yellow
//        "#00FF00".toColorInt(), // Green
        "#0000FF".toColorInt(), // Blue
//        "#4B0082".toColorInt(), // Indigo
        "#9400D3".toColorInt(), // Violet
        "#FF0000".toColorInt()  // Red again to close the loop smoothly
    )

    // 2. The 'cometPositions' array has been completely removed.

    // --- END OF THE CHANGED SECTION ---

    private val matrix = Matrix()
    private var rotationAngle = 0f

    init {
        setLayerType(LAYER_TYPE_SOFTWARE, null)
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, h)

        // Update the shader to use the full gradient.
        // We pass 'null' for the positions, which tells the gradient
        // to spread the colors evenly around the circle.
        borderPaint.shader = SweepGradient(
            w / 2f,
            h / 2f,
            gradientColors,
            null // This is the key change!
        )
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        matrix.setRotate(rotationAngle, width / 2f, height / 2f)
        borderPaint.shader.setLocalMatrix(matrix)

        canvas.drawRoundRect(
            borderPaint.strokeWidth / 2,
            borderPaint.strokeWidth / 2,
            width.toFloat() - borderPaint.strokeWidth / 2,
            height.toFloat() - borderPaint.strokeWidth / 2,
            60f,
            60f,
            borderPaint
        )
    }

    override fun setRotation(angle: Float) {
        this.rotationAngle = angle
        invalidate()
    }

    fun setGlowAlpha(alpha: Int) {
        borderPaint.alpha = alpha.coerceIn(0, 255)
        invalidate()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/LoginActivity.kt.kt
================================================
package com.blurr.voice

import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button // Changed from SignInButton
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.EditText
import android.widget.Toast
import android.graphics.Color
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.IntentSenderRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.blurr.voice.utilities.FreemiumManager
import com.blurr.voice.utilities.OnboardingManager
import com.blurr.voice.utilities.UserProfileManager
import com.google.android.gms.auth.api.identity.BeginSignInRequest
import com.google.android.gms.auth.api.identity.Identity
import com.google.android.gms.auth.api.identity.SignInClient
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.common.SignInButton
import com.google.firebase.Firebase
import com.google.firebase.auth.ActionCodeSettings
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.auth.actionCodeSettings
import com.google.firebase.auth.auth
import com.google.firebase.crashlytics.FirebaseCrashlytics
import kotlinx.coroutines.launch

class LoginActivity : AppCompatActivity() {

    private lateinit var oneTapClient: SignInClient
    private lateinit var signInRequest: BeginSignInRequest
    private lateinit var firebaseAuth: FirebaseAuth
    private lateinit var signInButton: SignInButton // Using Google's SignInButton
    private lateinit var emailField: EditText
    private lateinit var emailSendLinkButton: Button
    private lateinit var progressBar: ProgressBar
    private lateinit var loadingText: TextView

    // New ActivityResultLauncher for the modern Identity API
    private lateinit var googleSignInLauncher: ActivityResultLauncher<IntentSenderRequest>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_onboarding)

        signInButton = findViewById(R.id.googleSignInButton)
        // Customize Google Sign-In button appearance and text
        signInButton.setSize(SignInButton.SIZE_WIDE)
        signInButton.setColorScheme(SignInButton.COLOR_LIGHT)
        customizeGoogleSignInButton(signInButton)
        emailField = findViewById(R.id.emailInput)
        emailSendLinkButton = findViewById(R.id.emailSendLinkButton)
        progressBar = findViewById(R.id.progressBar)
        loadingText = findViewById(R.id.loadingText)
        firebaseAuth = Firebase.auth

        // 1. Initialize the OneTapClient
        oneTapClient = Identity.getSignInClient(this)

        // 2. Build the BeginSignInRequest
        signInRequest = BeginSignInRequest.builder()
            .setGoogleIdTokenRequestOptions(
                BeginSignInRequest.GoogleIdTokenRequestOptions.builder()
                    .setSupported(true)
                    // Your server's client ID, generated by the google-services plugin.
                    // This is crucial for Firebase authentication.
                    .setServerClientId(getString(R.string.default_web_client_id))
                    // Show all Google accounts on the device.
                    .setFilterByAuthorizedAccounts(false)
                    .build()
            )
            .build()

        // 3. Initialize the new launcher
        googleSignInLauncher = registerForActivityResult(ActivityResultContracts.StartIntentSenderForResult()) { result ->
            if (result.resultCode == RESULT_OK) {
                try {
                    // The one-tap UI returns a Sign-In Credential
                    val credential = oneTapClient.getSignInCredentialFromIntent(result.data)
                    val googleIdToken = credential.googleIdToken
                    if (googleIdToken != null) {
                        Log.d("LoginActivity", "Got Google ID Token.")
                        // Pass the token to Firebase - keep progress bar visible during Firebase auth
                        firebaseAuthWithGoogle(googleIdToken)
                    } else {
                        Log.e("LoginActivity", "Google ID Token was null.")
                        Toast.makeText(this, "Google Sign-In failed.", Toast.LENGTH_SHORT).show()
                        progressBar.visibility = View.GONE
                        loadingText.visibility = View.GONE
                        signInButton.isEnabled = true
                    }
                } catch (e: ApiException) {
                    Log.w("LoginActivity", "Google sign in failed", e)
                    FirebaseCrashlytics.getInstance().recordException(e)
                    FirebaseCrashlytics.getInstance().log("Google Sign-In failed in credential extraction with ApiException")
                    Toast.makeText(this, "Google Sign-In failed.", Toast.LENGTH_SHORT).show()
                    progressBar.visibility = View.GONE
                    loadingText.visibility = View.GONE
                    signInButton.isEnabled = true
                }
            } else {
                // User cancelled or there was an error - hide progress bar
                progressBar.visibility = View.GONE
                loadingText.visibility = View.GONE
                signInButton.isEnabled = true
            }
        }


        signInButton.setOnClickListener {
            signIn()
        }

        emailSendLinkButton.setOnClickListener {
            val email = emailField.text?.toString()?.trim()
            if (!email.isNullOrEmpty()) {
                sendSignInLink(email)
            } else {
                Toast.makeText(this, "Enter your email", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun customizeGoogleSignInButton(button: SignInButton) {
        // Replace the text and color inside Google's SignInButton
        // Note: SignInButton contains a TextView as its first child
        (0 until button.childCount)
            .map { button.getChildAt(it) }
            .firstOrNull { it is TextView }
            ?.let { tv ->
                val textView = tv as TextView
                textView.text = "Continue with Google Login"
                textView.setTextColor(Color.GRAY)
            }
    }

    private fun signIn() {
        progressBar.visibility = View.VISIBLE
        loadingText.visibility = View.VISIBLE
        signInButton.isEnabled = false
        
        Log.d("LoginActivity", "Starting Google Sign-In process")
        Log.d("LoginActivity", "Using web client ID: ${getString(R.string.default_web_client_id)}")
        
        // 4. Launch the sign-in flow
        oneTapClient.beginSignIn(signInRequest)
            .addOnSuccessListener(this) { result ->
                try {
                    Log.d("LoginActivity", "One Tap UI started successfully")
                    // The BeginSignInResult contains a PendingIntent
                    val intentSenderRequest = IntentSenderRequest.Builder(result.pendingIntent.intentSender).build()
                    // Launch the intent sender
                    googleSignInLauncher.launch(intentSenderRequest)
                } catch (e: Exception) {
                    Log.e("LoginActivity", "Couldn't start One Tap UI: ${e.localizedMessage}", e)
                    FirebaseCrashlytics.getInstance().recordException(e)
                    FirebaseCrashlytics.getInstance().log("Failed to start One Tap UI: ${e.localizedMessage}")
                    Toast.makeText(this, "Sign-in UI failed to start: ${e.localizedMessage}", Toast.LENGTH_LONG).show()
                    progressBar.visibility = View.GONE
                    loadingText.visibility = View.GONE
                    signInButton.isEnabled = true
                }
            }
            .addOnFailureListener(this) { e ->
                Log.e("LoginActivity", "Sign-in failed: ${e.localizedMessage}", e)
                FirebaseCrashlytics.getInstance().recordException(e)
                FirebaseCrashlytics.getInstance().log("Google One Tap sign-in failed: ${e.localizedMessage}")
                Toast.makeText(this, "Sign-in failed: ${e.localizedMessage}", Toast.LENGTH_LONG).show()
                progressBar.visibility = View.GONE
                loadingText.visibility = View.GONE
                signInButton.isEnabled = true
            }
    }

    private fun sendSignInLink(email: String) {
        // Configure action code settings
        val actionCodeSettings = ActionCodeSettings.newBuilder()
            .setAndroidPackageName(packageName, true, null)
            .setHandleCodeInApp(true)
            .setUrl("https://black-radius-341415.firebaseapp.com/__/auth/action")
            .build()
        Firebase.auth.sendSignInLinkToEmail(email, actionCodeSettings)
            .addOnSuccessListener {
                Log.d("EmailLink", "Email sent OK to $email")
            }
            .addOnFailureListener { e ->
                Log.e("EmailLink", "Failed to send email", e)
            }

    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        intent?.let { handleEmailLinkIntent(it) }
    }

    override fun onStart() {
        super.onStart()
        handleEmailLinkIntent(intent)
    }

    private fun handleEmailLinkIntent(intent: Intent) {
        val auth = Firebase.auth
        val data = intent.data?.toString() ?: return
        if (!auth.isSignInWithEmailLink(data)) return

        val storedEmail = getSharedPreferences("email_link", MODE_PRIVATE)
            .getString("pending_email", null)
        val email = storedEmail ?: return

        progressBar.visibility = View.VISIBLE
        loadingText.visibility = View.VISIBLE

        auth.signInWithEmailLink(email, data).addOnCompleteListener { task ->
            progressBar.visibility = View.GONE
            loadingText.visibility = View.GONE
            if (task.isSuccessful) {
                getSharedPreferences("email_link", MODE_PRIVATE)
                    .edit().remove("pending_email").apply()
                startPostAuthFlow(task.result?.additionalUserInfo?.isNewUser ?: false)
            } else {
                Toast.makeText(this, "Email link sign-in failed: ${task.exception?.localizedMessage}", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun startPostAuthFlow(isNewUser: Boolean) {
        val profileManager = UserProfileManager(this)
        val user = firebaseAuth.currentUser
        val name = user?.displayName ?: "Unknown"
        val email = user?.email ?: "unknown"
        profileManager.saveProfile(name, email)

        lifecycleScope.launch {
            val onboardingManager = OnboardingManager(this@LoginActivity)
            if (isNewUser) {
                val freemiumManager = FreemiumManager()
                freemiumManager.provisionUserIfNeeded()
            }
            if (onboardingManager.isOnboardingCompleted()) {
                startActivity(Intent(this@LoginActivity, MainActivity::class.java))
            } else {
                startActivity(Intent(this@LoginActivity, OnboardingPermissionsActivity::class.java))
            }
            finish()
        }
    }

    private fun firebaseAuthWithGoogle(idToken: String) {
        val credential = GoogleAuthProvider.getCredential(idToken, null)
        firebaseAuth.signInWithCredential(credential)
            .addOnCompleteListener(this) { task ->
                // Hide progress bar and loading text when Firebase authentication completes
                progressBar.visibility = View.GONE
                loadingText.visibility = View.GONE
                signInButton.isEnabled = true
                
                if (task.isSuccessful) {
                    val isNewUser = task.result?.additionalUserInfo?.isNewUser ?: false

                    Log.d("LoginActivity", "signInWithCredential:success")
                    // 1. Get the successfully signed-in user
                    val user = firebaseAuth.currentUser
                    val name = user?.displayName
                    val email = user?.email
                    val profileManager = UserProfileManager(this)

                    // 2. Check if name and email are not null
                    if (name != null && email != null) {
                        // 3. Create an instance of your UserProfileManager

                        // 4. Save the profile information
                        profileManager.saveProfile(name, email)
                        Log.d("LoginActivity", "User profile saved: Name='${name}', Email='${email}'")
                    } else {
                        profileManager.saveProfile("Unknown", "unknown")
                        Log.w("LoginActivity", "User name or email was null, profile not saved.")
                    }

                    lifecycleScope.launch {
                        val onboardingManager = OnboardingManager(this@LoginActivity)

                        if (isNewUser) {
                            Log.d("LoginActivity", "New user detected. Provisioning freemium account.")
                            val freemiumManager = FreemiumManager()
                            freemiumManager.provisionUserIfNeeded()
                        }

                        // CHECK THE LOCAL FLAG INSTEAD OF isNewUser
                        if (onboardingManager.isOnboardingCompleted()) {
                            Log.d("LoginActivity", "Onboarding already completed on this device. Launching main activity.")
                            startActivity(Intent(this@LoginActivity, MainActivity::class.java))
                        } else {
                            Log.d("LoginActivity", "Onboarding not completed. Launching permissions stepper.")
                            startActivity(Intent(this@LoginActivity, OnboardingPermissionsActivity::class.java))
                        }
                        finish()
                    }
                } else {
                    Log.w("LoginActivity", "signInWithCredential:failure", task.exception)
                    task.exception?.let { exception ->
                        FirebaseCrashlytics.getInstance().recordException(exception)
                        FirebaseCrashlytics.getInstance().log("Firebase authentication failed: ${exception.localizedMessage}")
                    }
                    Toast.makeText(this, "Authentication Failed.", Toast.LENGTH_SHORT).show()
                }
            }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/MainActivity.kt
================================================
package com.blurr.voice

import android.annotation.SuppressLint
import android.app.role.RoleManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.graphics.Color
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.view.View
import android.widget.TextView
import android.widget.Toast
import android.widget.VideoView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.android.billingclient.api.*
import com.blurr.voice.v2.AgentService
import com.blurr.voice.utilities.FreemiumManager
import com.blurr.voice.utilities.Logger
import com.blurr.voice.utilities.OnboardingManager
import com.blurr.voice.utilities.PermissionManager
import com.blurr.voice.utilities.UserIdManager
import com.blurr.voice.utilities.UserProfileManager
import com.blurr.voice.utilities.VideoAssetManager
import com.blurr.voice.utilities.WakeWordManager
import com.blurr.voice.utilities.PandaState
import com.blurr.voice.utilities.PandaStateManager
import com.blurr.voice.utilities.DeltaStateColorMapper
import com.blurr.voice.views.DeltaSymbolView
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.tasks.await
import java.io.File

class MainActivity : BaseNavigationActivity() {

    private lateinit var handler: Handler
    private lateinit var managePermissionsButton: TextView
    private lateinit var tvPermissionStatus: TextView
    private lateinit var userId: String
    private lateinit var permissionManager: PermissionManager
    private lateinit var wakeWordManager: WakeWordManager
    private lateinit var auth: FirebaseAuth
    private lateinit var tasksLeftTag: View
    private lateinit var freemiumManager: FreemiumManager
    private lateinit var wakeWordHelpLink: TextView
    private lateinit var increaseLimitsLink: TextView
    private lateinit var onboardingManager: OnboardingManager
    private lateinit var requestRoleLauncher: ActivityResultLauncher<Intent>
    private lateinit var billingStatusTextView: TextView
    private lateinit var statusTextView: TextView
    private lateinit var loadingOverlay: View
    private lateinit var pandaStateManager: PandaStateManager
    private lateinit var stateChangeListener: (PandaState) -> Unit
    private lateinit var proSubscriptionTag: View
    private lateinit var permissionsTag: View
    private lateinit var permissionsStatusTag: TextView
    private lateinit var tasksLeftText: TextView
    private lateinit var deltaSymbol: DeltaSymbolView


    private lateinit var root: View
    companion object {
        const val ACTION_WAKE_WORD_FAILED = "com.blurr.voice.WAKE_WORD_FAILED"
        const val ACTION_PURCHASE_UPDATED = "com.blurr.voice.PURCHASE_UPDATED"
    }
    
    private val wakeWordFailureReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == ACTION_WAKE_WORD_FAILED) {
                Logger.d("MainActivity", "Received wake word failure broadcast.")
                // The service stops itself, but we should refresh the UI state
                updateUI()
                showWakeWordFailureDialog()
            }
        }
    }
    
    private val purchaseUpdateReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == ACTION_PURCHASE_UPDATED) {
                Logger.d("MainActivity", "Received purchase update broadcast.")
                // Refresh billing status
                showLoading(true)
                performBillingCheck()
            }
        }
    }

    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                Toast.makeText(this, "Permission granted!", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Permission denied.", Toast.LENGTH_SHORT).show()
            }
        }




    @RequiresApi(Build.VERSION_CODES.R)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        auth = Firebase.auth
        val currentUser = auth.currentUser
        val profileManager = UserProfileManager(this)

        if (currentUser == null || !profileManager.isProfileComplete()) {
            startActivity(Intent(this, LoginActivity::class.java))
            finish()
            return
        }
        onboardingManager = OnboardingManager(this)
        if (!onboardingManager.isOnboardingCompleted()) {
            Logger.d("MainActivity", "User is logged in but onboarding not completed. Relaunching permissions stepper.")
            startActivity(Intent(this, OnboardingPermissionsActivity::class.java))
            finish()
            return
        }

        requestRoleLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == RESULT_OK) {
                Toast.makeText(this, "Set as default assistant successfully!", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Couldn’t become default assistant. Opening settings…", Toast.LENGTH_SHORT).show()
                Logger.w("MainActivity", "Role request canceled or app not eligible.\n${explainAssistantEligibility()}")
                openAssistantPickerSettings()
            }
            showAssistantStatus(true)
        }


        setContentView(R.layout.activity_main_content)
        findViewById<TextView>(R.id.btn_set_default_assistant).setOnClickListener {
            startActivity(Intent(this, RoleRequestActivity::class.java))
        }
        updateDefaultAssistantButtonVisibility()

        handleIntent(intent)
        managePermissionsButton = findViewById(R.id.btn_manage_permissions) // ADDED

        val userIdManager = UserIdManager(applicationContext)
        userId = userIdManager.getOrCreateUserId()
        increaseLimitsLink = findViewById(R.id.increase_limits_link) // ADDED

        permissionManager = PermissionManager(this)
        permissionManager.initializePermissionLauncher()

        managePermissionsButton = findViewById(R.id.btn_manage_permissions)
        tasksLeftText = findViewById(R.id.tasks_left_tag_text)
        tasksLeftTag = findViewById(R.id.tasks_left_tag)
        tvPermissionStatus = findViewById(R.id.tv_permission_status)
        wakeWordHelpLink = findViewById(R.id.wakeWordHelpLink)
        billingStatusTextView = findViewById(R.id.billing_status_textview)
        statusTextView = findViewById(R.id.status_text)
        loadingOverlay = findViewById(R.id.loading_overlay)
        proSubscriptionTag = findViewById(R.id.pro_subscription_tag)
        permissionsTag = findViewById(R.id.permissions_tag)
        permissionsStatusTag = findViewById(R.id.permissions_status_tag)
        deltaSymbol = findViewById(R.id.delta_symbol)
        freemiumManager = FreemiumManager()
        updateStatusText(PandaState.IDLE)
        setupProBanner()
        initializePandaStateManager()
        wakeWordManager = WakeWordManager(this, requestPermissionLauncher)
        handler = Handler(Looper.getMainLooper())
        setupClickListeners()
        showLoading(true)
        performBillingCheck()
        
        lifecycleScope.launch {
            val videoUrl = "https://storage.googleapis.com/blurr-app-assets/wake_word_demo.mp4"
            VideoAssetManager.getVideoFile(this@MainActivity, videoUrl)
        }

    }

    private fun openAssistantPickerSettings() {
        val specifics = listOf(
            Intent("android.settings.VOICE_INPUT_SETTINGS"),
            Intent(Settings.ACTION_VOICE_INPUT_SETTINGS),
            Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS)
        )
        for (i in specifics) {
            if (i.resolveActivity(packageManager) != null) {
                startActivity(i); return
            }
        }
        Toast.makeText(this, "Assistant settings not available on this device.", Toast.LENGTH_SHORT).show()
    }

    @RequiresApi(Build.VERSION_CODES.Q)
    fun showAssistantStatus(toast: Boolean = false) {
        val rm = getSystemService(RoleManager::class.java)
        val held = rm?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true
        val msg = if (held) "This app is the default assistant." else "This app is NOT the default assistant."
        if (toast) Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
        Logger.d("MainActivity", msg)
    }

    private fun explainAssistantEligibility(): String {
        val pm = packageManager
        val pkg = packageName

        val assistIntent = Intent(Intent.ACTION_ASSIST).setPackage(pkg)
        val assistActivities = pm.queryIntentActivities(assistIntent, 0)

        val visIntent = Intent("android.service.voice.VoiceInteractionService").setPackage(pkg)
        val visServices = pm.queryIntentServices(visIntent, 0)

        return buildString {
            append("Assistant eligibility:\n")
            append("• ACTION_ASSIST activity: ${if (assistActivities.isNotEmpty()) "FOUND" else "NOT FOUND"}\n")
            append("• VoiceInteractionService: ${if (visServices.isNotEmpty()) "FOUND" else "NOT FOUND"}\n")
            append("Note: Many OEMs only list apps with a VoiceInteractionService as selectable assistants.\n")
        }
    }

    override fun onStart() {
        super.onStart()
        if (auth.currentUser == null) {
            startActivity(Intent(this, LoginActivity::class.java))
            finish()
            return
        }
        
        showLoading(true)
        performBillingCheck()
    }

    private fun handleIntent(intent: Intent?) {
        if (intent?.action == "com.blurr.voice.WAKE_UP_PANDA") {
            Logger.d("MainActivity", "Wake up Panda shortcut activated!")
            startConversationalAgent()
        }
    }

    private fun startConversationalAgent() {
        if (!ConversationalAgentService.isRunning) {
            val serviceIntent = Intent(this, ConversationalAgentService::class.java)
            ContextCompat.startForegroundService(this, serviceIntent)
            Toast.makeText(this, "Panda is waking up...", Toast.LENGTH_SHORT).show()
        } else {
            Logger.d("MainActivity", "ConversationalAgentService is already running.")
            Toast.makeText(this, "Panda is already awake!", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        handleIntent(intent)
    }

    override fun getContentLayoutId(): Int = R.layout.activity_main_content
    
    override fun getCurrentNavItem(): BaseNavigationActivity.NavItem = BaseNavigationActivity.NavItem.HOME

    private fun setupClickListeners() {
        managePermissionsButton.setOnClickListener {
            startActivity(Intent(this, PermissionsActivity::class.java))
        }
        increaseLimitsLink.setOnClickListener {
            requestLimitIncrease()
        }

        wakeWordHelpLink.setOnClickListener {
            showWakeWordFailureDialog()
        }
        findViewById<TextView>(R.id.disclaimer_link).setOnClickListener {
            showDisclaimerDialog()
        }
        findViewById<TextView>(R.id.examples_link).setOnClickListener {
            showExamplesDialog()
        }
        
        // Add click listener to delta symbol
        deltaSymbol.setOnClickListener {
            // Only start conversational agent if in ready/idle state
            if (pandaStateManager.getCurrentState() == PandaState.IDLE || pandaStateManager.getCurrentState() == PandaState.ERROR) {
                startConversationalAgent()
            }
        }
    }

    private fun requestLimitIncrease() {
        val userEmail = auth.currentUser?.email
        if (userEmail.isNullOrEmpty()) {
            Toast.makeText(this, "Could not get your email. Please try again.", Toast.LENGTH_SHORT).show()
            return
        }

        val recipient = "ayush0000ayush@gmail.com"
        val subject = "I am facing issue in"
        val body = "Hello,\n\nI am facing issue for my account: $userEmail\n <issue-content>.... \n\nThank you."

        val intent = Intent(Intent.ACTION_SENDTO).apply {
            data = Uri.parse("mailto:") // Only email apps should handle this
            putExtra(Intent.EXTRA_EMAIL, arrayOf(recipient))
            putExtra(Intent.EXTRA_SUBJECT, subject)
            putExtra(Intent.EXTRA_TEXT, body)
        }

        // Verify that the intent will resolve to an activity
        if (intent.resolveActivity(packageManager) != null) {
            startActivity(intent)
        } else {
            Toast.makeText(this, "No email application found.", Toast.LENGTH_SHORT).show()
        }
    }


    private fun setupProBanner() {
        val proBanner = findViewById<View>(R.id.pro_upgrade_banner)
        val upgradeButton = findViewById<TextView>(R.id.upgrade_button)
        
        upgradeButton.setOnClickListener {
            // Navigate to Pro purchase screen (Requirement 2.3)
            val intent = Intent(this, ProPurchaseActivity::class.java)
            startActivity(intent)
        }
        
        // Initially hide the banner - it will be shown/hidden based on subscription status
        proBanner.visibility = View.GONE
    }

    /**
     * Initialize PandaStateManager and set up state change listeners
     */
    private fun initializePandaStateManager() {
        pandaStateManager = PandaStateManager.getInstance(this)
        stateChangeListener = { newState ->
            updateStatusText(newState)

            updateDeltaVisuals(newState)
            Logger.d("MainActivity", "Panda state changed to: ${newState.name}")
        }
        pandaStateManager.addStateChangeListener(stateChangeListener)
    }
    private fun updateDeltaVisuals(state: PandaState) {
        runOnUiThread {
            // Get the color for the current state
            val color = DeltaStateColorMapper.getColor(this, state)
            deltaSymbol.setColor(color)

            // Start or stop the glow based on whether the state is "active"
            if (DeltaStateColorMapper.isActiveState(state)) {
                deltaSymbol.startGlow()
            } else {
                deltaSymbol.stopGlow()
            }
        }
    }
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    override fun onResume() {
        super.onResume()
        showLoading(true)
        performBillingCheck()
        displayDeveloperMessage()
        updateDeltaVisuals(pandaStateManager.getCurrentState())
        updateUI()
        pandaStateManager.startMonitoring()
        val wakeWordFilter = IntentFilter(ACTION_WAKE_WORD_FAILED)
        val purchaseFilter = IntentFilter(ACTION_PURCHASE_UPDATED)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(wakeWordFailureReceiver, wakeWordFilter, RECEIVER_NOT_EXPORTED)
            registerReceiver(purchaseUpdateReceiver, purchaseFilter, RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(wakeWordFailureReceiver, wakeWordFilter)
            registerReceiver(purchaseUpdateReceiver, purchaseFilter)
        }
    }

    override fun onPause() {
        super.onPause()
        pandaStateManager.stopMonitoring()
        try {
            unregisterReceiver(wakeWordFailureReceiver)
            unregisterReceiver(purchaseUpdateReceiver)
        } catch (e: IllegalArgumentException) {
            Logger.d("MainActivity", "Receivers were not registered")
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        if (::pandaStateManager.isInitialized && ::stateChangeListener.isInitialized) {
            pandaStateManager.removeStateChangeListener(stateChangeListener)
            pandaStateManager.stopMonitoring()
        }
    }

    private fun showDisclaimerDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle("Disclaimer")
            .setMessage("Panda is an experimental AI assistant and is still in development. It may not always be accurate or perform as expected. It does small task better. Your understanding is appreciated!")
            .setPositiveButton("Okay") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(
            ContextCompat.getColor(this, R.color.white)
        )
    }

    private fun showExamplesDialog() {
        val examples = arrayOf(
            "Open YouTube and play music",
            "Send a text message",
            "Set an alarm for 30 minutes",
            "Open camera app",
            "Check weather forecast",
            "Open calculator",
            "Surprise me"
        )
        
        val dialog = AlertDialog.Builder(this)
            .setTitle("Example Commands")
            .setItems(examples) { _, which ->
                val selectedExample = examples[which]
                if (selectedExample == "Surprise me"){
                    AgentService.start(this, "play never gonna give you up on youtube")

                }
                AgentService.start(this, selectedExample)
            }
            .setNegativeButton("Cancel") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
        
        dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(
            ContextCompat.getColor(this, R.color.black)
        )
    }


    private fun showWakeWordFailureDialog() {
        val dialogView = layoutInflater.inflate(R.layout.dialog_wake_word_failure, null)
        val videoView = dialogView.findViewById<VideoView>(R.id.video_demo)
        val videoContainer = dialogView.findViewById<View>(R.id.video_container_card)
        val builder = AlertDialog.Builder(this)
            .setView(dialogView)
            .setPositiveButton("Got it") { dialog, _ ->
                dialog.dismiss()
            }
        val alertDialog = builder.create()
        lifecycleScope.launch {
            val videoUrl = "https://storage.googleapis.com/blurr-app-assets/wake_word_demo.mp4"
            val videoFile: File? = VideoAssetManager.getVideoFile(this@MainActivity, videoUrl)

            if (videoFile != null && videoFile.exists()) {
                videoContainer.visibility = View.VISIBLE
                videoView.setVideoURI(Uri.fromFile(videoFile))
                videoView.setOnPreparedListener { mp ->
                    mp.isLooping = true
                }
                alertDialog.setOnShowListener {
                    videoView.start()
                }
            } else {
                Logger.e("MainActivity", "Video file not found, hiding video container.")
                videoContainer.visibility = View.GONE
            }
        }

        alertDialog.show()
        alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(
            ContextCompat.getColor(this, R.color.white)
        )
    }
    private fun updateTaskCounter() {
        lifecycleScope.launch {
            val isUserSub = freemiumManager.isUserSubscribed()
            if(isUserSub){
                tasksLeftTag.visibility = View.GONE
            }
            val tasksLeft = freemiumManager.getTasksRemaining()
            tasksLeftText.text = "$tasksLeft tasks left"
        }
    }

    private fun updateBillingStatus() {
        lifecycleScope.launch {
            try {
                val isSubscribed = freemiumManager.isUserSubscribed()
                val billingClientReady = MyApplication.isBillingClientReady.value
                val proBanner = findViewById<View>(R.id.pro_upgrade_banner)
                if (proBanner == null) {
                    Logger.w("MainActivity", "pro_banner view not found in updateBillingStatus")
                    return@launch
                }
                when {
                    !billingClientReady -> {
                        proSubscriptionTag.visibility = View.GONE
                        proBanner.visibility = View.VISIBLE
                    }
                    isSubscribed -> {
                        proSubscriptionTag.visibility = View.VISIBLE
                        proBanner.visibility = View.GONE
                    }
                    else -> {
                        proSubscriptionTag.visibility = View.GONE
                        proBanner.visibility = View.VISIBLE
                    }
                }
            } catch (e: Exception) {
                Logger.e("MainActivity", "Error updating billing status", e)
                proSubscriptionTag.visibility = View.GONE
                val proBanner = findViewById<View>(R.id.pro_upgrade_banner)
                if (proBanner != null) {
                    proBanner.visibility = View.VISIBLE
                } else {
                    Logger.w("MainActivity", "pro_banner view not found in error handler")
                }
            }
        }
    }

    @SuppressLint("SetTextI18n")
    private fun updateUI() {
        val allPermissionsGranted = permissionManager.areAllPermissionsGranted()
        if (allPermissionsGranted) {
            tvPermissionStatus.text = "All required permissions are granted."
            tvPermissionStatus.visibility = View.GONE
            managePermissionsButton.visibility = View.GONE
            tvPermissionStatus.setTextColor(Color.parseColor("#4CAF50")) // Green
            permissionsTag.visibility = View.VISIBLE
        } else {
            tvPermissionStatus.text = "Some permissions are missing. Tap below to manage."
            tvPermissionStatus.setTextColor(Color.parseColor("#F44336")) // Red
            permissionsTag.visibility = View.GONE
        }
    }

    private fun isThisAppDefaultAssistant(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            val rm = getSystemService(RoleManager::class.java)
            rm?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true
        } else {
            val flat = Settings.Secure.getString(contentResolver, "voice_interaction_service")
            val currentPkg = flat?.substringBefore('/')
            currentPkg == packageName
        }
    }

    private fun updateDefaultAssistantButtonVisibility() {
        val btn = findViewById<TextView>(R.id.btn_set_default_assistant)
        btn.visibility = if (isThisAppDefaultAssistant()) View.GONE else View.VISIBLE
    }

    private fun showLoading(show: Boolean) {
        loadingOverlay.visibility = if (show) View.VISIBLE else View.GONE
    }

    private fun performBillingCheck() {
        lifecycleScope.launch {
            try {
                waitForBillingClientReady()
                queryAndHandlePurchases()
                updateTaskCounter()
                updateBillingStatus()
                
            } catch (e: Exception) {
                Logger.e("MainActivity", "Error during billing check", e)
                updateTaskCounter()
                updateBillingStatus()
            } finally {
                showLoading(false)
            }
        }
    }

    private suspend fun waitForBillingClientReady() {
        return withContext(Dispatchers.IO) {
            var attempts = 0
            val maxAttempts = 10
            
            while (!MyApplication.isBillingClientReady.value && attempts < maxAttempts) {
                kotlinx.coroutines.delay(500)
                attempts++
            }
            
            if (!MyApplication.isBillingClientReady.value) {
                Logger.w("MainActivity", "Billing client not ready after waiting")
            }
        }
    }

    private suspend fun queryAndHandlePurchases() {
        return withContext(Dispatchers.IO) {
            if (!MyApplication.isBillingClientReady.value) {
                Logger.e("MainActivity", "queryPurchases: BillingClient is not ready")
                return@withContext
            }

            try {
                val params = QueryPurchasesParams.newBuilder()
                    .setProductType(BillingClient.ProductType.SUBS)
                    .build()
                
                Logger.d("MainActivity", "queryPurchases: BillingClient is ready")

                val purchasesResult = MyApplication.billingClient.queryPurchasesAsync(params)
                val billingResult = purchasesResult.billingResult
                
                Logger.d("MainActivity", "queryPurchases: Got billing result: ${billingResult.responseCode}")

                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                    Logger.d("MainActivity", "queryPurchases: Found ${purchasesResult.purchasesList.size} purchases")
                    purchasesResult.purchasesList.forEach { purchase ->
                        when (purchase.purchaseState) {
                            Purchase.PurchaseState.PURCHASED -> {
                                Logger.d("MainActivity", "Found purchased item: ${purchase.products}")
                                handlePurchase(purchase)
                            }
                            Purchase.PurchaseState.PENDING -> {
                                Logger.d("MainActivity", "Purchase is pending")
                            }
                            else -> {
                                Logger.d("MainActivity", "Purchase is not in a valid state: ${purchase.purchaseState}")
                            }
                        }
                    }
                } else {
                    Logger.e("MainActivity", "Failed to query purchases: ${billingResult.debugMessage}")
                }
            } catch (e: Exception) {
                Logger.e("MainActivity", "Exception during purchase query", e)
            }
        }
    }

    private suspend fun handlePurchase(purchase: Purchase) {
        return withContext(Dispatchers.IO) {
            try {
                if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {
                    if (!purchase.isAcknowledged) {
                        val acknowledgePurchaseParams = AcknowledgePurchaseParams.newBuilder()
                            .setPurchaseToken(purchase.purchaseToken)
                            .build()
                        
                        MyApplication.billingClient.acknowledgePurchase(acknowledgePurchaseParams) { billingResult ->
                            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                                Logger.d("MainActivity", "Purchase acknowledged: ${purchase.orderId}")
                                lifecycleScope.launch {
                                    updateUserToPro()
                                }
                            } else {
                                Logger.e("MainActivity", "Failed to acknowledge purchase: ${billingResult.debugMessage}")
                            }
                        }
                    } else {
                        updateUserToPro()
                    }
                }
            } catch (e: Exception) {
                Logger.e("MainActivity", "Error handling purchase", e)
            }
        }
    }


    private suspend fun updateUserToPro() {
        val uid = Firebase.auth.currentUser?.uid
        if (uid == null) {
            Logger.e("MainActivity", "Cannot update user to pro: user is not authenticated.")
            withContext(Dispatchers.Main) {
            }
            return
        }

        withContext(Dispatchers.IO) {
            val db = Firebase.firestore
            try {
                val userDocRef = db.collection("users").document(uid)
                userDocRef.update("plan", "pro").await()
                Logger.d("MainActivity", "Successfully updated user $uid to 'pro' plan.")
                withContext(Dispatchers.Main) {
                }

            } catch (e: Exception) {
                Logger.e("MainActivity", "Error updating user to pro", e)
                withContext(Dispatchers.Main) {
                }
            }
        }
    }

    private fun displayDeveloperMessage() {
        lifecycleScope.launch {
            try {
                // Check if message has been shown more than once
                val sharedPrefs = getSharedPreferences("developer_message_prefs", Context.MODE_PRIVATE)
                val displayCount = sharedPrefs.getInt("developer_message_count", 0)
                
                if (displayCount >= 1) {
                    Logger.d("MainActivity", "Developer message already shown $displayCount times, skipping display")
                    return@launch
                }
                
                val db = Firebase.firestore
                val docRef = db.collection("settings").document("freemium")
                
                docRef.get().addOnSuccessListener { document ->
                    if (document != null && document.exists()) {
                        val message = document.getString("developerMessage")
                        if (!message.isNullOrEmpty()) {
                            val dialog = AlertDialog.Builder(this@MainActivity)
                                .setTitle("Message from Developer")
                                .setMessage(message)
                                .setPositiveButton("OK") { dialogInterface, _ ->
                                    dialogInterface.dismiss()
                                    // Increment the display count after user dismisses
                                    val editor = sharedPrefs.edit()
                                    editor.putInt("developer_message_count", displayCount + 1)
                                    editor.apply()
                                    Logger.d("MainActivity", "Developer message display count updated to ${displayCount + 1}")
                                }
                                .show()
                            dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(
                                ContextCompat.getColor(this@MainActivity, R.color.black)
                            )
                            Logger.d("MainActivity", "Developer message displayed in dialog")
                        } else {
                            Logger.d("MainActivity", "Developer message is empty")
                        }
                    } else {
                        Logger.d("MainActivity", "Developer message document does not exist")
                    }
                }.addOnFailureListener { exception ->
                    Logger.e("MainActivity", "Error fetching developer message", exception)
                }
            } catch (e: Exception) {
                Logger.e("MainActivity", "Exception in displayDeveloperMessage", e)
            }
        }
    }

    /**
     * Update the status text based on the current PandaState
     */
    fun updateStatusText(state: PandaState) {
        runOnUiThread {
            try {
                val statusText = DeltaStateColorMapper.getStatusText(state)
                statusTextView.text = statusText
                Logger.d("MainActivity", "Status text updated to: $statusText for state: ${state.name}")
            } catch (e: Exception) {
                Logger.e("MainActivity", "Error updating status text", e)
                statusTextView.text = "Ready" // Fallback to default
            }
        }
    }

    /**
     * Update the status text with custom text (overrides state-based text)
     */
    fun updateStatusText(customText: String) {
        runOnUiThread {
            try {
                statusTextView.text = customText
                Logger.d("MainActivity", "Status text updated to custom text: $customText")
            } catch (e: Exception) {
                Logger.e("MainActivity", "Error updating status text with custom text", e)
                statusTextView.text = "Ready" // Fallback to default
            }
        }
    }

}


================================================
FILE: app/src/main/java/com/blurr/voice/MemoriesActivity.kt
================================================
package com.blurr.voice

import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.data.Memory
import com.blurr.voice.data.MemoryManager
//import com.blurr.voice.v2.llm.GeminiApi
import com.blurr.voice.v2.llm.GeminiMessage
import com.blurr.voice.v2.llm.MessageRole
import com.blurr.voice.v2.llm.TextPart
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import kotlinx.coroutines.launch

class MemoriesActivity : AppCompatActivity() {
    
    // Memory feature flag - temporarily disabled
    companion object {
        const val MEMORY_ENABLED = false
    }
    
    private lateinit var memoriesRecyclerView: RecyclerView
    private lateinit var emptyStateText: TextView
    private lateinit var addMemoryFab: FloatingActionButton
    private lateinit var memoriesAdapter: MemoriesAdapter
    private lateinit var memoryManager: MemoryManager
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_memories)
        
        memoryManager = MemoryManager.getInstance(this)
        
        setupViews()
        setupRecyclerView()
        loadMemories()
    }

    private fun setupViews() {
        // Setup toolbar
        val toolbar = findViewById<Toolbar>(R.id.toolbar)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.title = "My Memories"
        
        // Setup views
        memoriesRecyclerView = findViewById(R.id.memoriesRecyclerView)
        emptyStateText = findViewById(R.id.emptyStateText)
        addMemoryFab = findViewById(R.id.addMemoryFab)
        
        // Setup privacy card click listener
        val privacyCard = findViewById<com.google.android.material.card.MaterialCardView>(R.id.privacyCard)
        privacyCard.setOnClickListener {
            val intent = Intent(this, PrivacyActivity::class.java)
            startActivity(intent)
        }
        
        // Setup FAB click listener - disable if memory is off
        addMemoryFab.setOnClickListener {
            if (MEMORY_ENABLED) {
                showAddMemoryDialog()
            } else {
                Toast.makeText(this, "Memory functionality is temporarily disabled", Toast.LENGTH_SHORT).show()
            }
        }
        
        // Disable FAB if memory is disabled
        if (!MEMORY_ENABLED) {
            addMemoryFab.alpha = 0.5f
            addMemoryFab.isEnabled = false
        }
    }
    
    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.menu_memories, menu)
        return true
    }
    
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_privacy -> {
                val intent = Intent(this, PrivacyActivity::class.java)
                startActivity(intent)
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
    
    private fun setupRecyclerView() {
        memoriesAdapter = MemoriesAdapter(emptyList()) { memory ->
            showDeleteConfirmationDialog(memory)
        }
        
        memoriesRecyclerView.apply {
            layoutManager = LinearLayoutManager(this@MemoriesActivity)
            adapter = memoriesAdapter
        }
        
        // Setup swipe to delete
        val swipeHandler = object : ItemTouchHelper.SimpleCallback(
            0, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
        ) {
            override fun onMove(
                recyclerView: RecyclerView,
                viewHolder: RecyclerView.ViewHolder,
                target: RecyclerView.ViewHolder
            ): Boolean = false
            
            override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
                val position = viewHolder.adapterPosition
                val memory = memoriesAdapter.getMemoryAt(position)
                if (memory != null) {
                    showDeleteConfirmationDialog(memory)
                }
            }
        }
        
        ItemTouchHelper(swipeHandler).attachToRecyclerView(memoriesRecyclerView)
    }
    
    private fun loadMemories() {
        if (!MEMORY_ENABLED) {
            Log.d("MemoriesActivity", "Memory disabled, showing empty state with disabled message")
            updateUI(emptyList())
            return
        }
        
        lifecycleScope.launch {
            try {
                val memories = memoryManager.getAllMemoriesList()
                updateUI(memories)
            } catch (e: Exception) {
                Toast.makeText(this@MemoriesActivity, "Error loading memories: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
    
    private fun updateUI(memories: List<Memory>) {
        if (memories.isEmpty() || !MEMORY_ENABLED) {
            memoriesRecyclerView.visibility = View.GONE
            emptyStateText.visibility = View.VISIBLE
            
            // Update empty state text based on memory status
            emptyStateText.text = if (!MEMORY_ENABLED) {
                "Memory functionality is temporarily disabled.\nPanda memory is turned off as of yet."
            } else {
                "No memories yet.\nTap the + button to add your first memory!"
            }
        } else {
            memoriesRecyclerView.visibility = View.VISIBLE
            emptyStateText.visibility = View.GONE
            memoriesAdapter.updateMemories(memories)
        }
    }
    
    private fun showAddMemoryDialog() {
        val dialogView = layoutInflater.inflate(R.layout.dialog_add_memory, null)
        val memoryEditText = dialogView.findViewById<EditText>(R.id.memoryEditText)
        val saveButton = dialogView.findViewById<com.google.android.material.button.MaterialButton>(R.id.saveButton)
        val cancelButton = dialogView.findViewById<com.google.android.material.button.MaterialButton>(R.id.cancelButton)
        
        // Enable/disable save button based on text input
        memoryEditText.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
            override fun afterTextChanged(s: Editable?) {
                saveButton.isEnabled = !s.isNullOrBlank()
            }
        })
        
        val dialog = AlertDialog.Builder(this)
            .setView(dialogView)
            .setCancelable(false)
            .create()
        
        saveButton.setOnClickListener {
            val memoryText = memoryEditText.text.toString().trim()
            if (memoryText.isNotEmpty()) {
                addMemory(memoryText)
                dialog.dismiss()
            }
        }
        
        cancelButton.setOnClickListener {
            dialog.dismiss()
        }
        
        dialog.show()
    }
    
    private fun addMemory(memoryText: String) {
        lifecycleScope.launch {
            try {
                val success = memoryManager.addMemory(memoryText)
                if (success) {
                    Toast.makeText(this@MemoriesActivity, "Memory added successfully", Toast.LENGTH_SHORT).show()
                    loadMemories() // Reload the list
                } else {
                    Toast.makeText(this@MemoriesActivity, "Failed to add memory", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Toast.makeText(this@MemoriesActivity, "Error adding memory: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
    
    private fun showDeleteConfirmationDialog(memory: Memory) {
        AlertDialog.Builder(this)
            .setTitle("Delete Memory")
            .setMessage("Are you sure you want to delete this memory?\n\n\"${memory.originalText}\"")
            .setPositiveButton("Delete") { _, _ ->
                deleteMemory(memory)
            }
            .setNegativeButton("Cancel") { _, _ ->
                // Restore the swiped item
                memoriesAdapter.notifyDataSetChanged()
            }
            .setCancelable(false)
            .show()
    }
    
    private fun deleteMemory(memory: Memory) {
        lifecycleScope.launch {
            try {
                val success = memoryManager.deleteMemoryById(memory.id)
                if (success) {
                    memoriesAdapter.removeMemory(memory)
                    showSnackbar("Memory deleted", "Undo") {
                        // Undo functionality could be added here
                    }
                    
                    // Update UI if no memories left
                    if (memoriesAdapter.itemCount == 0) {
                        updateUI(emptyList())
                    }
                } else {
                    Toast.makeText(this@MemoriesActivity, "Failed to delete memory", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Toast.makeText(this@MemoriesActivity, "Error deleting memory: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
    
    private fun showSnackbar(message: String, actionText: String, action: () -> Unit) {
        Snackbar.make(findViewById(android.R.id.content), message, Snackbar.LENGTH_LONG)
            .setAction(actionText) { action() }
            .show()
    }
    
    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/MemoriesAdapter.kt
================================================
package com.blurr.voice

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.data.Memory
import java.text.SimpleDateFormat
import java.util.*

class MemoriesAdapter(
    private var memories: List<Memory>,
    private val onDeleteClick: (Memory) -> Unit
) : RecyclerView.Adapter<MemoriesAdapter.MemoryViewHolder>() {

    class MemoryViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val memoryText: TextView = itemView.findViewById(R.id.memoryText)
        val memoryDate: TextView = itemView.findViewById(R.id.memoryDate)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MemoryViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_memory, parent, false)
        return MemoryViewHolder(view)
    }

    override fun onBindViewHolder(holder: MemoryViewHolder, position: Int) {
        val memory = memories[position]
        holder.memoryText.text = memory.originalText
        
        // Format the date
        val dateFormat = SimpleDateFormat("MMM dd, yyyy 'at' HH:mm", Locale.getDefault())
        val date = Date(memory.timestamp)
        holder.memoryDate.text = dateFormat.format(date)
    }

    override fun getItemCount(): Int = memories.size

    fun getMemoryAt(position: Int): Memory? {
        return if (position >= 0 && position < memories.size) {
            memories[position]
        } else {
            null
        }
    }

    fun updateMemories(newMemories: List<Memory>) {
        memories = newMemories
        notifyDataSetChanged()
    }

    fun removeMemory(memory: Memory) {
        val position = memories.indexOf(memory)
        if (position != -1) {
            val newList = memories.toMutableList()
            newList.removeAt(position)
            memories = newList
            notifyItemRemoved(position)
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/MomentsActivity.kt
================================================
package com.blurr.voice

import android.os.Bundle
import android.view.View
import android.widget.LinearLayout
import android.widget.TextView
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.data.TaskHistoryItem
import com.blurr.voice.utilities.Logger
import com.google.firebase.Firebase
import com.google.firebase.Timestamp
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await

class MomentsActivity : BaseNavigationActivity() {
    
    private lateinit var recyclerView: RecyclerView
    private lateinit var emptyState: LinearLayout
    private lateinit var adapter: MomentsAdapter
    private val db = Firebase.firestore
    private val auth = Firebase.auth
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_moments_content)
        
        // Setup back button
        findViewById<TextView>(R.id.back_button).setOnClickListener {
            finish()
        }
        
        // Initialize views
        recyclerView = findViewById(R.id.task_history_recycler_view)
        emptyState = findViewById(R.id.empty_state)
        
        // Setup RecyclerView
        recyclerView.layoutManager = LinearLayoutManager(this)
        adapter = MomentsAdapter(emptyList())
        recyclerView.adapter = adapter
        
        // Load task history
        loadTaskHistory()
    }
    
    private fun loadTaskHistory() {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            showEmptyState()
            return
        }
        
        CoroutineScope(Dispatchers.Main).launch {
            try {
                val document = db.collection("users").document(currentUser.uid).get().await()
                if (document.exists()) {
                    val taskHistoryData = document.get("taskHistory") as? List<Map<String, Any>>
                    if (taskHistoryData != null && taskHistoryData.isNotEmpty()) {
                        val taskHistory = taskHistoryData.mapNotNull { taskData ->
                            try {
                                TaskHistoryItem(
                                    task = taskData["task"] as? String ?: "",
                                    status = taskData["status"] as? String ?: "",
                                    startedAt = taskData["startedAt"] as? Timestamp,
                                    completedAt = taskData["completedAt"] as? Timestamp,
                                    success = taskData["success"] as? Boolean,
                                    errorMessage = taskData["errorMessage"] as? String
                                )
                            } catch (e: Exception) {
                                Logger.e("MomentsActivity", "Error parsing task history item", e)
                                null
                            }
                        }
                        
                        // Sort by startedAt in descending order (most recent first)
                        val sortedTaskHistory = taskHistory.sortedByDescending { 
                            it.startedAt?.toDate() ?: java.util.Date(0)
                        }
                        
                        if (sortedTaskHistory.isNotEmpty()) {
                            showTaskHistory(sortedTaskHistory)
                        } else {
                            showEmptyState()
                        }
                    } else {
                        showEmptyState()
                    }
                } else {
                    showEmptyState()
                }
            } catch (e: Exception) {
                Logger.e("MomentsActivity", "Error loading task history", e)
                showEmptyState()
            }
        }
    }
    
    private fun showTaskHistory(taskHistory: List<TaskHistoryItem>) {
        adapter = MomentsAdapter(taskHistory)
        recyclerView.adapter = adapter
        recyclerView.visibility = View.VISIBLE
        emptyState.visibility = View.GONE
    }
    
    private fun showEmptyState() {
        recyclerView.visibility = View.GONE
        emptyState.visibility = View.VISIBLE
    }
    
    override fun getContentLayoutId(): Int = R.layout.activity_moments_content
    
    override fun getCurrentNavItem(): BaseNavigationActivity.NavItem = BaseNavigationActivity.NavItem.MOMENTS
}


================================================
FILE: app/src/main/java/com/blurr/voice/MomentsAdapter.kt
================================================
package com.blurr.voice

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.data.TaskHistoryItem

class MomentsAdapter(private val taskHistory: List<TaskHistoryItem>) : 
    RecyclerView.Adapter<MomentsAdapter.TaskViewHolder>() {

    class TaskViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val taskText: TextView = itemView.findViewById(R.id.task_text)
        val statusText: TextView = itemView.findViewById(R.id.status_text)
        val timeText: TextView = itemView.findViewById(R.id.time_text)
        val statusEmoji: TextView = itemView.findViewById(R.id.status_emoji)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TaskViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_task_history, parent, false)
        return TaskViewHolder(view)
    }

    override fun onBindViewHolder(holder: TaskViewHolder, position: Int) {
        val task = taskHistory[position]
        
        holder.taskText.text = task.task
        holder.statusEmoji.text = task.getStatusEmoji()
        
        when (task.status.lowercase()) {
            "started" -> {
                holder.statusText.text = "Started"
                holder.timeText.text = "Started: ${task.getFormattedStartTime()}"
            }
            "completed" -> {
                holder.statusText.text = if (task.success == true) "Completed Successfully" else "Completed with Error"
                holder.timeText.text = "Completed: ${task.getFormattedCompletionTime()}"
            }
            "failed" -> {
                holder.statusText.text = "Failed"
                holder.timeText.text = "Failed: ${task.getFormattedCompletionTime()}"
            }
            else -> {
                holder.statusText.text = "Unknown Status"
                holder.timeText.text = "Started: ${task.getFormattedStartTime()}"
            }
        }
    }

    override fun getItemCount(): Int = taskHistory.size
}




================================================
FILE: app/src/main/java/com/blurr/voice/MyApplication.kt
================================================
package com.blurr.voice

import android.app.Application
import android.content.Context
import android.content.Intent
import com.blurr.voice.utilities.Logger
import com.android.billingclient.api.*
import com.blurr.voice.intents.IntentRegistry
import com.blurr.voice.intents.impl.DialIntent
import com.blurr.voice.intents.impl.EmailComposeIntent
import com.blurr.voice.intents.impl.ShareTextIntent
import com.blurr.voice.intents.impl.ViewUrlIntent
import com.blurr.voice.triggers.TriggerMonitoringService
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlin.math.pow

class MyApplication : Application(), PurchasesUpdatedListener {

    private val applicationScope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    private var reconnectAttempts = 0
    private val maxReconnectAttempts = 5
    private val initialReconnectDelayMs = 1000L

    companion object {
        lateinit var appContext: Context
            private set

        lateinit var billingClient: BillingClient
            private set

        private val _isBillingClientReady = MutableStateFlow(false)
        val isBillingClientReady: StateFlow<Boolean> = _isBillingClientReady.asStateFlow()
    }

    override fun onCreate() {
        super.onCreate()
        appContext = applicationContext

        billingClient = BillingClient.newBuilder(this)
            .setListener(this)
            .enablePendingPurchases()
            .build()

        connectToBillingService()

        IntentRegistry.register(DialIntent())
        IntentRegistry.register(ViewUrlIntent())
        IntentRegistry.register(ShareTextIntent())
        IntentRegistry.register(EmailComposeIntent())
        IntentRegistry.init(this)
    }

    private fun connectToBillingService() {
        if (billingClient.isReady) {
            Logger.d("MyApplication", "BillingClient is already connected.")
            return
        }
        billingClient.startConnection(object : BillingClientStateListener {
            override fun onBillingSetupFinished(billingResult: BillingResult) {
                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                    Logger.d("MyApplication", "BillingClient setup successfully.")
                    _isBillingClientReady.value = true
                    reconnectAttempts = 0
                } else {
                    Logger.e("MyApplication", "BillingClient setup failed: ${billingResult.debugMessage}")
                    _isBillingClientReady.value = false
                    retryConnectionWithBackoff()
                }
            }

            override fun onBillingServiceDisconnected() {
                Logger.w("MyApplication", "Billing service disconnected. Retrying...")
                _isBillingClientReady.value = false
                retryConnectionWithBackoff()
            }
        })
    }

    private fun retryConnectionWithBackoff() {
        if (reconnectAttempts < maxReconnectAttempts) {
            val delay = initialReconnectDelayMs * (2.0.pow(reconnectAttempts)).toLong()
            applicationScope.launch {
                delay(delay)
                reconnectAttempts++
                Logger.d("MyApplication", "Retrying connection, attempt #$reconnectAttempts")
                connectToBillingService()
            }
        } else {
            Logger.e("MyApplication", "Max reconnect attempts reached. Will not retry further.")
        }
    }

    override fun onPurchasesUpdated(billingResult: BillingResult, purchases: MutableList<Purchase>?) {
        Logger.d("MyApplication", "Purchase update received")
        // Send broadcast to MainActivity to handle the purchase update
        val intent = Intent("com.blurr.voice.PURCHASE_UPDATED")
        intent.putExtra("response_code", billingResult.responseCode)
        intent.putExtra("debug_message", billingResult.debugMessage)
        appContext.sendBroadcast(intent)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/OnboardingPermissionsActivity.kt
================================================
package com.blurr.voice

import android.Manifest
import android.app.Activity
import android.app.AlertDialog
import android.app.role.RoleManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Color
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.getSystemService
import com.blurr.voice.utilities.OnboardingManager

class OnboardingPermissionsActivity : AppCompatActivity() {

    private lateinit var permissionIcon: ImageView
    private lateinit var permissionTitle: TextView
    private lateinit var permissionDescription: TextView
    private lateinit var grantButton: Button
    private lateinit var nextButton: Button
    private lateinit var skipButton: Button
    private lateinit var stepperIndicator: TextView


    private var currentStep = 0
    private val permissionSteps = mutableListOf<PermissionStep>()
    private val ASSISTANT_ROLE_REQUEST_CODE = 1001

    // Activity result launchers for different permission types
    private lateinit var requestPermissionLauncher: ActivityResultLauncher<String>
    private lateinit var requestOverlayLauncher: ActivityResultLauncher<Intent>
    private lateinit var requestRoleLauncher: ActivityResultLauncher<Intent>
    private var pendingRoleRequest = false
    private var isLaunchingRole = false
    private val accessibilityServiceChecker = AccessibilityServiceChecker(this)
    private var hasScheduledAdvance = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_onboarding_stepper)

        // Initialize UI components
        permissionIcon = findViewById(R.id.permissionIcon)
        permissionTitle = findViewById(R.id.permissionTitle)
        permissionDescription = findViewById(R.id.permissionDescription)
        grantButton = findViewById(R.id.grantButton)
        nextButton = findViewById(R.id.nextButton)
        skipButton = findViewById(R.id.skipButton)
        stepperIndicator = findViewById(R.id.stepperIndicator)

        setupLaunchers()
        // Initialize permission steps
        setupPermissionSteps()
        // Set up the result launchers
        // Handle the button clicks
        setupClickListeners()
    }


    override fun onResume() {
        super.onResume()
        // Check the status of the current step when the activity resumes
        // This is important after the user returns from a settings screen

        // If we returned from a settings screen or role sheet, reflect current state in UI
        if (currentStep < permissionSteps.size) {
            val isGranted = permissionSteps[currentStep].isGranted()
            if (isGranted) {
                // Permission was granted while away, automatically move to next step after a short delay
                Toast.makeText(this, "Permission granted!", Toast.LENGTH_SHORT).show()
                scheduleAdvanceOnce()
            } else {
                updateUIForStep(currentStep)
            }
        }
    }

    private fun setupPermissionSteps() {
        // Step 1: Accessibility Service (Special Intent)
        permissionSteps.add(
            PermissionStep(
                titleRes = R.string.accessibility_permission_title,
                descRes = R.string.accessibility_permission_full_desc,
                iconRes = R.drawable.a11y_v2,
                isGranted = { accessibilityServiceChecker.isAccessibilityServiceEnabled() },
                // The action now shows the consent dialog instead of going directly to settings
                action = { showAccessibilityConsentDialog() }
            )
        )

        // Step 2: Microphone (Standard Permission)
        permissionSteps.add(
            PermissionStep(
                titleRes = R.string.microphone_permission_title,
                descRes = R.string.microphone_permission_desc,
                iconRes = R.drawable.microphone,
                isGranted = { ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED }
            ) {
                requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
            }
        )

        // Step 3: Overlay (Special Intent)
        permissionSteps.add(
            PermissionStep(
                titleRes = R.string.overlay_permission_title,
                descRes = R.string.overlay_permission_desc,
                iconRes = R.drawable.display,
                isGranted = { Build.VERSION.SDK_INT < Build.VERSION_CODES.M || Settings.canDrawOverlays(this) }
            ) {
                val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName"))
                requestOverlayLauncher.launch(intent)
            }
        )

        // Step 4: Notifications (Standard Permission - Android 13+)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permissionSteps.add(
                PermissionStep(
                    titleRes = R.string.notifications_permission_title,
                    descRes = R.string.notifications_permission_desc,
                    iconRes = R.drawable.bell,
                    isGranted = { ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED }
                ) {
                    requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                }
            )
        }


        // Step 5: Default Assistant Role (Special Intent) - Only for API 29+
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            permissionSteps.add(
                PermissionStep(
                    titleRes = R.string.default_assistant_role_title,
                    descRes = R.string.default_assistant_role_desc,
                    iconRes = R.drawable.butler,
                    isGranted = {
                        val rm = getSystemService(RoleManager::class.java)
                        rm?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true
                    },
                    action = {
                        startActivity(Intent(this, RoleRequestActivity::class.java))
                    }
                )
            )
        }

// ...
        // Start the flow with the first step
        updateUIForStep(currentStep)
    }
    private fun requestOverlay() {
        val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:$packageName"))
        startActivity(intent) // (no launcher)
    }
    private fun showAccessibilityConsentDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle(getString(R.string.accessibility_consent_title))
            .setMessage(getString(R.string.accessibility_permission_details))
            .setPositiveButton(getString(R.string.accept)) { _, _ ->
                // User clicked Accept, navigate to System Settings
                val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
                startActivity(intent)
            }
            .setNegativeButton(getString(R.string.decline)) { dialog, _ ->
                // User clicked Decline, just dismiss the dialog and do nothing
                dialog.dismiss()
            }
            .create()

        // Now, show the dialog
        dialog.show()
        dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.setTextColor(Color.GREEN)
        dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.setTextColor(Color.parseColor("#F44336"))
    }
    private fun setupLaunchers() {
        requestPermissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->
                if (isGranted) {
                    // Permission granted, automatically move to next step after a short delay
                    Toast.makeText(this, "Permission granted!", Toast.LENGTH_SHORT).show()
                    scheduleAdvanceOnce()
                } else {
                    updateUIForStep(currentStep)
                }
            }

        requestOverlayLauncher =
            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {
                val isGranted = permissionSteps[currentStep].isGranted()
                if (isGranted) {
                    // Permission granted, automatically move to next step after a short delay
                    Toast.makeText(this, "Permission granted!", Toast.LENGTH_SHORT).show()
                    scheduleAdvanceOnce()
                } else {
                    updateUIForStep(currentStep)
                }
            }

        requestRoleLauncher =
            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {
                isLaunchingRole = false           // ✅ clear here only
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    val rm = getSystemService(RoleManager::class.java)
                    val isGranted = rm?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true
                    if (isGranted) {
                        // Role granted, automatically move to next step after a short delay
                        Toast.makeText(this, "Default assistant role granted!", Toast.LENGTH_SHORT).show()
                        scheduleAdvanceOnce()
                    } else {
                        updateUIForStep(currentStep)
                    }
                } else {
                    updateUIForStep(currentStep)
                }
            }
    }
    private fun scheduleAdvanceOnce(delayMs: Long = 1000) {
        if (hasScheduledAdvance) return
        hasScheduledAdvance = true
        nextButton.postDelayed({
            moveToNextStep()
        }, delayMs)
    }
    private fun resetAssistantAskedFlag() {
        getSharedPreferences("assistant_prefs", Context.MODE_PRIVATE)
            .edit().remove("asked_for_assistant_role").apply()
    }


    @RequiresApi(Build.VERSION_CODES.Q)
    private fun openAssistantPicker() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            // Fallback for older Android versions
            openAssistantSettingsFallback()
            return
        }

        val roleManager = getSystemService(RoleManager::class.java)

        if (roleManager?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true) {
            Toast.makeText(this, "Already the default assistant", Toast.LENGTH_SHORT).show()
            return
        }

        if (isLaunchingRole) return  // ✅ prevent re-entrancy

        window.decorView.post {
            try {
                if (roleManager != null && roleManager.isRoleAvailable(RoleManager.ROLE_ASSISTANT)) {
                    isLaunchingRole = true
                    requestRoleLauncher.launch(roleManager.createRequestRoleIntent(RoleManager.ROLE_ASSISTANT))
                } else {
                    openAssistantSettingsFallback()
                }
            } catch (_: SecurityException) {
                openAssistantSettingsFallback()
            }
        }
    }

    private fun openAssistantSettingsFallback() {
        // Use startActivity for settings screens (they don’t meaningfully “return”)
        val intents = listOf(
            Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS),
            Intent(Settings.ACTION_VOICE_INPUT_SETTINGS),
            Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                .setData(Uri.fromParts("package", packageName, null))
        )
        for (i in intents) {
            if (i.resolveActivity(packageManager) != null) {
                startActivity(i)
                return
            }
        }
        Toast.makeText(this, "Could not open assistant settings on this device.", Toast.LENGTH_LONG).show()
    }
    private fun setupClickListeners() {
        grantButton.setOnClickListener {
            permissionSteps[currentStep].action.invoke()
        }

        nextButton.setOnClickListener {
            moveToNextStep()
        }

        skipButton.setOnClickListener {
            // Simply move to the next step, without granting
            moveToNextStep()
        }
    }

    private fun moveToNextStep() {
        if (currentStep < permissionSteps.size - 1) {
            hasScheduledAdvance = false
            currentStep++
            updateUIForStep(currentStep)
        } else {
            // Last step, finish onboarding
            finishOnboarding()
        }
    }

// In OnboardingPermissionsActivity.kt

    // In OnboardingPermissionsActivity.kt

    private fun updateUIForStep(stepIndex: Int) {
        if (stepIndex >= permissionSteps.size) {
            finishOnboarding()
            return
        }

        val step = permissionSteps[stepIndex]

        // Update UI elements
        permissionIcon.setImageResource(step.iconRes)
        permissionTitle.setText(step.titleRes)
        permissionDescription.setText(step.descRes)
        stepperIndicator.text = "Step ${stepIndex + 1} of ${permissionSteps.size}"

        val isGranted = step.isGranted()

        if (isGranted) {
            // Permission is already granted. Hide the grant and skip buttons.
            grantButton.visibility = View.GONE
            skipButton.visibility = View.GONE

            // Make the next button visible to proceed.
            nextButton.visibility = View.VISIBLE
            
            // Handle the final step
            if (stepIndex == permissionSteps.size - 1) {
                nextButton.text = "Finish"
            } else {
                nextButton.text = "Next"
            }

        } else {
            // Permission is not granted. Show the grant and skip buttons.
            grantButton.visibility = View.VISIBLE
            nextButton.visibility = View.GONE
            skipButton.visibility = View.VISIBLE
            
            // Set the appropriate text for the grant button based on the step
            if (stepIndex == permissionSteps.size - 1) {
                // Default Assistant Role step
                grantButton.text = "Open Assistant Settings"
            } else {
                grantButton.text = getString(R.string.grant_permission_button)
            }
        }
    }
    private fun finishOnboarding() {
        // Set the flag to indicate onboarding is completed for this device.
        val onboardingManager = OnboardingManager(this)
        onboardingManager.setOnboardingCompleted(true)

        val intent = Intent(this, MainActivity::class.java)
        startActivity(intent)
        finish() // End the onboarding flow
    }
}

// Data class to represent each step
data class PermissionStep(
    @DrawableRes val iconRes: Int,
    val titleRes: Int,
    val descRes: Int,
    val isGranted: () -> Boolean,
    val action: () -> Unit
)

// Helper class to check accessibility service status
class AccessibilityServiceChecker(private val context: Context) {
    fun isAccessibilityServiceEnabled(): Boolean {
        val accessibilityManager = ContextCompat.getSystemService(context, android.view.accessibility.AccessibilityManager::class.java)
        if (accessibilityManager == null || !accessibilityManager.isEnabled) {
            return false
        }
        val enabledServices = accessibilityManager.getEnabledAccessibilityServiceList(
            android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK)
        for (service in enabledServices) {
            val serviceInfo = service.resolveInfo.serviceInfo
            if (serviceInfo.packageName == context.packageName &&
                serviceInfo.name == ScreenInteractionService::class.java.name) {
                return true
            }
        }
        return false
    }

}


================================================
FILE: app/src/main/java/com/blurr/voice/PandaWidgetProvider.kt
================================================
package com.blurr.voice

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.os.Build
import android.widget.RemoteViews

class PandaWidgetProvider : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        // Perform this loop procedure for each widget that belongs to this provider
        for (appWidgetId in appWidgetIds) {
            // Create an Intent to launch MainActivity with our custom action.
            // THIS IS THE SAME ACTION WE USED FOR THE APP SHORTCUT!
            val intent = Intent(context, MainActivity::class.java)
            intent.action = "com.blurr.voice.WAKE_UP_PANDA"

            // Create a PendingIntent that will be triggered when the widget is clicked.
            val pendingIntent = PendingIntent.getActivity(
                context,
                0, // A request code for this pending intent
                intent,
                // Use FLAG_IMMUTABLE for security on modern Android versions
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
                } else {
                    PendingIntent.FLAG_UPDATE_CURRENT
                }
            )

            // Get the layout for the App Widget and attach an on-click listener
            val views = RemoteViews(context.packageName, R.layout.panda_widget_layout)
            views.setOnClickPendingIntent(R.id.widget_root, pendingIntent)

            // Tell the AppWidgetManager to perform an update on the current app widget
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/PermissionsActivity.kt
================================================
package com.blurr.voice

import android.Manifest
import android.app.role.RoleManager
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Color
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.text.TextUtils
import android.view.View
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat

class PermissionsActivity : AppCompatActivity() {

    // --- UI Views ---
    private lateinit var accessibilityStatus: TextView
    private lateinit var microphoneStatus: TextView
    private lateinit var overlayStatus: TextView
    private lateinit var assistantStatus: TextView

    // NEW: Add Button variables
    private lateinit var grantAccessibilityButton: TextView
    private lateinit var grantMicrophoneButton: TextView
    private lateinit var grantOverlayButton: TextView
    private lateinit var grantAssistantButton: TextView

    // NEW: Add a permission launcher for the microphone
    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                Toast.makeText(this, "Microphone permission granted!", Toast.LENGTH_SHORT).show()
                // The onResume will handle updating the UI
            } else {
                Toast.makeText(this, "Permission denied.", Toast.LENGTH_SHORT).show()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_permissions)

        // Find all status TextViews
        accessibilityStatus = findViewById(R.id.accessibilityStatus)
        microphoneStatus = findViewById(R.id.microphoneStatus)
        overlayStatus = findViewById(R.id.overlayStatus)
        assistantStatus = findViewById(R.id.assistantStatus)

        // NEW: Find all Grant Buttons
        grantAccessibilityButton = findViewById(R.id.grantAccessibilityButton)
        grantMicrophoneButton = findViewById(R.id.grantMicrophoneButton)
        grantOverlayButton = findViewById(R.id.grantOverlayButton)
        grantAssistantButton = findViewById(R.id.grantAssistantButton)

        val backButton: Button = findViewById(R.id.backButtonPermissions)
        backButton.setOnClickListener {
            finish()
        }

        // NEW: Set up click listeners for the grant buttons
        setupGrantButtonListeners()
    }

    override fun onResume() {
        super.onResume()
        // Update statuses and button visibility every time the user returns to this screen
        updatePermissionStatuses()
    }

    private fun setupGrantButtonListeners() {
        // --- CHANGED: The click listener now shows a consent dialog ---
        grantAccessibilityButton.setOnClickListener {
            showAccessibilityConsentDialog()
        }

        grantMicrophoneButton.setOnClickListener {
            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
        }

        grantOverlayButton.setOnClickListener {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val intent = Intent(
                    Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                    Uri.parse("package:$packageName")
                )
                startActivity(intent)
            }
        }

        grantAssistantButton.setOnClickListener {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                val roleManager = getSystemService(ROLE_SERVICE) as RoleManager
                val intent = roleManager.createRequestRoleIntent(RoleManager.ROLE_ASSISTANT)
                startActivityForResult(intent, 123)
            } else {
                val intent = Intent(Settings.ACTION_VOICE_INPUT_SETTINGS)
                startActivity(intent)
            }
        }
    }

    private fun showAccessibilityConsentDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle(getString(R.string.accessibility_consent_title))
            .setMessage(getString(R.string.accessibility_consent_message))
            .setPositiveButton(getString(R.string.accept)) { _, _ ->
                // User clicked Accept, navigate to System Settings
                val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
                startActivity(intent)
            }
            .setNegativeButton(getString(R.string.decline)) { dialog, _ ->
                // User clicked Decline, just dismiss the dialog and do nothing
                dialog.dismiss()
            }
            .create()

        // Now, show the dialog
        dialog.show()
        dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.setTextColor(Color.GREEN)
        dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.setTextColor(Color.parseColor("#F44336"))
    }

    private fun updatePermissionStatuses() {
        // 1. Accessibility Service Check
        if (isAccessibilityServiceEnabled()) {
            accessibilityStatus.text = "Granted"
            accessibilityStatus.setTextColor(Color.parseColor("#4CAF50")) // Green
            accessibilityStatus.setBackgroundResource(R.drawable.status_background_granted)
            grantAccessibilityButton.visibility = View.GONE // Hide button
        } else {
            accessibilityStatus.text = "Not Granted"
            accessibilityStatus.setTextColor(Color.parseColor("#F44336")) // Red
            accessibilityStatus.setBackgroundResource(R.drawable.status_background_denied)
            grantAccessibilityButton.visibility = View.VISIBLE // Show button
        }

        // 2. Microphone Permission Check
        if (isMicrophonePermissionGranted()) {
            microphoneStatus.text = "Granted"
            microphoneStatus.setTextColor(Color.parseColor("#4CAF50"))
            microphoneStatus.setBackgroundResource(R.drawable.status_background_granted)
            grantMicrophoneButton.visibility = View.GONE
        } else {
            microphoneStatus.text = "Not Granted"
            microphoneStatus.setTextColor(Color.parseColor("#F44336"))
            microphoneStatus.setBackgroundResource(R.drawable.status_background_denied)
            grantMicrophoneButton.visibility = View.VISIBLE
        }

        // 3. Display Over Other Apps Check
        if (isOverlayPermissionGranted()) {
            overlayStatus.text = "Granted"
            overlayStatus.setTextColor(Color.parseColor("#4CAF50"))
            overlayStatus.setBackgroundResource(R.drawable.status_background_granted)
            grantOverlayButton.visibility = View.GONE
        } else {
            overlayStatus.text = "Not Granted"
            overlayStatus.setTextColor(Color.parseColor("#F44336"))
            overlayStatus.setBackgroundResource(R.drawable.status_background_denied)
            grantOverlayButton.visibility = View.VISIBLE
        }

        // 4. Default Assistant Check
        if (isDefaultAssistant()) {
            assistantStatus.text = "Granted"
            assistantStatus.setTextColor(Color.parseColor("#4CAF50"))
            assistantStatus.setBackgroundResource(R.drawable.status_background_granted)
            grantAssistantButton.visibility = View.GONE
        } else {
            assistantStatus.text = "Not Granted"
            assistantStatus.setTextColor(Color.parseColor("#F44336"))
            assistantStatus.setBackgroundResource(R.drawable.status_background_denied)
            grantAssistantButton.visibility = View.VISIBLE
        }
    }

    // --- Helper functions to check each permission (no changes here) ---

    private fun isAccessibilityServiceEnabled(): Boolean {
        val service = packageName + "/" + ScreenInteractionService::class.java.canonicalName
        val accessibilityEnabled = Settings.Secure.getInt(
            applicationContext.contentResolver,
            Settings.Secure.ACCESSIBILITY_ENABLED,
            0
        )
        if (accessibilityEnabled == 1) {
            val settingValue = Settings.Secure.getString(
                applicationContext.contentResolver,
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
            )
            if (settingValue != null) {
                val splitter = TextUtils.SimpleStringSplitter(':')
                splitter.setString(settingValue)
                while (splitter.hasNext()) {
                    if (splitter.next().equals(service, ignoreCase = true)) {
                        return true
                    }
                }
            }
        }
        return false
    }

    private fun isMicrophonePermissionGranted(): Boolean {
        return ContextCompat.checkSelfPermission(
            this,
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }

    private fun isOverlayPermissionGranted(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Settings.canDrawOverlays(this)
        } else {
            true // Granted at install time on older versions
        }
    }

    private fun isDefaultAssistant(): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            val roleManager = getSystemService(ROLE_SERVICE) as RoleManager
            return roleManager.isRoleHeld(RoleManager.ROLE_ASSISTANT)
        } else {
            val assistant = Settings.Secure.getString(contentResolver, "voice_interaction_service")
            return assistant != null && assistant.contains(packageName)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/PrivacyActivity.kt
================================================
package com.blurr.voice

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar

class PrivacyActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_privacy)
        
        setupToolbar()
    }
    
    private fun setupToolbar() {
        val toolbar = findViewById<Toolbar>(R.id.toolbar)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.title = "How Panda Remembers"
    }
    
    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/ProPurchaseActivity.kt
================================================
package com.blurr.voice

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.android.billingclient.api.*
import com.blurr.voice.MyApplication
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull

class ProPurchaseActivity : BaseNavigationActivity(), PurchasesUpdatedListener {

    private lateinit var priceTextView: TextView
    private lateinit var purchaseButton: Button
    private lateinit var loadingProgressBar: ProgressBar
    private lateinit var featuresTextView: TextView
    private lateinit var backButton: View
    
    private val billingClient: BillingClient = MyApplication.billingClient
    private var productDetails: ProductDetails? = null
    
    companion object {
        private const val PRO_SKU = "panda_premium_monthly"
        private const val TAG = "ProPurchaseActivity"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_pro_purchase)
        
        initializeViews()
        setupClickListeners()
        loadProductDetails()
    }
    
    private fun initializeViews() {
        priceTextView = findViewById(R.id.price_text)
        purchaseButton = findViewById(R.id.purchase_button)
        loadingProgressBar = findViewById(R.id.loading_progress)
//        featuresTextView = findViewById(R.id.features_text)
        backButton = findViewById(R.id.back_button)
        
        // Initially hide purchase button and show loading
        purchaseButton.visibility = View.GONE
        loadingProgressBar.visibility = View.VISIBLE
    }
    
    private fun setupClickListeners() {
        backButton.setOnClickListener {
            finish()
        }
        
        purchaseButton.setOnClickListener {
            launchPurchaseFlow()
        }
    }
    
    private fun loadProductDetails() {
        lifecycleScope.launch {
            try {
                // Wait for billing client to be ready
                val isReady = withTimeoutOrNull(10000L) {
                    MyApplication.isBillingClientReady.first { it }
                }
                
                if (isReady != true) {
                    showError("Unable to connect to Play Store. Please try again later.")
                    return@launch
                }
                
                val productList = listOf(
                    QueryProductDetailsParams.Product.newBuilder()
                        .setProductId(PRO_SKU)
                        .setProductType(BillingClient.ProductType.SUBS)
                        .build()
                )
                
                val params = QueryProductDetailsParams.newBuilder()
                    .setProductList(productList)
                    .build()
                
                val productDetailsResult = billingClient.queryProductDetails(params)
                
                if (productDetailsResult.billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                    val productDetailsList = productDetailsResult.productDetailsList
                    Log.d(TAG, "Product details: $productDetailsList")
                    if (productDetailsList?.isNotEmpty() == true) {
                        productDetails = productDetailsList[0]
                        updateUIWithProductDetails()
                    } else {
                        showError("Pro subscription not available")
                    }
                } else {
                    showError("Failed to load pricing information")
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error loading product details", e)
                showError("Error loading pricing information")
            }
        }
    }
    
    private fun updateUIWithProductDetails() {
        productDetails?.let { details ->
            val subscriptionOfferDetails = details.subscriptionOfferDetails?.firstOrNull()
            val pricingPhase = subscriptionOfferDetails?.pricingPhases?.pricingPhaseList?.firstOrNull()
            
            if (pricingPhase != null) {
                val formattedPrice = pricingPhase.formattedPrice
                val billingPeriod = pricingPhase.billingPeriod
                
                // Convert billing period to readable format
                val periodText = when {
                    billingPeriod.contains("P1M") -> "month"
                    billingPeriod.contains("P1Y") -> "year"
                    billingPeriod.contains("P1W") -> "week"
                    else -> "billing period"
                }
                
                priceTextView.text = "$formattedPrice/$periodText"
                
                // Show purchase button and hide loading
                loadingProgressBar.visibility = View.GONE
                purchaseButton.visibility = View.VISIBLE
                
            } else {
                showError("Pricing information not available")
            }
        }
    }
    
    private fun launchPurchaseFlow() {
        productDetails?.let { details ->
            val subscriptionOfferDetails = details.subscriptionOfferDetails?.firstOrNull()
            if (subscriptionOfferDetails != null) {
                val productDetailsParamsList = listOf(
                    BillingFlowParams.ProductDetailsParams.newBuilder()
                        .setProductDetails(details)
                        .setOfferToken(subscriptionOfferDetails.offerToken)
                        .build()
                )
                
                val billingFlowParams = BillingFlowParams.newBuilder()
                    .setProductDetailsParamsList(productDetailsParamsList)
                    .build()
                
                val billingResult = billingClient.launchBillingFlow(this, billingFlowParams)
                
                if (billingResult.responseCode != BillingClient.BillingResponseCode.OK) {
                    Toast.makeText(this, "Failed to launch purchase flow", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    
    private fun showError(message: String) {
        loadingProgressBar.visibility = View.GONE
        priceTextView.text = "Pricing unavailable"
        purchaseButton.visibility = View.GONE
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }
    
    override fun onPurchasesUpdated(billingResult: BillingResult, purchases: MutableList<Purchase>?) {
        if (billingResult.responseCode == BillingClient.BillingResponseCode.OK && purchases != null) {
            for (purchase in purchases) {
                if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {
                    Toast.makeText(this, "Purchase successful! Welcome to Pro!", Toast.LENGTH_LONG).show()
                    finish() // Close the purchase activity
                }
            }
        } else if (billingResult.responseCode == BillingClient.BillingResponseCode.USER_CANCELED) {
            Toast.makeText(this, "Purchase cancelled", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "Purchase failed: ${billingResult.debugMessage}", Toast.LENGTH_LONG).show()
        }
    }
    override fun getContentLayoutId(): Int {
        return R.layout.activity_pro_purchase
    }

    override fun getCurrentNavItem(): NavItem {
        return BaseNavigationActivity.NavItem.UPGRADE
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/RoleRequestActivity.kt
================================================
package com.blurr.voice

import android.app.role.RoleManager
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.util.Log
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity

class RoleRequestActivity : AppCompatActivity() {

    private var launched = false
    private lateinit var roleLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        launched = savedInstanceState?.getBoolean("launched") ?: false

        // Register once
        roleLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == RESULT_OK) {
                Toast.makeText(this, "Set as default assistant successfully!", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Couldn’t become default assistant. Opening settings…", Toast.LENGTH_SHORT).show()
                Log.w("RoleRequestActivity", "Role request canceled or app not eligible.\n${explainAssistantEligibility()}")
                openAssistantSettingsFallback()
            }
            finish() // Return to caller (MainActivity should re-check status in onResume)
        }
    }

    override fun onPostResume() {
        super.onPostResume()
        if (launched) return
        launched = true

        val rm = getSystemService(RoleManager::class.java)
        Log.d("RoleRequestActivity", explainAssistantEligibility())

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q &&
            rm?.isRoleAvailable(RoleManager.ROLE_ASSISTANT) == true &&
            !rm.isRoleHeld(RoleManager.ROLE_ASSISTANT)
        ) {
            // Launch AFTER window is visible to avoid BadToken issues
            window.decorView.post {
                try {
                    roleLauncher.launch(rm.createRequestRoleIntent(RoleManager.ROLE_ASSISTANT))
                } catch (_: Exception) {
                    openAssistantSettingsFallback()
                }
            }
        } else {
            // Either role not available or already held — go to Settings (or just finish)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && rm?.isRoleHeld(RoleManager.ROLE_ASSISTANT) == true) {
                Toast.makeText(this, "Already the default assistant.", Toast.LENGTH_SHORT).show()
                finish()
            } else {
                openAssistantSettingsFallback()
                // Don’t finish here; let user navigate back from Settings to MainActivity.
                // If you prefer to auto-finish, add: finish()
            }
        }
    }

    private fun openAssistantSettingsFallback() {
        val intents = listOf(
            Intent("android.settings.VOICE_INPUT_SETTINGS"),
            Intent(Settings.ACTION_VOICE_INPUT_SETTINGS),
            Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS)
        )
        for (i in intents) {
            if (i.resolveActivity(packageManager) != null) {
                startActivity(i)
                return
            }
        }
        Toast.makeText(this, "Assistant settings unavailable on this device.", Toast.LENGTH_LONG).show()
    }

    private fun explainAssistantEligibility(): String {
        val pm = packageManager
        val pkg = packageName

        val assistIntent = Intent(Intent.ACTION_ASSIST).setPackage(pkg)
        val assistActivities = pm.queryIntentActivities(assistIntent, 0)

        val visIntent = Intent("android.service.voice.VoiceInteractionService").setPackage(pkg)
        val visServices = pm.queryIntentServices(visIntent, 0)

        return buildString {
            append("Assistant eligibility:\n")
            append("• ACTION_ASSIST activity: ${if (assistActivities.isNotEmpty()) "FOUND" else "NOT FOUND"}\n")
            append("• VoiceInteractionService: ${if (visServices.isNotEmpty()) "FOUND" else "NOT FOUND"}\n")
            append("Note: Many OEMs only list apps with a VoiceInteractionService as selectable assistants.\n")
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        outState.putBoolean("launched", launched)
        super.onSaveInstanceState(outState)
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/ScreenInteractionService.kt
================================================
package com.blurr.voice

import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.GestureDescription
import android.animation.ValueAnimator
import android.content.ComponentName
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Color
import android.graphics.Path
import android.graphics.PixelFormat
import android.graphics.Point
import android.graphics.Rect
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.util.Xml
import android.view.Display
import android.view.Gravity
import android.view.View
import android.view.WindowManager
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import android.widget.ImageView
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.core.content.ContextCompat
import com.blurr.voice.utilities.TTSManager
import com.blurr.voice.utilities.TtsVisualizer
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import org.xmlpull.v1.XmlPullParser
import org.xmlpull.v1.XmlSerializer
import java.io.File
import java.io.FileOutputStream
import java.io.OutputStream
import java.io.StringReader
import java.io.StringWriter
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

private data class SimplifiedElement(
    val description: String,
    val bounds: Rect,
    val center: Point,
    val isClickable: Boolean,
    val className: String
)

data class RawScreenData(
    val xml: String,
    val pixelsAbove: Int,
    val pixelsBelow: Int,
    val screenWidth: Int,
    val screenHeight: Int
)

class ScreenInteractionService : AccessibilityService() {

    companion object {
        var instance: ScreenInteractionService? = null

        const val DEBUG_SHOW_TAPS = false

        const val DEBUG_SHOW_BOUNDING_BOXES = false
    }

    private var windowManager: WindowManager? = null

    private var ttsVisualizer: TtsVisualizer? = null

    private var audioWaveView: AudioWaveView? = null
    private var glowingBorderView: GlowBorderView? = null

    private var statusBarHeight = -1

    private var currentActivityName: String? = null

    override fun onServiceConnected() {
        super.onServiceConnected()
        instance = this
        this.windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager
        Log.d("InteractionService", "Accessibility Service connected.")
//        setupGlowEffect()
//        setupAudioWaveEffect()
//        setupWaveBorderEffect()
    }
    /**
     * Gets the package name of the app currently in the foreground.
     * @return The package name as a String, or null if not available.
     */
    fun getForegroundAppPackageName(): String? {
        // The rootInActiveWindow property holds the node info for the current screen,
        // which includes the package name.
        return rootInActiveWindow?.packageName?.toString()
    }

    /**
     * NEW: Hides and cleans up the glowing border view.
     */
    private fun hideGlowingBorder() {
        Handler(Looper.getMainLooper()).post {
            glowingBorderView?.let { windowManager?.removeView(it) }
            glowingBorderView = null
        }
    }


    /**
     * Shows a temporary visual indicator on the screen for debugging taps.
     */
    private fun showDebugTap(tapX: Float, tapY: Float) {
        if (!Settings.canDrawOverlays(this)) {
            Log.w("InteractionService", "Cannot show debug tap: 'Draw over other apps' permission not granted.")
            return
        }

        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager
        val overlayView = ImageView(this)

        val tapIndicator = GradientDrawable().apply {
            shape = GradientDrawable.OVAL
            setColor(0x80FF0000.toInt()) // Semi-transparent red
            setSize(100, 100)
            setStroke(4, 0xFFFF0000.toInt()) // Solid red border
        }
        overlayView.setImageDrawable(tapIndicator)

        val params = WindowManager.LayoutParams(
            100, 100,
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
            PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.TOP or Gravity.START
            x = tapX.toInt() - 50
            y = tapY.toInt() - 50
        }

        Handler(Looper.getMainLooper()).post {
            try {
                windowManager.addView(overlayView, params)
                Handler(Looper.getMainLooper()).postDelayed({
                    if (overlayView.isAttachedToWindow) windowManager.removeView(overlayView)
                }, 500L)
            } catch (e: Exception) {
                Log.e("InteractionService", "Failed to add debug tap view", e)
            }
        }
    }

    /**
     * Draws labeled bounding boxes for each simplified element on the screen.
     */
    private fun drawDebugBoundingBoxes(elements: List<SimplifiedElement>) {
        if (!Settings.canDrawOverlays(this)) {
            Log.w("InteractionService", "Cannot draw bounding boxes: 'Draw over other apps' permission not granted.")
            return
        }

        // Calculate status bar height once
        if (statusBarHeight < 0) {
            val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
            statusBarHeight = if (resourceId > 0) resources.getDimensionPixelSize(resourceId) else 0
        }

        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager
        val viewsToRemove = mutableListOf<View>()
        val mainHandler = Handler(Looper.getMainLooper())

        mainHandler.post {
            elements.forEach { element ->
                try {
                    // Create the border view
                    val boxView = View(this).apply {
                        background = GradientDrawable().apply {
                            shape = GradientDrawable.RECTANGLE
                            val color = if (element.isClickable) 0xFF00FF00.toInt() else 0xFFFFFF00.toInt()
                            setStroke(4, color)
                        }
                    }
                    val boxParams = WindowManager.LayoutParams(
                        element.bounds.width(), element.bounds.height(),
                        WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                        WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                        PixelFormat.TRANSLUCENT
                    ).apply {
                        gravity = Gravity.TOP or Gravity.START
                        x = element.bounds.left
                        // CORRECTED: Subtract status bar height for accurate positioning
                        y = element.bounds.top - statusBarHeight
                    }
                    windowManager.addView(boxView, boxParams)
                    viewsToRemove.add(boxView)

                    // Create the label view
                    val labelView = TextView(this).apply {
                        text = element.description
                        setBackgroundColor(0xAA000000.toInt())
                        setTextColor(0xFFFFFFFF.toInt())
                        textSize = 10f
                        setPadding(4, 2, 4, 2)
                    }
                    val labelParams = WindowManager.LayoutParams(
                        WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT,
                        WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                        WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                        PixelFormat.TRANSLUCENT
                    ).apply {
                        gravity = Gravity.TOP or Gravity.START
                        x = element.bounds.left
                        // CORRECTED: Subtract status bar height and offset from the top
                        y = (element.bounds.top - 35).coerceAtLeast(0) - statusBarHeight
                    }
                    windowManager.addView(labelView, labelParams)
                    viewsToRemove.add(labelView)

                } catch (e: Exception) {
                    Log.e("InteractionService", "Failed to add debug bounding box view for element: ${element.description}", e)
                }
            }

            mainHandler.postDelayed({
                viewsToRemove.forEach { view ->
                    if (view.isAttachedToWindow) windowManager.removeView(view)
                }
            }, 10000L)
        }
    }


    /**
     * UPDATED: Parses the raw XML into a de-duplicated, structured list of simplified elements.
     */
    private fun parseXmlToSimplifiedElements(xmlString: String): List<SimplifiedElement> {
        val allElements = mutableListOf<SimplifiedElement>()
        try {
            val parser: XmlPullParser = Xml.newPullParser()
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false)
            parser.setInput(StringReader(xmlString))

            var eventType = parser.eventType
            while (eventType != XmlPullParser.END_DOCUMENT) {
                if (eventType == XmlPullParser.START_TAG && parser.name == "node") {
                    val boundsString = parser.getAttributeValue(null, "bounds")
                    val bounds = try {
                        val numbers = boundsString?.replace(Regex("[\\[\\]]"), ",")?.split(",")?.filter { it.isNotEmpty() }
                        if (numbers?.size == 4) Rect(numbers[0].toInt(), numbers[1].toInt(), numbers[2].toInt(), numbers[3].toInt()) else Rect()
                    } catch (e: Exception) { Rect() }

                    if (bounds.width() <= 0 || bounds.height() <= 0) {
                        eventType = parser.next()
                        continue
                    }

                    val isClickable = parser.getAttributeValue(null, "clickable") == "true"
                    val text = parser.getAttributeValue(null, "text")
                    val contentDesc = parser.getAttributeValue(null, "content-desc")
                    val resourceId = parser.getAttributeValue(null, "resource-id")
                    val className = parser.getAttributeValue(null, "class") ?: "Element"

                    if (isClickable || !text.isNullOrEmpty() || (contentDesc != null && contentDesc != "null" && contentDesc.isNotEmpty())) {
                        val description = when {
                            !contentDesc.isNullOrEmpty() && contentDesc != "null" -> contentDesc
                            !text.isNullOrEmpty() -> text
                            !resourceId.isNullOrEmpty() -> resourceId.substringAfterLast('/')
                            else -> ""
                        }
                        if (description.isNotEmpty()) {
                            val center = Point(bounds.centerX(), bounds.centerY())
                            allElements.add(SimplifiedElement(description, bounds, center, isClickable, className))
                        }
                    }
                }
                eventType = parser.next()
            }
        } catch (e: Exception) {
            Log.e("InteractionService", "Error parsing XML for simplified elements", e)
        }

//        // --- De-duplication Logic ---
//        val filteredElements = mutableListOf<SimplifiedElement>()
//        val claimedAreas = mutableListOf<Rect>()
//
//        // Process larger elements first to claim their space
//        allElements.sortedByDescending { it.bounds.width() * it.bounds.height() }.forEach { element ->
//            // Check if the element's center is already within a claimed area
//            val isContained = claimedAreas.any { claimedRect ->
//                claimedRect.contains(element.center.x, element.center.y)
//            }
//
//            if (!isContained) {
//                filteredElements.add(element)
//                // Only clickable containers should claim space to prevent them from hiding their children
//                if (element.isClickable) {
//                    claimedAreas.add(element.bounds)
//                }
//            }
//        }

        // Return the filtered list, sorted by top-to-bottom, left-to-right position
//        return filteredElements.sortedWith(compareBy({ it.bounds.top }, { it.bounds.left }))
        return allElements
    }

    /**
     * Formats the structured list of elements into a single string for the LLM.
     */
    private fun formatElementsForLlm(elements: List<SimplifiedElement>): String {
        if (elements.isEmpty()) {
            return "No interactable or textual elements found on the screen."
        }
        val elementStrings = elements.map {
            val action = if (it.isClickable) "Action: Clickable" else "Action: Not-Clickable (Text only)"
            val elementType = it.className.substringAfterLast('.')
            // Use the center point in the output string
            "- $elementType: \"${it.description}\" | $action | Center: (${it.center.x}, ${it.center.y})"
        }
        return "Interactable Screen Elements:\n" + elementStrings.joinToString("\n")
    }
    /**
     * Shows a thin, white border around the entire screen for 300ms.
     * This serves as a non-intrusive visual feedback mechanism.
     */
    private fun showScreenFlash() {
        // All UI operations must be on the main thread
        val mainHandler = Handler(Looper.getMainLooper())
        mainHandler.post {
            // Although AccessibilityServices can often draw overlays without this,
            // it's good practice to check, especially for broader compatibility.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(this)) {
                Log.w("InteractionService", "Cannot show screen flash: 'Draw over other apps' permission not granted.")
                return@post
            }

            // 1. Create the View that will be our border
            val borderView = View(this)

            // 2. Create a drawable for the border (transparent inside, white stroke)
            val borderDrawable = GradientDrawable().apply {
                shape = GradientDrawable.RECTANGLE
                setColor(Color.TRANSPARENT) // The middle of the shape is transparent
                // Set the stroke (the border). 8px is a good thickness.
                setStroke(8, Color.WHITE)
            }
            borderView.background = borderDrawable

            // 3. Define the layout parameters for the overlay
            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT, // Full width
                WindowManager.LayoutParams.MATCH_PARENT, // Full height
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, // Draw on top of everything
                // These flags make the view non-interactive (can't be touched or focused)
                // and allow it to draw over the status bar.
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or
                        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
                PixelFormat.TRANSLUCENT // Required for transparency
            )

            try {
                // 4. Add the view to the window manager
                windowManager?.addView(borderView, params)

                // 5. Schedule the removal of the view after 300ms
                mainHandler.postDelayed({
                    // Ensure the view is still attached to the window before removing
                    if (borderView.isAttachedToWindow) {
                        windowManager?.removeView(borderView)
                    }
                }, 500L) // The flash duration

            } catch (e: Exception) {
                Log.e("InteractionService", "Failed to add screen flash view", e)
            }
        }
    }

    suspend fun dumpWindowHierarchy(pureXML: Boolean = false): String {
        return withContext(Dispatchers.Default) {
            val rootNode = rootInActiveWindow ?: run {
                Log.e("InteractionService", "Root node is null, cannot dump hierarchy.")
                return@withContext "Error: UI hierarchy is not available."
            }

            val stringWriter = StringWriter()
            try {
                val serializer: XmlSerializer = Xml.newSerializer()
                serializer.setOutput(stringWriter)
                serializer.startDocument("UTF-8", true)
                serializer.startTag(null, "hierarchy")
                dumpNode(rootNode, serializer, 0)
                serializer.endTag(null, "hierarchy")
                serializer.endDocument()

                val rawXml = stringWriter.toString()
//                logLongString("rawXml", rawXml)

                // Get screen dimensions
                val screenWidth: Int
                val screenHeight: Int
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    val windowMetrics = windowManager?.currentWindowMetrics
                    val insets = windowMetrics?.windowInsets?.getInsetsIgnoringVisibility(android.view.WindowInsets.Type.systemBars())
                    screenWidth = windowMetrics?.bounds?.width() ?: 0
                    screenHeight = windowMetrics?.bounds?.height() ?: 0
                } else {
                    val display = windowManager?.defaultDisplay
                    val size = Point()
                    display?.getSize(size)
                    screenWidth = size.x
                    screenHeight = size.y
                }


//                 val semanticParser = SemanticParser()
//                 val simplifiedJson = semanticParser.toHierarchicalString(rawXml)
//                // 1. Parse the raw XML into a structured list.
                val simplifiedElements = parseXmlToSimplifiedElements(rawXml)
                println("SIZEEEE : " + simplifiedElements.size)
                // 2. If debug mode is on, draw the bounding boxes.
                if (DEBUG_SHOW_BOUNDING_BOXES) {
                    drawDebugBoundingBoxes(simplifiedElements)
                }

                try {
                    showScreenFlash()
                } catch (e: Exception) {
                    Log.e("InteractionService", "Failed to trigger screen flash", e)
                }

                if (pureXML) {
                    return@withContext rawXml
                }
                // 3. Format the structured list into the final string for the LLM.
                return@withContext formatElementsForLlm(simplifiedElements)

            } catch (e: Exception) {
                Log.e("InteractionService", "Error dumping or transforming UI hierarchy", e)
                return@withContext "Error processing UI."
            }
        }
    }

    private fun dumpNode(node: android.view.accessibility.AccessibilityNodeInfo?, serializer: XmlSerializer, index: Int) {
        if (node == null) return

        serializer.startTag(null, "node")

        // Add common attributes to the XML node
        serializer.attribute(null, "index", index.toString())
        serializer.attribute(null, "text", node.text?.toString() ?: "")
        serializer.attribute(null, "resource-id", node.viewIdResourceName ?: "")
        serializer.attribute(null, "class", node.className?.toString() ?: "")
        serializer.attribute(null, "package", node.packageName?.toString() ?: "")
        serializer.attribute(null, "content-desc", node.contentDescription?.toString() ?: "")
        serializer.attribute(null, "checkable", node.isCheckable.toString())
        serializer.attribute(null, "checked", node.isChecked.toString())
        serializer.attribute(null, "clickable", node.isClickable.toString())
        serializer.attribute(null, "enabled", node.isEnabled.toString())
        serializer.attribute(null, "focusable", node.isFocusable.toString())
        serializer.attribute(null, "focused", node.isFocused.toString())
        serializer.attribute(null, "scrollable", node.isScrollable.toString())
        serializer.attribute(null, "long-clickable", node.isLongClickable.toString())
        serializer.attribute(null, "password", node.isPassword.toString())
        serializer.attribute(null, "selected", node.isSelected.toString())

        val bounds = android.graphics.Rect()
        node.getBoundsInScreen(bounds)
        serializer.attribute(null, "bounds", bounds.toShortString())

        // Recursively dump children
        for (i in 0 until node.childCount) {
            dumpNode(node.getChild(i), serializer, i)
        }

        serializer.endTag(null, "node")
    }


    fun logLongString(tag: String, message: String) {
        val maxLogSize = 2000 // Split into chunks of 2000 characters
        for (i in 0..message.length / maxLogSize) {
            val start = i * maxLogSize
            var end = (i + 1) * maxLogSize
            end = if (end > message.length) message.length else end
            Log.d(tag, message.substring(start, end))
        }
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent) {
        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {
            val packageName = event.packageName?.toString()
            val className = event.className?.toString()

            if (!packageName.isNullOrBlank() && !className.isNullOrBlank()) {
                this.currentActivityName = ComponentName(packageName, className).flattenToString()
                Log.d("AccessibilityService", "Current Activity Updated: $currentActivityName")
            }
        }
    }

    fun getCurrentActivityName(): String {
        return this.currentActivityName ?: "Unknown"
    }


    override fun onInterrupt() {
        Log.e("InteractionService", "Accessibility Service interrupted.")
    }

    override fun onDestroy() {
        super.onDestroy()
        instance = null
        hideGlowingBorder()
        Log.d("InteractionService", "Accessibility Service destroyed.")
    }

    /**
     * NEW: Programmatically checks if there is a focused and editable input field
     * ready to receive text. This is the most reliable way to know if typing is possible.
     * @return True if typing is possible, false otherwise.
     */
    fun isTypingAvailable(): Boolean {
        val focusedNode = rootInActiveWindow?.findFocus(AccessibilityNodeInfo.FOCUS_INPUT)
        return focusedNode != null && focusedNode.isEditable && focusedNode.isEnabled
    }

    fun clickOnPoint(x: Float, y: Float) {
        // Show visual feedback for the tap if the debug flag is enabled
        if (DEBUG_SHOW_TAPS) {
            showDebugTap(x, y)
        }

        val path = Path().apply {
            moveTo(x, y)
        }
        val gesture = GestureDescription.Builder()
            .addStroke(GestureDescription.StrokeDescription(path, 0, 10))
            .build()

        dispatchGesture(gesture, null, null)
    }

    /**
     * Performs a swipe gesture on the screen.
     * @param duration The time in milliseconds the swipe should take.
     */
    fun swipe(x1: Float, y1: Float, x2: Float, y2: Float, duration: Long) {
        val path = Path()
        path.moveTo(x1, y1)
        path.lineTo(x2, y2)
        val gesture = GestureDescription.Builder()
            .addStroke(GestureDescription.StrokeDescription(path, 0, duration))
            .build()

        dispatchGesture(gesture, null, null)
    }
    /**
     * Performs a long press gesture at a specific point on the screen.
     * @param x The x-coordinate of the long press.
     * @param y The y-coordinate of the long press.
     */
    fun longClickOnPoint(x: Float, y: Float) {
        // Show visual feedback for the tap if the debug flag is enabled
        if (DEBUG_SHOW_TAPS) {
            showDebugTap(x, y)
        }

        val path = Path().apply {
            moveTo(x, y)
        }
        // A long press is essentially a tap that is held down.
        // 600ms is a common duration for a long press.
        val longPressStroke = GestureDescription.StrokeDescription(path, 0, 2000L)

        val gesture = GestureDescription.Builder()
            .addStroke(longPressStroke)
            .build()

        dispatchGesture(gesture, null, null)
    }

    /**
     * Scrolls the screen down by a given number of pixels with more precision.
     * This performs a swipe from bottom to top with a calculated duration
     * to maintain a slow, constant velocity and minimize the "fling" effect.
     *
     * @param pixels The number of pixels to scroll.
     * @param pixelsPerSecond The desired velocity of the swipe. Lower is more precise.
     */
    fun scrollDownPrecisely(pixels: Int, pixelsPerSecond: Int = 1000) {
        val displayMetrics = resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels
        val screenHeight = displayMetrics.heightPixels

        // Define swipe path in the middle of the screen
        val x = screenWidth / 2
        // Start swipe from 80% down the screen to avoid navigation bars
        val y1 = (screenHeight * 0.8).toInt()
        // Calculate end point, ensuring it doesn't go below 0
        val y2 = (y1 - pixels).coerceAtLeast(0)

        // Calculate duration based on distance to maintain a constant, slow velocity
        // duration (ms) = (distance (px) / velocity (px/s)) * 1000 (ms/s)
        val distance = y1 - y2
        if (distance <= 0) {
            Log.w("Scroll", "Scroll distance is zero or negative. Aborting.")
            return
        }

        val duration = (distance.toFloat() / pixelsPerSecond * 1000).toInt()

        Log.d("Scroll", "Scrolling down by $pixels pixels: swipe from ($x, $y1) to ($x, $y2) over $duration ms")
        swipe(x.toFloat(), y1.toFloat(), x.toFloat(), y2.toFloat(), duration.toLong())
    }

    /**
     * Types the given text into the currently focused editable field.
     */
    fun typeTextInFocusedField(textToType: String) {
        // Find the node that currently has input focus
        val focusedNode = rootInActiveWindow?.findFocus(AccessibilityNodeInfo.FOCUS_INPUT)

        if (focusedNode != null && focusedNode.isEditable) {
            val arguments = Bundle()
            // To append text rather than replacing it, we get existing text first
            val existingText =  ""
            val newText = existingText.toString() + textToType

            arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, newText)
            focusedNode.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, arguments)
        } else {
            Log.e("InteractionService", "Could not find a focused editable field to type in.")
        }
    }

    /**
     * Triggers the 'Back' button action.
     */
    fun performBack() {
        performGlobalAction(GLOBAL_ACTION_BACK)
    }

    /**
     * Triggers the 'Home' button action.
     */
    fun performHome() {
        performGlobalAction(GLOBAL_ACTION_HOME)
    }

    /**
     * Triggers the 'App Switch' (Recents) action.
     */
    fun performRecents() {
        performGlobalAction(GLOBAL_ACTION_RECENTS)
    }

    @RequiresApi(Build.VERSION_CODES.R)
    fun performEnter() {
        val rootNode: AccessibilityNodeInfo? = rootInActiveWindow
        if (rootNode == null) {
            Log.e("InteractionService", "Cannot perform Enter: rootInActiveWindow is null.")
            return
        }

        val focusedNode = rootNode.findFocus(AccessibilityNodeInfo.FOCUS_INPUT)
        if (focusedNode == null) {
            Log.w("InteractionService", "Could not find a focused input node to perform 'Enter' on.")
            return
        }

        try {
            val supportedActions = focusedNode.actionList

            // --- Step 1: Attempt the primary, correct method ---
            val imeAction = AccessibilityNodeInfo.AccessibilityAction.ACTION_IME_ENTER
            if (supportedActions.contains(imeAction)) {
                Log.d("InteractionService", "Attempting primary action: ACTION_IME_ENTER")
                val success = focusedNode.performAction(imeAction.id)
                if (success) {
                    Log.d("InteractionService", "Successfully performed ACTION_IME_ENTER.")
                    return // Action succeeded, we are done.
                }
                // If it failed, we'll proceed to the fallback.
                Log.w("InteractionService", "ACTION_IME_ENTER was supported but failed to execute. Proceeding to fallback.")
            }

            // --- Step 2: Attempt the fallback method ---
            Log.w("InteractionService", "ACTION_IME_ENTER not available or failed. Trying ACTION_CLICK as a fallback.")
            val clickAction = AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK
            if (supportedActions.contains(clickAction)) {
                val success = focusedNode.performAction(clickAction.id)
                if (success) {
                    Log.d("InteractionService", "Fallback ACTION_CLICK succeeded.")
                } else {
                    Log.e("InteractionService", "Fallback ACTION_CLICK also failed.")
                }
            } else {
                Log.e("InteractionService", "No supported 'Enter' or 'Click' action was found on the focused node.")
            }

        } catch (e: Exception) {
            Log.e("InteractionService", "Exception while trying to perform Enter action", e)
        } finally {
            // IMPORTANT: Always recycle the node you found to prevent memory leaks.
            focusedNode.recycle()
        }
    }

    /**
     * Traverses the node tree to find the primary scrollable container.
     * A simple heuristic is to find the largest scrollable node on screen.
     */
    private fun findScrollableNodeAndGetInfo(rootNode: AccessibilityNodeInfo?): Pair<Int, Int> {
        if (rootNode == null) return Pair(0, 0)

        val queue: ArrayDeque<AccessibilityNodeInfo> = ArrayDeque()
        queue.addLast(rootNode)

        var bestNode: AccessibilityNodeInfo? = null
        var maxNodeSize = -1

        while (queue.isNotEmpty()) {
            val node = queue.removeFirst()

            if (node.isScrollable) {
                val rect = android.graphics.Rect()
                node.getBoundsInScreen(rect)
                val size = rect.width() * rect.height()
                if (size > maxNodeSize) {
                    maxNodeSize = size
                    bestNode = node
                }
            }

            for (i in 0 until node.childCount) {
                node.getChild(i)?.let { queue.addLast(it) }
            }
        }

        var pixelsAbove = 0
        var pixelsBelow = 0

        bestNode?.let {
            val rangeInfo = it.rangeInfo
            if (rangeInfo != null) {
                // Use RangeInfo if available (common in RecyclerViews)
                pixelsAbove = (rangeInfo.current - rangeInfo.min).toInt()
                pixelsBelow = (rangeInfo.max - rangeInfo.current).toInt()
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                // Fallback for Android R+ (common in ScrollViews)
                // Note: getMaxScrollY() might not always be available.
                pixelsAbove = 10
                pixelsBelow = (5).coerceAtLeast(0)
            }
            // Recycle the node we found to be safe
            it.recycle()
        }

        return Pair(pixelsAbove, pixelsBelow)
    }

    private fun getScreenDimensions(): Pair<Int, Int> {
        val windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            // Use modern API for Android 11+ (API 30+)
            val metrics = windowManager.currentWindowMetrics
            val width = metrics.bounds.width()
            val height = metrics.bounds.height()
            Pair(width, height)
        } else {
            // Use legacy API for older Android versions (API 24-29)
            val display = windowManager.defaultDisplay
            val displayMetrics = android.util.DisplayMetrics()
            display.getRealMetrics(displayMetrics)
            val width = displayMetrics.widthPixels
            val height = displayMetrics.heightPixels
            Pair(width, height)
        }
    }

    suspend fun getScreenAnalysisData(): RawScreenData {
        val (screenWidth, screenHeight) = getScreenDimensions()
        val maxRetries = 5
        val retryDelay = 800L // 200 milliseconds

        for (attempt in 1..maxRetries) {
            // Attempt to get the root node in each iteration.
            val rootNode = rootInActiveWindow

            if (rootNode != null) {
                // --- SUCCESS PATH ---
                // If the root node is available, proceed with the analysis and return.
                Log.d("InteractionService", "Got rootInActiveWindow on attempt $attempt.")

                // 1. Get scroll info by traversing the live nodes
                val (pixelsAbove, pixelsBelow) = findScrollableNodeAndGetInfo(rootNode)

                // 2. Get the XML dump
                val xmlString = dumpWindowHierarchy(true)
                // Return the complete data, exiting the function successfully.
                return RawScreenData(xmlString, pixelsAbove, pixelsBelow, screenWidth, screenHeight)
            }

            // --- RETRY PATH ---
            // If the root node is null and this isn't the last attempt, wait and retry.
            if (attempt < maxRetries) {
                Log.d("InteractionService", "rootInActiveWindow is null on attempt $attempt. Retrying in ${retryDelay}ms...")
                delay(retryDelay)
            }
        }

        // --- FAILURE PATH ---
        // If the loop completes, all retries have failed.
        Log.e("InteractionService", "Failed to get rootInActiveWindow after $maxRetries attempts.")
        // Return the placeholder to indicate failure.
        return RawScreenData("<hierarchy/>", 0, 0, screenWidth, screenHeight)
    }

    /**
     * Asynchronously captures a screenshot from an AccessibilityService in a safe and reliable way.
     * This function follows the "Strict Librarian" rule: it always closes the screenshot resource
     * after use to prevent leaks and allow subsequent screenshots to succeed.
     *
     * @return A nullable Bitmap. Returns the screenshot Bitmap on success, or null if any part of the process fails.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun captureScreenshot(): Bitmap? {
        // A top-level try-catch block ensures that no matter what fails inside the coroutine,
        // the app will not crash. It will log the error and return null.
        return try {
            // suspendCancellableCoroutine is the standard way to wrap a modern callback-based
            // Android API into a clean, suspendable coroutine.
            suspendCancellableCoroutine { continuation ->
                // The executor ensures the result callbacks happen on the main UI thread,
                // which is a requirement for many UI-related APIs.
                val executor = ContextCompat.getMainExecutor(this)

                // STEP 1: Ask the "Librarian" (Android OS) to check out the "book" (Screenshot).
                takeScreenshot(
                    Display.DEFAULT_DISPLAY,
                    executor,
                    object : TakeScreenshotCallback {

                        // This block is called if the system successfully grants us the screenshot buffer.
                        override fun onSuccess(screenshotResult: ScreenshotResult) {
                            // The HardwareBuffer is the actual low-level resource. It's the "special book".
                            val hardwareBuffer = screenshotResult.hardwareBuffer

                            if (hardwareBuffer == null) {
                                // If, for some reason, the buffer is null even on success, fail gracefully.
                                continuation.resumeWithException(Exception("Screenshot hardware buffer was null."))
                                return
                            }

                            // STEP 2: "Photocopy the book" by wrapping the HardwareBuffer into a standard Bitmap.
                            // We make a mutable copy so we can work with it after closing the original buffer.
                            val bitmap = Bitmap.wrapHardwareBuffer(hardwareBuffer, screenshotResult.colorSpace)
                                ?.copy(Bitmap.Config.ARGB_8888, false)

                            // STEP 3: THIS IS THE MOST IMPORTANT STEP.
                            // "Return the book to the librarian." We immediately close the original HardwareBuffer
                            // to release the system resource. This allows the *next* screenshot call to succeed.
                            hardwareBuffer.close()

                            // STEP 4: Give the "photocopy" (the Bitmap) back to our agent.
                            if (bitmap != null) {
                                // If the bitmap was created successfully, resume the coroutine with the result.
                                continuation.resume(bitmap)
                            } else {
                                // If bitmap creation failed, resume with an error.
                                continuation.resumeWithException(Exception("Failed to wrap hardware buffer into a Bitmap."))
                            }
                        }

                        // This block is called if the "Librarian" denies our request for any reason.
                        override fun onFailure(errorCode: Int) {
                            // We don't crash the app. We just tell the coroutine that it failed,
                            // which will be caught by our top-level try-catch block.
                            continuation.resumeWithException(Exception("Screenshot failed with error code: $errorCode"))
                        }
                    }
                )
            }
        } catch (e: Exception) {
            // Any exception from resumeWithException will be caught here.
            // We log the full error with its stack trace for easy debugging.
            Log.e("ScreenshotUtil", "Screenshot capture failed", e)
            // We return null to the caller, signaling that the operation did not succeed.
            null
        }
    }

    private fun saveBitmapToFile(bitmap: Bitmap, file: File) {
        try {
            file.parentFile?.mkdirs()

            val fos: OutputStream = FileOutputStream(file)
            fos.use {
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, it)
                Log.d("InteractionService", "Screenshot saved to ${file.absolutePath}")
            }
        } catch (e: Exception) {
            Log.e("InteractionService", "Failed to save bitmap to file.", e)
        }
    }

    /**
     * A private recursive helper to find and collect interactable nodes.
     */
    private fun findInteractableNodesRecursive(
        node: AccessibilityNodeInfo?,
        list: MutableList<InteractableElement>
    ) {
        if (node == null) return
//
        // =================================================================
        // THIS IS THE CORE LOGIC: Check if the node is interactable
        // =================================================================
//      val isInteractable = (node.isClickable || node.isLongClickable || node.isScrollable || node.isFocusable || node.isLongClickable || node.is) && node.isEnabled

        val bounds = android.graphics.Rect()
        node.getBoundsInScreen(bounds)

        // We only care about elements that are actually visible on screen
        if (!bounds.isEmpty) {
            list.add(
                InteractableElement(
                    text = node.text?.toString(),
                    contentDescription = node.contentDescription?.toString(),
                    resourceId = node.viewIdResourceName,
                    className = node.className?.toString(),
                    bounds = bounds,
                    node = node // Keep the original node reference to perform actions
                )
            )
        }

        // Continue searching through the children
        for (i in 0 until node.childCount) {
            findInteractableNodesRecursive(node.getChild(i), list)
        }
    }

    /**
     * NEW: Creates and displays the AudioWaveView at the bottom of the screen.
     */
    private fun showAudioWave() {
        if (audioWaveView != null) return // Already showing

        audioWaveView = AudioWaveView(this)

        // Convert 150dp to pixels for the view's height
        val heightInDp = 150
        val heightInPixels = (heightInDp * resources.displayMetrics.density).toInt()

        val params = WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT, // Full width
            heightInPixels, // Fixed height
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or
                    WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
            PixelFormat.TRANSLUCENT
        ).apply {
            // --- 3. Anchor the view to the bottom ---
            gravity = Gravity.BOTTOM
//            y = 200 // Moves the view 200 pixels up from the bottom

        }

        Handler(Looper.getMainLooper()).post {
            windowManager?.addView(audioWaveView, params)
            Log.d("InteractionService", "Audio wave view added.")
        }
    }

    /**
     * Connects the TTS audio output to the wave view for real-time visualization.
     */
    fun showAndSetupAudioWave() {
        showAudioWave()
        val ttsManager = TTSManager.getInstance(this)
        val audioSessionId = ttsManager.getAudioSessionId()

        if (audioSessionId == 0) {
            Log.e("InteractionService", "Failed to get valid audio session ID. Visualizer not started.")
            return
        }

        // Create the visualizer and link it to the AudioWaveView
        ttsVisualizer = TtsVisualizer(audioSessionId) { normalizedAmplitude ->
            Handler(Looper.getMainLooper()).post {
                audioWaveView?.setRealtimeAmplitude(normalizedAmplitude)
            }
        }

        // Use the utterance listener to start and stop the visualizer
        ttsManager.utteranceListener = { isSpeaking ->
            Handler(Looper.getMainLooper()).post {
                if (isSpeaking) {
                    audioWaveView?.setTargetAmplitude(0.2f)
                    ttsVisualizer?.start()
                } else {
                    ttsVisualizer?.stop()
                    audioWaveView?.setTargetAmplitude(0.0f)
                }
            }
        }
    }
    fun hideAudioWave() {
        Handler(Looper.getMainLooper()).post {
            audioWaveView?.let {
                if (it.isAttachedToWindow) {
                    windowManager?.removeView(it)
                    Log.d("InteractionService", "Audio wave view removed.")
                }
            }
            audioWaveView = null

            // Clean up visualizer and listener to prevent leaks
            ttsVisualizer?.stop()
            ttsVisualizer = null
            TTSManager.getInstance(this).utteranceListener = null
            Log.d("InteractionService", "Audio wave effect has been torn down.")
        }
    }


}

data class InteractableElement(
    val text: String?,
    val contentDescription: String?,
    val resourceId: String?,
    val className: String?,
    val bounds: android.graphics.Rect,
    // We can also hold a reference to the original node if needed for performing actions
    val node: android.view.accessibility.AccessibilityNodeInfo
) {
    // A helper to get the center coordinates, useful for tapping
    fun getCenter(): android.graphics.Point {
        return android.graphics.Point(bounds.centerX(), bounds.centerY())
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/SettingsActivity.kt
================================================
package com.blurr.voice

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.NumberPicker
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.lifecycle.lifecycleScope
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import com.blurr.voice.api.GoogleTts
import com.blurr.voice.api.PicovoiceKeyManager
import com.blurr.voice.api.TTSVoice
import com.blurr.voice.utilities.SpeechCoordinator
import com.blurr.voice.utilities.VoicePreferenceManager
import com.blurr.voice.utilities.UserProfileManager
import com.blurr.voice.utilities.WakeWordManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.io.File
import kotlin.coroutines.cancellation.CancellationException

class SettingsActivity : BaseNavigationActivity() {

    private lateinit var ttsVoicePicker: NumberPicker
    private lateinit var permissionsInfoButton: TextView
    private lateinit var batteryOptimizationHelpButton: TextView
    private lateinit var appVersionText: TextView
    private lateinit var editUserName: android.widget.EditText
    private lateinit var editUserEmail: android.widget.EditText
    private lateinit var editWakeWordKey: android.widget.EditText
    private lateinit var textGetPicovoiceKeyLink: TextView
    private lateinit var wakeWordButton: TextView
    private lateinit var buttonSignOut: Button
    private lateinit var wakeWordManager: WakeWordManager
    private lateinit var requestPermissionLauncher: ActivityResultLauncher<String>


    private lateinit var sc: SpeechCoordinator
    private lateinit var sharedPreferences: SharedPreferences
    private lateinit var availableVoices: List<TTSVoice>
    private var voiceTestJob: Job? = null

    companion object {
        private const val PREFS_NAME = "BlurrSettings"
        private const val KEY_SELECTED_VOICE = "selected_voice"
        private const val TEST_TEXT = "Hello, I'm Panda, and this is a test of the selected voice."
        private val DEFAULT_VOICE = TTSVoice.CHIRP_PUCK
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_settings)

        // Initialize permission launcher first
        requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                Toast.makeText(this, "Permission granted!", Toast.LENGTH_SHORT).show()
                // The manager will handle the service start after permission is granted.
                wakeWordManager.handleWakeWordButtonClick(wakeWordButton)
                updateWakeWordButtonState()
            } else {
                Toast.makeText(this, "Permission denied.", Toast.LENGTH_SHORT).show()
            }
        }

        initialize()
        setupUI()
        loadAllSettings()
        setupAutoSavingListeners()
        cacheVoiceSamples()
    }

    override fun onStop() {
        super.onStop()
        // Stop any lingering voice tests when the user leaves the screen
        sc.stop()
        voiceTestJob?.cancel()
    }

    private fun initialize() {
        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        sc = SpeechCoordinator.getInstance(this)
        availableVoices = GoogleTts.getAvailableVoices()
        // Initialize wake word manager
        wakeWordManager = WakeWordManager(this, requestPermissionLauncher)
    }

    private fun setupUI() {
        ttsVoicePicker = findViewById(R.id.ttsVoicePicker)
        permissionsInfoButton = findViewById(R.id.permissionsInfoButton)
        appVersionText = findViewById(R.id.appVersionText)
        batteryOptimizationHelpButton = findViewById(R.id.batteryOptimizationHelpButton)
      
        editWakeWordKey = findViewById(R.id.editWakeWordKey)
        wakeWordButton = findViewById(R.id.wakeWordButton)
        buttonSignOut = findViewById(R.id.buttonSignOut)

        editUserName = findViewById(R.id.editUserName)
        editUserEmail = findViewById(R.id.editUserEmail)
        textGetPicovoiceKeyLink = findViewById(R.id.textGetPicovoiceKeyLink)


        setupClickListeners()
        setupVoicePicker()

        // Prefill profile fields from saved values
        kotlin.runCatching {
            val pm = UserProfileManager(this)
            editUserName.setText(pm.getName() ?: "")
            editUserEmail.setText(pm.getEmail() ?: "")
        }

        // Show app version
        val versionName = BuildConfig.VERSION_NAME
        appVersionText.text = "Version $versionName"
    }

    private fun setupVoicePicker() {
        val voiceDisplayNames = availableVoices.map { it.displayName }.toTypedArray()
        ttsVoicePicker.minValue = 0
        ttsVoicePicker.maxValue = voiceDisplayNames.size - 1
        ttsVoicePicker.displayedValues = voiceDisplayNames
        ttsVoicePicker.wrapSelectorWheel = false
    }

    private fun setupClickListeners() {
        permissionsInfoButton.setOnClickListener {
            val intent = Intent(this, PermissionsActivity::class.java)
            startActivity(intent)
        }
        batteryOptimizationHelpButton.setOnClickListener {
            showBatteryOptimizationDialog()
        }
        wakeWordButton.setOnClickListener {
            val keyManager = PicovoiceKeyManager(this)
            
            // Step 1: Save key if provided in the EditText
            val userKey = editWakeWordKey.text.toString().trim()
            if (userKey.isNotEmpty()) {
                keyManager.saveUserProvidedKey(userKey)
                Toast.makeText(this, "Wake word key saved.", Toast.LENGTH_SHORT).show()
            }
            
            // Step 2: Check if we have a key (either just saved or previously saved)
            val hasKey = !keyManager.getUserProvidedKey().isNullOrBlank()
            
            if (!hasKey) {
                showPicovoiceKeyRequiredDialog()
                return@setOnClickListener
            }
            
            // Step 3: Enable the wake word
            wakeWordManager.handleWakeWordButtonClick(wakeWordButton)
            // Give the service a moment to update its state before refreshing the UI
            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({ updateWakeWordButtonState() }, 500)
        }
        textGetPicovoiceKeyLink.setOnClickListener {
            val url = "https://console.picovoice.ai/login"
            val intent = Intent(Intent.ACTION_VIEW)
            intent.data = Uri.parse(url)
            try {
                startActivity(intent)
            } catch (e: Exception) {
                // This might happen if the device has no web browser
                Toast.makeText(this, "Could not open link. No browser found.", Toast.LENGTH_SHORT).show()
                Log.e("SettingsActivity", "Failed to open Picovoice link", e)
            }
        }

        buttonSignOut.setOnClickListener {
            showSignOutConfirmationDialog()
        }
    }

    private fun setupAutoSavingListeners() {
        var isInitialLoad = true

        ttsVoicePicker.setOnValueChangedListener { _, _, newVal ->
            val selectedVoice = availableVoices[newVal]
            saveSelectedVoice(selectedVoice)

            if (!isInitialLoad) {
                voiceTestJob?.cancel()
                voiceTestJob = lifecycleScope.launch {
                    delay(400L)
                    // First, stop any currently playing voice
                    sc.stop()
                    // Then, play the new sample
                    playVoiceSample(selectedVoice)
                }
            }
        }

        ttsVoicePicker.post {
            isInitialLoad = false
        }
    }

    private fun playVoiceSample(voice: TTSVoice) {
        lifecycleScope.launch {
            val cacheDir = File(cacheDir, "voice_samples")
            val voiceFile = File(cacheDir, "${voice.name}.wav")

            try {
                if (voiceFile.exists()) {
                    val audioData = voiceFile.readBytes()
                    sc.playAudioData(audioData)
                    Log.d("SettingsActivity", "Playing cached sample for ${voice.displayName}")
                } else {
                    sc.testVoice(TEST_TEXT, voice)
                    Log.d("SettingsActivity", "Synthesizing test for ${voice.displayName}")
                }
            } catch (e: Exception) {
                if (e !is CancellationException) {
                    Log.e("SettingsActivity", "Error playing voice sample", e)
                    Toast.makeText(this@SettingsActivity, "Error playing voice", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun cacheVoiceSamples() {
        lifecycleScope.launch(Dispatchers.IO) {
            val cacheDir = File(cacheDir, "voice_samples")
            if (!cacheDir.exists()) cacheDir.mkdirs()

            var downloadedCount = 0
            for (voice in availableVoices) {
                val voiceFile = File(cacheDir, "${voice.name}.wav")
                if (!voiceFile.exists()) {
                    try {
                        val audioData = GoogleTts.synthesize(TEST_TEXT, voice)
                        voiceFile.writeBytes(audioData)
                        downloadedCount++
                    } catch (e: Exception) {
                        Log.e("SettingsActivity", "Failed to cache voice ${voice.name}", e)
                    }
                }
            }
            if (downloadedCount > 0) {
                runOnUiThread {
                    Toast.makeText(this@SettingsActivity, "$downloadedCount voice samples prepared.", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun loadAllSettings() {

        // Inside loadAllSettings()
        val keyManager = PicovoiceKeyManager(this)
        editWakeWordKey.setText(keyManager.getUserProvidedKey() ?: "") // You will create this method next
        val savedVoiceName = sharedPreferences.getString(KEY_SELECTED_VOICE, DEFAULT_VOICE.name)
        val savedVoice = availableVoices.find { it.name == savedVoiceName } ?: DEFAULT_VOICE
        ttsVoicePicker.value = availableVoices.indexOf(savedVoice)
        
        // Update wake word button state
        updateWakeWordButtonState()
    }

    private fun saveSelectedVoice(voice: TTSVoice) {
        VoicePreferenceManager.saveSelectedVoice(this, voice)
        Log.d("SettingsActivity", "Saved voice: ${voice.displayName}")
    }

    private fun showPicovoiceKeyRequiredDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle("Picovoice Key Required")
            .setMessage("To enable wake word functionality, you need a Picovoice AccessKey. You can get a free key from the Picovoice Console. Note: The Picovoice dashboard might not be available on mobile browsers sometimes - you may need to use a desktop browser.")
            .setPositiveButton("Get Key") { _, _ ->
                // Try to open Picovoice console
                val url = "https://console.picovoice.ai/login"
                val intent = Intent(Intent.ACTION_VIEW)
                intent.data = Uri.parse(url)
                try {
                    startActivity(intent)
                } catch (e: Exception) {
                    Toast.makeText(this, "Could not open link. No browser found or link unavailable on mobile. Please use a desktop browser.", Toast.LENGTH_LONG).show()
                    Log.e("SettingsActivity", "Failed to open Picovoice link", e)
                }
            }
            .setNegativeButton("Cancel") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
        
        // Set button text colors to white
        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(
            androidx.core.content.ContextCompat.getColor(this, R.color.white)
        )
        dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(
            androidx.core.content.ContextCompat.getColor(this, R.color.white)
        )
    }

    private fun updateWakeWordButtonState() {
        wakeWordManager.updateButtonState(wakeWordButton)
    }

    private fun showBatteryOptimizationDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle(getString(R.string.battery_optimization_title))
            .setMessage(getString(R.string.battery_optimization_message))
            .setPositiveButton(getString(R.string.learn_how)) { _, _ ->
                // Open the Tasker FAQ URL
                val url = "https://tasker.joaoapps.com/userguide/en/faqs/faq-problem.html#00"
                val intent = Intent(Intent.ACTION_VIEW)
                intent.data = Uri.parse(url)
                try {
                    startActivity(intent)
                } catch (e: Exception) {
                    Toast.makeText(this, "Could not open link. No browser found.", Toast.LENGTH_LONG).show()
                    Log.e("SettingsActivity", "Failed to open battery optimization link", e)
                }
            }
            .setNegativeButton("Cancel") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
        
        // Set button text colors to white
        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(
            androidx.core.content.ContextCompat.getColor(this, R.color.white)
        )
        dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(
            androidx.core.content.ContextCompat.getColor(this, R.color.white)
        )
    }

    private fun showSignOutConfirmationDialog() {
        AlertDialog.Builder(this)
            .setTitle("Sign Out")
            .setMessage("Are you sure you want to sign out? This will clear all your settings and data.")
            .setPositiveButton("Sign Out") { _, _ ->
                signOut()
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun signOut() {
        // Clear User Profile
        val userProfileManager = UserProfileManager(this)
        userProfileManager.clearProfile()

        // Clear all shared preferences for this app
        getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE).edit().clear().apply()


        // Restart the app by navigating to the onboarding screen
        val intent = Intent(this, LoginActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        startActivity(intent)
        finish()
    }

    
    override fun getContentLayoutId(): Int = R.layout.activity_settings
    
    override fun getCurrentNavItem(): BaseNavigationActivity.NavItem = BaseNavigationActivity.NavItem.SETTINGS
}


================================================
FILE: app/src/main/java/com/blurr/voice/agents/ClarificationAgent.kt
================================================
package com.blurr.voice.agents

import android.content.Context
import com.blurr.voice.api.GeminiApi
import com.google.ai.client.generativeai.type.TextPart
import org.json.JSONObject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import android.util.Log
import org.json.JSONException

/**
 * A data class to hold the parsed result from the clarification check for type safety.
 *
 * @property status The status of the instruction, either "CLEAR" or "NEEDS_CLARIFICATION".
 * @property questions A list of clarifying questions if the status is "NEEDS_CLARIFICATION".
 */
data class ClarificationResult(
    val status: String,
    val questions: List<String>
)

/**
 * An agent responsible for analyzing a user's task instruction to determine if it's
 * clear enough for execution or if it requires more information.
 * It communicates with the Gemini API using a structured JSON format for both requests and responses.
 */
class ClarificationAgent {

    /**
     * Analyzes the user's instruction and returns a result indicating if clarification is needed.
     * This is the main entry point for the agent.
     *
     * @param instruction The user's raw task instruction (e.g., "send a message to mom").
     * @param conversationHistory The recent history of the conversation for context.
     * @param context The Android context, required for the Gemini API call.
     * @return A [ClarificationResult] containing the status and any necessary questions.
     */
    suspend fun analyze(instruction: String, conversationHistory: List<Pair<String, List<Any>>>, context: Context): ClarificationResult {
        try {
            // 1. Create a specialized prompt for the LLM.
            val prompt = createPrompt(instruction, conversationHistory)

            // 2. Prepare the chat structure for the Gemini API.
            // For this specific task, we only need to send our structured prompt.
            val apiChat = listOf("user" to listOf(TextPart(prompt)))

            // 3. Call the Gemini API.
            val responseJson = withContext(Dispatchers.IO) {
                GeminiApi.generateContent(
                    chat = apiChat,
                    modelName = "gemini-1.5-flash-latest", // Using a fast, modern model for this task.
                    context = context
                )
            }
            Log.d("ClarificationAgent", "Clarification API Response: $responseJson")

            // 4. Parse the JSON response into our data class.
            return parseResponse(responseJson)

        } catch (e: Exception) {
            Log.e("ClarificationAgent", "Error during clarification analysis", e)
            // Fallback safety net: If any error occurs, assume the instruction is clear
            // to prevent the agent from getting stuck.
            return ClarificationResult("CLEAR", emptyList())
        }
    }

    /**
     * Parses the JSON response string from the Gemini API into a [ClarificationResult].
     * It's designed to be robust against common formatting issues like markdown code blocks.
     *
     * @param jsonResponse The raw JSON string from the API.
     * @return A [ClarificationResult] object. Returns a default "CLEAR" result on parsing failure.
     */
    private fun parseResponse(jsonResponse: String?): ClarificationResult {
        if (jsonResponse.isNullOrBlank()) {
            Log.w("ClarificationAgent", "Received null or blank response from API. Defaulting to CLEAR.")
            return ClarificationResult("CLEAR", emptyList())
        }
        try {
            // Clean the response to handle cases where the model wraps JSON in markdown.
            val cleanedJson = jsonResponse.trim().removePrefix("```json").removePrefix("```").removeSuffix("```").trim()

            val json = JSONObject(cleanedJson)
            val status = json.optString("status", "CLEAR")
            val questionsArray = json.optJSONArray("questions")
            val questions = mutableListOf<String>()

            if (questionsArray != null) {
                for (i in 0 until questionsArray.length()) {
                    questions.add(questionsArray.getString(i))
                }
            }
            return ClarificationResult(status, questions)
        } catch (e: JSONException) {
            Log.e("ClarificationAgent", "Failed to parse clarification JSON: $jsonResponse", e)
            // Fallback on parsing failure.
            return ClarificationResult("CLEAR", emptyList())
        }
    }

    /**
     * Creates the prompt for the Gemini API, instructing it to analyze the user's
     * instruction and respond with a specific JSON format.
     *
     * @param instruction The user's task instruction to analyze.
     * @param conversationHistory The recent conversation history for context.
     * @return A formatted prompt string.
     */
    private fun createPrompt(instruction: String, conversationHistory: List<Pair<String, List<Any>>>): String {
        // Build a concise version of the conversation history for context.
        val historyString = conversationHistory
            .takeLast(6) // Use last 6 turns to keep the prompt focused.
            .joinToString("\n") { (role, parts) ->
                val text = parts.filterIsInstance<TextPart>().joinToString(" ") { it.text }
                // Clean up the model's JSON response from the main conversation history.
                val cleanedText = if (role == "model" && text.trim().startsWith("{")) "[Agent performs an action]" else text
                "$role: $cleanedText"
            }

        return """
            You are an AI assistant that analyzes a user's instruction to determine if it requires clarification before an automated agent can execute it.
            Your goal is to identify ambiguous or incomplete instructions and generate specific, actionable questions to gather the missing details. The agent can see the screen, tap, and use the phone like a human.

            Analyze the user's latest instruction within the context of the recent conversation.

            ### Recent Conversation History ###
            $historyString
            ### End Conversation History ###

            ### User's Task Instruction to Analyze ###
            "$instruction"

            ### Your Task ###
            Based on the instruction and the conversation history, decide if the instruction is clear enough to be executed or if it needs clarification.
            - An instruction is CLEAR if it can be performed without any more information (e.g., "Open WhatsApp", "Take a screenshot").
            - An instruction NEEDS CLARIFICATION if it's missing key details (e.g., "Send a message" (to whom? what message?), "Set an alarm" (for what time?), "Book a ride" (to where?)).

            ### Response Format ###
            You MUST respond with a single, valid JSON object only. Do not add any text before or after the JSON.
            The JSON object must have the following structure:
            {
              "status": "CLEAR" | "NEEDS_CLARIFICATION",
              "questions": [ "An array of strings, where each string is a specific clarifying question." ]
            }

            Example 1 (Needs Clarification):
            Instruction: "Message my brother happy birthday"
            Response:
            {
              "status": "NEEDS_CLARIFICATION",
              "questions": [
                "Which of your brothers should I message?",
                "Which app should I use to send the message?"
              ]
            }

            Example 2 (Clear):
            Instruction: "Go to the home screen"
            Response:
            {
              "status": "CLEAR",
              "questions": []
            }
        """.trimIndent()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/EmbeddingService.kt
================================================
package com.blurr.voice.api

import android.util.Log
import kotlinx.coroutines.delay
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import java.util.concurrent.TimeUnit
import com.blurr.voice.utilities.ApiKeyManager
import com.blurr.voice.utilities.NetworkNotifier

/**
 * Service for generating embeddings using Gemini API
 */
object EmbeddingService {
    
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(60, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    /**
     * Generate embedding for a single text
     */
    suspend fun generateEmbedding(
        text: String,
        taskType: String = "RETRIEVAL_DOCUMENT",
        maxRetries: Int = 3
    ): List<Float>? {
        // Network check
        try {
            val isOnline = true
            if (!isOnline) {
                Log.e("EmbeddingService", "No internet connection. Skipping embedding call.")
                NetworkNotifier.notifyOffline()
                return null
            }
        } catch (e: Exception) {
            Log.e("EmbeddingService", "Network check failed, assuming offline. ${e.message}")
            return null
        }
        var attempts = 0
        while (attempts < maxRetries) {
            val currentApiKey = ApiKeyManager.getNextKey()
            Log.d("EmbeddingService", "=== EMBEDDING API REQUEST (Attempt ${attempts + 1}) ===")
            Log.d("EmbeddingService", "Using API key ending in: ...${currentApiKey.takeLast(4)}")
            Log.d("EmbeddingService", "Task type: $taskType")
            Log.d("EmbeddingService", "Text: ${text.take(100)}...")
            
            try {
                val payload = JSONObject().apply {
                    put("model", "models/gemini-embedding-001")
                    put("content", JSONObject().apply {
                        put("parts", JSONArray().apply {
                            put(JSONObject().put("text", text))
                        })
                    })
                    put("taskType", taskType)
                }
                
                val request = Request.Builder()
                    .url("https://generativelanguage.googleapis.com/v1beta/models/gemini-embedding-001:embedContent?key=$currentApiKey")
                    .post(payload.toString().toRequestBody("application/json".toMediaType()))
                    .build()
                
                client.newCall(request).execute().use { response ->
                    val responseBody = response.body?.string()
                    
                    Log.d("EmbeddingService", "=== EMBEDDING API RESPONSE (Attempt ${attempts + 1}) ===")
                    Log.d("EmbeddingService", "HTTP Status: ${response.code}")
                    
                    if (!response.isSuccessful || responseBody.isNullOrEmpty()) {
                        Log.e("EmbeddingService", "API call failed with HTTP ${response.code}. Response: $responseBody")
                        throw Exception("API Error ${response.code}: $responseBody")
                    }
                    
                    val embedding = parseEmbeddingResponse(responseBody)
                    Log.d("EmbeddingService", "Successfully generated embedding with ${embedding.size} dimensions")
                    return embedding
                }
                
            } catch (e: Exception) {
                Log.e("EmbeddingService", "=== EMBEDDING API ERROR (Attempt ${attempts + 1}) ===", e)
                attempts++
                if (attempts < maxRetries) {
                    val delayTime = 1000L * attempts
                    Log.d("EmbeddingService", "Retrying in ${delayTime}ms...")
                    delay(delayTime)
                } else {
                    Log.e("EmbeddingService", "Embedding generation failed after all $maxRetries retries.")
                    return null
                }
            }
        }
        return null
    }
    
    /**
     * Generate embeddings for multiple texts by calling the API for each text individually
     */
    suspend fun generateEmbeddings(
        texts: List<String>,
        taskType: String = "RETRIEVAL_DOCUMENT",
        maxRetries: Int = 3
    ): List<List<Float>>? {
        Log.d("EmbeddingService", "=== BATCH EMBEDDING REQUEST ===")
        Log.d("EmbeddingService", "Texts count: ${texts.size}")
        
        val embeddings = mutableListOf<List<Float>>()
        
        for ((index, text) in texts.withIndex()) {
            Log.d("EmbeddingService", "Processing text ${index + 1}/${texts.size}")
            val embedding = generateEmbedding(text, taskType, maxRetries)
            if (embedding != null) {
                embeddings.add(embedding)
            } else {
                Log.e("EmbeddingService", "Failed to generate embedding for text ${index + 1}")
                return null // Return null if any embedding fails
            }
        }
        
        Log.d("EmbeddingService", "Successfully generated ${embeddings.size} embeddings")
        return embeddings
    }
    
    private fun parseEmbeddingResponse(responseBody: String): List<Float> {
        val json = JSONObject(responseBody)
        val embedding = json.getJSONObject("embedding")
        val values = embedding.getJSONArray("values")
        
        return (0 until values.length()).map { i ->
            values.getDouble(i).toFloat()
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/api/Eyes.kt
================================================
package com.blurr.voice.api

import android.content.Context
import android.graphics.Bitmap
import android.os.Build
import android.os.Environment
import java.io.File
import android.util.Log
import androidx.annotation.RequiresApi
import com.blurr.voice.RawScreenData
import com.blurr.voice.ScreenInteractionService

class Eyes(context: Context) {

    // This now points to the public directory where your screenshots will be saved.
    private val publicPicturesDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)

    // This will now point to the specific screenshot file after it's created.
    private var latestScreenshotFile: File? = null

    // The path for the XML file can remain internal as you don't need to view it manually.
    private val xmlFile: File = File(context.filesDir, "window_dump.xml")

    /**
     * Takes a screenshot and saves it to the public Pictures/ScreenAgent directory.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun openEyes(): Bitmap? {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("Eyes", "Accessibility Service is not running!")
            return null
        }
        // Directly call the suspend function on the service
        return service.captureScreenshot()
    }

    /**
     * Dumps the current UI layout to an XML file using the Accessibility Service.
     */
    @RequiresApi(Build.VERSION_CODES.O)
    suspend fun openPureXMLEyes(): String {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("AccessibilityController", "Accessibility Service is not running!")
            return "<hierarchy/>"
        }
        Log.d("AccessibilityController", "Requesting UI layout dump...")
        return service.dumpWindowHierarchy(true)
    }

    /**
     * Dumps the current UI layout in a more readable markdown format.
     */
    @RequiresApi(Build.VERSION_CODES.O)
    suspend fun openXMLEyes(): String {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("AccessibilityController", "Accessibility Service is not running!")
            return "<hierarchy/>"
        }
        Log.d("AccessibilityController", "Requesting UI layout dump...")
        return service.dumpWindowHierarchy()
    }

    fun getKeyBoardStatus(): Boolean {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("AccessibilityController", "Accessibility Service is not running!")
            return false
        }
        return service.isTypingAvailable()
    }

    /**
     * Gets all raw screen data (XML, scroll info) in a single, efficient call.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun getRawScreenData(): RawScreenData? {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("AccessibilityController", "Accessibility Service is not running!")
            return RawScreenData("", 0,0, 0, 0)
        }
        return service.getScreenAnalysisData()
    }

    /**
     * Gets the package name of the current foreground activity.
     */
    fun getCurrentActivityName(): String {
        val service = ScreenInteractionService.instance
        if (service == null) {
            Log.e("AccessibilityController", "Accessibility Service is not running!")
            return "Unknown"
        }
        return service.getCurrentActivityName()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/Finger.kt
================================================
package com.blurr.voice.api

import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import com.blurr.voice.ScreenInteractionService

/**
 * A rewritten Finger class that uses the AccessibilityService for all actions,
 * requiring no root access.
 */
class Finger(private val context: Context) {

    private val TAG = "Finger (Accessibility)"

    // A helper to safely get the service instance
    private val service: ScreenInteractionService?
        get() {
            val instance = ScreenInteractionService.instance
            if (instance == null) {
                Log.e(TAG, "ScreenInteractionService is not running or not connected!")
            }
            return instance
        }

    /**
     * Starts the ChatActivity within the app using a standard Android Intent.
     */
    fun goToChatRoom(message: String) {
        Log.d(TAG, "Opening ChatActivity with message: $message")
        try {
            val intent = Intent().apply {
                // Use the app's own context to find the activity class
                setClassName(context, "com.blurr.app.ChatActivity")
                putExtra("custom_message", message)
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(intent)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start ChatActivity. Make sure it's defined in your AndroidManifest.xml", e)
        }
    }

    /**
     * Opens an app directly using package manager (requires QUERY_ALL_PACKAGES permission).
     * This method is intended for debugging purposes only and should be disabled in production.
     * 
     * @param packageName The package name of the app to open
     * @return true if the app was successfully launched, false otherwise
     */
    fun openApp(packageName: String): Boolean {
        Log.d(TAG, "Attempting to open app with package: $packageName")
        return try {
            val packageManager = context.packageManager
            val intent = packageManager.getLaunchIntentForPackage(packageName)
            
            if (intent != null) {
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)
                Log.d(TAG, "Successfully launched app: $packageName")
                true
            } else {
                Log.e(TAG, "No launch intent found for package: $packageName")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to open app: $packageName", e)
            false
        }
    }

    /**
     * Launch an arbitrary intent safely.
     */
    fun launchIntent(intent: Intent): Boolean {
        return try {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(intent)
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start intent: $intent", e)
            false
        }
    }

    /**
     * Taps a point on the screen.
     */
    fun tap(x: Int, y: Int) {
        Log.d(TAG, "Tapping at ($x, $y)")
        service?.clickOnPoint(x.toFloat(), y.toFloat())
    }

    /**
     * Performs a long press (press and hold) at a specific point on the screen.
     */
    fun longPress(x: Int, y: Int) {
        Log.d(TAG, "Long pressing at ($x, $y)")
        // This assumes your ScreenInteractionService has a method `longClickOnPoint`
        service?.longClickOnPoint(x.toFloat(), y.toFloat())
    }

    /**
     * Swipes between two points on the screen.
     */
    fun swipe(x1: Int, y1: Int, x2: Int, y2: Int, duration: Int = 1000) {
        Log.d(TAG, "Swiping from ($x1, $y1) to ($x2, $y2)")
        service?.swipe(x1.toFloat(), y1.toFloat(), x2.toFloat(), y2.toFloat(), duration.toLong())
    }

    /**
     * Types text i)nto the focused input field. This is now much more efficient.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    fun type(text: String) {
        Log.d(TAG, "Typing text: $text")
        service?.typeTextInFocusedField(text)
        this.enter()
    }

    /**
     * Simulates pressing the 'Enter' key.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    fun enter() {
        Log.d(TAG, "Performing 'Enter' action")
        service?.performEnter()
    }

    /**
     * Navigates back.
     */
    fun back() {
        Log.d(TAG, "Performing 'Back' action")
        service?.performBack()
    }

    /**
     * Goes to the home screen.
     */
    fun home() {
        Log.d(TAG, "Performing 'Home' action")
        service?.performHome()
    }

    /**
     * Opens the app switcher (recents).
     */
    fun switchApp() {
        Log.d(TAG, "Performing 'App Switch' action")
        service?.performRecents()
    }
    /**
     * Scrolls the screen down by a given number of pixels.
     * This performs a swipe from bottom to top.
     *
     * @param pixels The number of pixels to scroll.
     * @param duration The duration of the swipe in milliseconds.
     */
    fun scrollUp(pixels: Int, duration: Int = 500) {
        val displayMetrics = context.resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels
        val screenHeight = displayMetrics.heightPixels

        // Define swipe path in the middle of the screen
        val x = screenWidth / 2
        // Start swipe from 80% down the screen to avoid navigation bars
        val y1 = (screenHeight * 0.8).toInt()
        // Calculate end point, ensuring it doesn't go below 0
        val y2 = (y1 - pixels).coerceAtLeast(0)

        Log.d(TAG, "Scrolling down by $pixels pixels: swipe from ($x, $y1) to ($x, $y2)")
        swipe(x, y1, x, y2, duration)
    }

    /**
     * Scrolls the screen up by a given number of pixels.
     * This performs a swipe from top to bottom.
     *
     * @param pixels The number of pixels to scroll.
     * @param duration The duration of the swipe in milliseconds.
     */
    fun scrollDown(pixels: Int, duration: Int = 500) {
        val displayMetrics = context.resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels
        val screenHeight = displayMetrics.heightPixels

        // Define swipe path in the middle of the screen
        val x = screenWidth / 2
        // Start swipe from 20% down the screen to avoid status bars
        val y1 = (screenHeight * 0.2).toInt()
        // Calculate end point, ensuring it doesn't go beyond screen height
        val y2 = (y1 + pixels).coerceAtMost(screenHeight)

        Log.d(TAG, "Scrolling up by $pixels pixels: swipe from ($x, $y1) to ($x, $y2)")
        swipe(x, y1, x, y2, duration)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/GeminiApi.kt
================================================
package com.blurr.voice.api

import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.blurr.voice.BuildConfig
import com.blurr.voice.MyApplication
import com.blurr.voice.utilities.ApiKeyManager
import com.google.ai.client.generativeai.type.ImagePart
import com.google.ai.client.generativeai.type.TextPart
import com.google.firebase.Firebase
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.delay
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import com.blurr.voice.utilities.NetworkConnectivityManager
import com.blurr.voice.utilities.NetworkNotifier
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit

/**
 * Refactored GeminiApi as a singleton object.
 * It now gets a rotated API key from ApiKeyManager for every request
 * and logs all requests and responses to a persistent file.
 */
object GeminiApi {
    private val proxyUrl: String = BuildConfig.GCLOUD_PROXY_URL
    private val proxyKey: String = BuildConfig.GCLOUD_PROXY_URL_KEY

    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(90, TimeUnit.SECONDS)
        .writeTimeout(60, TimeUnit.SECONDS)
        .build()
    val db = Firebase.firestore


    suspend fun generateContent(
        chat: List<Pair<String, List<Any>>>,
        images: List<Bitmap> = emptyList(),
        modelName: String = "gemini-2.5-flash", // Updated to a more standard model name
        maxRetry: Int = 4,
        context: Context? = null
    ): String? {
        // Network check before making any calls
        try {
            val appCtx = context ?: MyApplication.appContext
            val isOnline = NetworkConnectivityManager(appCtx).isNetworkAvailable()
            if (!isOnline) {
                Log.e("GeminiApi", "No internet connection. Skipping generateContent call.")
                NetworkNotifier.notifyOffline()
                return null
            }
        } catch (e: Exception) {
            Log.e("GeminiApi", "Network check failed, assuming offline. ${e.message}")
            return null
        }
        // Extract the last user prompt text for logging purposes.
        val lastUserPrompt = chat.lastOrNull { it.first == "user" }
            ?.second
            ?.filterIsInstance<TextPart>()
            ?.joinToString(separator = "\n") { it.text } ?: "No text prompt found"

        var attempts = 0
        while (attempts < maxRetry) {
            // Get a new API key for each attempt
            val currentApiKey = ApiKeyManager.getNextKey()
            Log.d("GeminiApi", "=== GEMINI API REQUEST (Attempt ${attempts + 1}) ===")
            Log.d("GeminiApi", "Using API key ending in: ...${currentApiKey.takeLast(4)}")
            Log.d("GeminiApi", "Model: $modelName")

            val attemptStartTime = System.currentTimeMillis()
            // IMPORTANT: Define payload here so it's accessible in the catch block for logging.
            // MODIFIED: Pass modelName to buildPayload
            val payload = buildPayload(chat, modelName)

            Log.d("GeminiApi", "=== GEMINI API REQUEST (Attempt ${attempts + 1}) ===")
            Log.d("GeminiApi", "Model: $modelName")
            Log.d("GeminiApi", "Payload: ${payload.toString().take(500)}...")

            try {
                val request = Request.Builder()
                    .url(proxyUrl)
                    .post(payload.toString().toRequestBody("application/json".toMediaType()))
                    .addHeader("Content-Type", "application/json")
                    .addHeader("X-API-Key", proxyKey)
                    .build()

                val requestStartTime = System.currentTimeMillis()
                client.newCall(request).execute().use { response ->
                    val responseEndTime = System.currentTimeMillis()
                    val requestTime = responseEndTime - requestStartTime
                    val totalAttemptTime = responseEndTime - attemptStartTime
                    val responseBody = response.body?.string()

                    Log.d("GeminiApi", "=== GEMINI API RESPONSE (Attempt ${attempts + 1}) ===")
                    Log.d("GeminiApi", "HTTP Status: ${response.code}")
                    Log.d("GeminiApi", "Request time: ${requestTime}ms")

                    if (!response.isSuccessful || responseBody.isNullOrEmpty()) {
                        Log.e("GeminiApi", "API call failed with HTTP ${response.code}. Response: $responseBody")
                        throw Exception("API Error ${response.code}: $responseBody")
                    }

                    // Assuming the proxy returns the standard Gemini API response format
                    val parsedResponse = responseBody

                    val logEntry = createLogEntry(
                        attempt = attempts + 1,
                        modelName = modelName,
                        prompt = lastUserPrompt,
                        imagesCount = images.size,
                        payload = payload.toString(),
                        responseCode = response.code,
                        responseBody = responseBody,
                        responseTime = requestTime,
                        totalTime = totalAttemptTime
                    )
                    saveLogToFile(MyApplication.appContext, logEntry)
                    val logData = createLogDataMap(
                        attempt = attempts + 1,
                        modelName = modelName,
                        prompt = lastUserPrompt,
                        imagesCount = images.size,
                        responseCode = null, // Note: This was null, kept as is
                        responseTime = requestTime,
                        totalTime = totalAttemptTime,
                        responseBody = responseBody,
                        status = "pass",
                    )
                    logToFirestore(logData)


                    return parsedResponse
                }
            } catch (e: Exception) {
                val attemptEndTime = System.currentTimeMillis()
                val totalAttemptTime = attemptEndTime - attemptStartTime

                Log.e("GeminiApi", "=== GEMINI API ERROR (Attempt ${attempts + 1}) ===", e)

                // Save the error log entry to a file.
                val logEntry = createLogEntry(
                    attempt = attempts + 1,
                    modelName = modelName,
                    prompt = lastUserPrompt,
                    imagesCount = images.size,
                    payload = payload.toString(), // Log the payload that caused the error
                    responseCode = null,
                    responseBody = null,
                    responseTime = 0,
                    totalTime = totalAttemptTime,
                    error = e.message
                )
                saveLogToFile(MyApplication.appContext, logEntry)
                val logData = createLogDataMap(
                    attempt = attempts + 1,
                    modelName = modelName,
                    prompt = lastUserPrompt,
                    imagesCount = images.size,
                    responseCode = null,
                    responseTime = 0,
                    totalTime = totalAttemptTime,
                    status = "error",
                    responseBody = null,
                    error = e.message
                )
                logToFirestore(logData)

                attempts++
                if (attempts < maxRetry) {
                    val delayTime = 1000L * attempts
                    Log.d("GeminiApi", "Retrying in ${delayTime}ms...")
                    delay(delayTime)
                } else {
                    Log.e("GeminiApi", "Request failed after all ${maxRetry} retries.")
                    return null
                }
            }
        }
        return null
    }

    /**
     * MODIFIED: This function now builds the payload to match the structure required by the proxy in code-2.
     * The new structure is: { "modelName": "...", "messages": [ { "role": "...", "parts": [ { "text": "..." } ] } ] }
     * NOTE: This proxy structure does not support images. ImageParts will be ignored.
     */
    private fun buildPayload(chat: List<Pair<String, List<Any>>>, modelName: String): JSONObject {
        val rootObject = JSONObject()
        rootObject.put("modelName", modelName)

        val messagesArray = JSONArray()
        chat.forEach { (role, parts) ->
            val messageObject = JSONObject()
            messageObject.put("role", role.lowercase())

            val jsonParts = JSONArray()
            parts.forEach { part ->
                when (part) {
                    is TextPart -> {
                        // The structure for a part is {"text": "..."}
                        val partObject = JSONObject().put("text", part.text)
                        jsonParts.put(partObject)
                    }
                    is ImagePart -> {
                        // Log a warning that images are being skipped for the proxy call
                        Log.w("GeminiApi", "ImagePart found but skipped. The proxy payload format does not support images.")
                    }
                }
            }

            // Only add the message to the array if it contains text parts
            if (jsonParts.length() > 0) {
                messageObject.put("parts", jsonParts)
                messagesArray.put(messageObject)
            }
        }

        rootObject.put("messages", messagesArray)
        return rootObject
    }

    /**
     * This function parses the standard response from the Gemini API.
     * It is assumed the proxy forwards this response structure without modification.
     */
    private fun parseSuccessResponse(responseBody: String): String? {
        return try {
            val json = JSONObject(responseBody)
            // Handle cases where the proxy might return a simplified text response directly
            if (json.has("text")) {
                return json.getString("text")
            }
            // Standard Gemini API response parsing
            if (!json.has("candidates")) {
                Log.w("GeminiApi", "API response has no 'candidates'. It was likely blocked. Full response: $responseBody")
                // Check for proxy-specific error format
                if (json.has("error")) {
                    Log.e("GeminiApi", "Proxy returned an error: ${json.getString("error")}")
                }
                return null
            }
            val candidates = json.getJSONArray("candidates")
            if (candidates.length() == 0) {
                Log.w("GeminiApi", "API response has an empty 'candidates' array. Full response: $responseBody")
                return null
            }
            val firstCandidate = candidates.getJSONObject(0)
            if (!firstCandidate.has("content")) {
                Log.w("GeminiApi", "First candidate has no 'content' object. Full response: $responseBody")
                return null
            }
            val content = firstCandidate.getJSONObject("content")
            if (!content.has("parts")) {
                Log.w("GeminiApi", "Content object has no 'parts' array. Full response: $responseBody")
                return null
            }
            val parts = content.getJSONArray("parts")
            if (parts.length() == 0) {
                Log.w("GeminiApi", "Parts array is empty. Full response: $responseBody")
                return null
            }
            parts.getJSONObject(0).getString("text")
        } catch (e: Exception) {
            Log.e("GeminiApi", "Failed to parse successful response: $responseBody", e)
            // As a fallback, if parsing fails but there was a response, return the raw string.
            // The proxy might be configured to return plain text on success.
            responseBody
        }
    }


    private fun saveLogToFile(context: Context, logEntry: String) {
        try {
            val logDir = File(context.filesDir, "gemini_logs")
            if (!logDir.exists()) {
                logDir.mkdirs()
            }
            // Use a single, rolling log file for simplicity.
            val logFile = File(logDir, "gemini_api_log.txt")

            FileWriter(logFile, true).use { writer ->
                writer.append(logEntry)
            }
            Log.d("GeminiApi", "Log entry saved to: ${logFile.absolutePath}")

        } catch (e: Exception) {
            Log.e("GeminiApi", "Failed to save log to file", e)
        }
    }
    private fun logToFirestore(logData: Map<String, Any?>) {
        // Create a unique and descriptive ID from the timestamp and prompt
        val timestamp = System.currentTimeMillis()
        val promptSnippet = (logData["prompt"] as? String)?.take(40) ?: "log"

        // Sanitize the prompt snippet to be a valid Firestore document ID
        // (removes spaces and special characters)
        val sanitizedPrompt = promptSnippet.replace(Regex("[^a-zA-Z0-9]"), "_")

        val documentId = "${timestamp}_$sanitizedPrompt"

        // Use .document(ID).set(data) instead of .add(data)
        db.collection("gemini_logs")
            .document(documentId)
            .set(logData)
            .addOnSuccessListener {
                Log.d("GeminiApi", "Log sent to Firestore with ID: $documentId")
            }
            .addOnFailureListener { e ->
                // This listener is for debugging; it won't block your app's flow
                Log.e("GeminiApi", "Error sending log to Firestore", e)
            }
    }
    private fun createLogEntry(
        attempt: Int,
        modelName: String,
        prompt: String,
        imagesCount: Int,
        payload: String,
        responseCode: Int?,
        responseBody: String?,
        responseTime: Long,
        totalTime: Long,
        error: String? = null
    ): String {
        return buildString {
            appendLine("=== GEMINI API DEBUG LOG ===")
            appendLine("Timestamp: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault()).format(Date())}")
            appendLine("Attempt: $attempt")
            appendLine("Model: $modelName")
            appendLine("Images count: $imagesCount")
            appendLine("Prompt length: ${prompt.length}")
            appendLine("Prompt: $prompt")
            appendLine("Payload: $payload")
            appendLine("Response code: $responseCode")
            appendLine("Response time: ${responseTime}ms")
            appendLine("Total time: ${totalTime}ms")
            if (error != null) {
                appendLine("Error: $error")
            } else {
                appendLine("Response body: $responseBody")
            }
            appendLine("=== END LOG ===")
        }
    }
    private fun createLogDataMap(
        attempt: Int,
        modelName: String,
        prompt: String,
        imagesCount: Int,
        responseCode: Int?,
        responseTime: Long,
        totalTime: Long,
        status: String,
        responseBody: String?,
        error: String? = null
    ): Map<String, Any?> {
        return mapOf(
            "timestamp" to FieldValue.serverTimestamp(), // Use server time
            "status" to status,
            "attempt" to attempt,
            "model" to modelName,
            "prompt" to prompt,
            "imagesCount" to imagesCount,
            "responseCode" to responseCode,
            "responseTimeMs" to responseTime,
            "totalTimeMs" to totalTime,
            "llmReply" to responseBody,
            "error" to error
        )
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/GoogleTTS.kt
================================================
package com.blurr.voice.api

import android.util.Base64
import android.util.Log
import com.blurr.voice.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import com.blurr.voice.MyApplication
import com.blurr.voice.utilities.NetworkConnectivityManager
import com.blurr.voice.utilities.NetworkNotifier

/**
 * Available voice options for Google TTS, using all provided Chirp3-HD voices.
 */
enum class TTSVoice(val displayName: String, val voiceName: String, val description: String) {
    CHIRP_ACHERNAR("Achernar", "en-US-Chirp3-HD-Achernar", "High-definition female voice."),
    CHIRP_ACHIRD("Achird", "en-US-Chirp3-HD-Achird", "High-definition male voice."),
    CHIRP_ALGENIB("Algenib", "en-US-Chirp3-HD-Algenib", "High-definition male voice."),
    CHIRP_ALGIEBA("Algieba", "en-US-Chirp3-HD-Algieba", "High-definition male voice."),
    CHIRP_ALNILAM("Alnilam", "en-US-Chirp3-HD-Alnilam", "High-definition male voice."),
    CHIRP_AOEDE("Aoede", "en-US-Chirp3-HD-Aoede", "High-definition female voice."),
    CHIRP_AUTONOE("Autonoe", "en-US-Chirp3-HD-Autonoe", "High-definition female voice."),
    CHIRP_CALLIRRHOE("Callirrhoe", "en-US-Chirp3-HD-Callirrhoe", "High-definition female voice."),
    CHIRP_CHARON("Charon", "en-US-Chirp3-HD-Charon", "High-definition male voice."),
    CHIRP_DESPINA("Despina", "en-US-Chirp3-HD-Despina", "High-definition female voice."),
    CHIRP_ENCELADUS("Enceladus", "en-US-Chirp3-HD-Enceladus", "High-definition male voice."),
    CHIRP_ERINOME("Erinome", "en-US-Chirp3-HD-Erinome", "High-definition female voice."),
    CHIRP_FENRIR("Fenrir", "en-US-Chirp3-HD-Fenrir", "High-definition male voice."),
    CHIRP_GACRUX("Gacrux", "en-US-Chirp3-HD-Gacrux", "High-definition female voice."),
    CHIRP_IAPETUS("Iapetus", "en-US-Chirp3-HD-Iapetus", "High-definition male voice."),
    CHIRP_KORE("Kore", "en-US-Chirp3-HD-Kore", "High-definition female voice."),
    CHIRP_LAOMEDEIA("Laomedeia", "en-US-Chirp3-HD-Laomedeia", "High-definition female voice."),
    CHIRP_LEDA("Leda", "en-US-Chirp3-HD-Leda", "High-definition female voice."),
    CHIRP_ORUS("Orus", "en-US-Chirp3-HD-Orus", "High-definition male voice."),
    CHIRP_PUCK("Puck", "en-US-Chirp3-HD-Puck", "High-definition male voice."),
    CHIRP_PULCHERRIMA("Pulcherrima", "en-US-Chirp3-HD-Pulcherrima", "High-definition female voice."),
    CHIRP_RASALGETHI("Rasalgethi", "en-US-Chirp3-HD-Rasalgethi", "High-definition male voice."),
    CHIRP_SADACHBIA("Sadachbia", "en-US-Chirp3-HD-Sadachbia", "High-definition male voice."),
    CHIRP_SADALTAGER("Sadaltager", "en-US-Chirp3-HD-Sadaltager", "High-definition male voice."),
    CHIRP_SCHEDAR("Schedar", "en-US-Chirp3-HD-Schedar", "High-definition male voice."),
    CHIRP_SULAFAT("Sulafat", "en-US-Chirp3-HD-Sulafat", "High-definition female voice."),
    CHIRP_UMBRIEL("Umbriel", "en-US-Chirp3-HD-Umbriel", "High-definition male voice."),
    CHIRP_VINDEMIATRIX("Vindemiatrix", "en-US-Chirp3-HD-Vindemiatrix", "High-definition female voice."),
    CHIRP_ZEPHYR("Zephyr", "en-US-Chirp3-HD-Zephyr", "High-definition female voice."),
    CHIRP_ZUBENELGENUBI("Zubenelgenubi", "en-US-Chirp3-HD-Zubenelgenubi", "High-definition male voice.")
}
/**
 * Handles communication with the Google Cloud Text-to-Speech API.
 */
object GoogleTts {
    const val apiKey = BuildConfig.GOOGLE_TTS_API_KEY
    private val client = OkHttpClient()
    private const val API_URL = "https://texttospeech.googleapis.com/v1beta1/text:synthesize?key=$apiKey"

    /**
     * Synthesizes speech from text using the Google Cloud TTS API with default voice.
     * @param text The text to synthesize.
     * @return A ByteArray containing the raw audio data (LINEAR16 PCM).
     * @throws Exception if the API call fails or the response is invalid.
     */
    suspend fun synthesize(text: String): ByteArray = synthesize(text, TTSVoice.CHIRP_LAOMEDEIA)
    /**
     * Synthesizes speech from text using the Google Cloud TTS API.
     * @param text The text to synthesize.
     * @param voice The voice to use for synthesis.
     * @return A ByteArray containing the raw audio data (LINEAR16 PCM).
     * @throws Exception if the API call fails or the response is invalid.
     */
    suspend fun synthesize(text: String, voice: TTSVoice): ByteArray = withContext(Dispatchers.IO) {
        if (apiKey.isEmpty()) {
            throw Exception("Google TTS API key is not configured.")
        }
        println(voice.displayName)

        // Network check
        val isOnline = try {
            true
        } catch (e: Exception) {
            Log.e("GoogleTts", "Network check failed, assuming offline. ${'$'}{e.message}")
            false
        }
        if (!isOnline) {
            NetworkNotifier.notifyOffline()
            throw Exception("No internet connection for TTS request.")
        }

        // 1. Construct the JSON payload
        val jsonPayload = JSONObject().apply {
            put("input", JSONObject().put("text", text))
            put("voice", JSONObject().apply {
                put("languageCode", "en-US")
                put("name", voice.voiceName)
            })
            put("audioConfig", JSONObject().apply {
                put("audioEncoding", "LINEAR16")
                put("sampleRateHertz", 24000)
            })
        }.toString()

        // 2. Build the network request
        val request = Request.Builder()
            .url(API_URL)
            .header("X-Goog-Api-Key", apiKey)
            .header("Content-Type", "application/json; charset=utf-8")
            .header("X-Android-Package", BuildConfig.APPLICATION_ID)
//            .header("X-Android-Cert", BuildConfig.SHA1_FINGERPRINT)
            .post(jsonPayload.toRequestBody("application/json".toMediaType()))
            .build()

        // 3. Execute the request and handle the response
        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                val errorBody = response.body?.string()
                Log.e("GoogleTts", "API Error: ${response.code} - $errorBody")
                throw Exception("Google TTS API request failed with code ${response.code}")
            }

            val responseBody = response.body?.string()
            if (responseBody.isNullOrEmpty()) {
                throw Exception("Received an empty response from Google TTS API.")
            }

            // 4. Decode the Base64 audio content into a ByteArray
            val jsonResponse = JSONObject(responseBody)
            val audioContent = jsonResponse.getString("audioContent")
            return@withContext Base64.decode(audioContent, Base64.DEFAULT)
        }
    }

    /**
     * Get all available voice options
     * @return List of all available TTS voices
     */
    fun getAvailableVoices(): List<TTSVoice> = TTSVoice.values().toList()
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/MemoryService.kt
================================================
package com.blurr.voice.api

import android.util.Log
import com.blurr.voice.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import com.blurr.voice.MyApplication
import com.blurr.voice.utilities.NetworkConnectivityManager
import com.blurr.voice.utilities.NetworkNotifier

/**
 * A service to interact with the Mem0 API for persistent memory storage and retrieval.
 */
class MemoryService {

    private val client = OkHttpClient()
    // --- CORRECTED: Use the correct BuildConfig field name ---
    private val apiKey = BuildConfig.MEM0_API

    /**
     * Adds a new memory to Mem0 based on the user's instruction.
     */
    suspend fun addMemory(instruction: String, userId: String) {
        if (apiKey.isEmpty()) {
            Log.w("MemoryService", "Mem0 API key is not set. Skipping add memory.")
            return
        }
        // Network check
        try {
            val isOnline = true
            if (!isOnline) {
                Log.e("MemoryService", "No internet connection. Skipping addMemory call.")
                NetworkNotifier.notifyOffline()
                return
            }
        } catch (e: Exception) {
            Log.e("MemoryService", "Network check failed, assuming offline. ${'$'}{e.message}")
            return
        }
        withContext(Dispatchers.IO) {
            try {
                val message = JSONObject().put("role", "user").put("content", instruction)
                val messagesArray = JSONArray().put(message)
                val payload = JSONObject().apply {
                    put("messages", messagesArray)
                    put("user_id", userId)
                    put("version", "v2")
                }
                println("Payload being sent to Mem0: ${payload.toString(2)}") // Pretty print JSON

                val request = Request.Builder()
                    .url("https://api.mem0.ai/v1/memories/")
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Token $apiKey")
                    .post(payload.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                client.newCall(request).execute().use { response ->
                    // --- THIS IS THE FIX ---
                    // Read the response body into a variable ONCE.
                    val responseBodyString = response.body?.string()

                    if (response.isSuccessful) {
                        // Now, print the body you captured.
                        Log.d("MemoryService", "Successfully added memory. Response: $responseBodyString")
                    } else {
                        // Log the body on failure as well.
                        Log.e("MemoryService", "Failed to add memory. Code: ${response.code}, Body: $responseBodyString")
                    }
                }
            } catch (e: Exception) {
                Log.e("MemoryService", "Error adding memory", e)
            }
        }
    }

    /**
     * Searches for memories relevant to the current query for a specific user.
     */
    suspend fun searchMemory(query: String, userId: String): String {
        if (apiKey.isEmpty()) {
            Log.w("MemoryService", "Mem0 API key is not set. Skipping search.")
            return "No relevant memories found."
        }
        // Network check
        try {
            val isOnline = true
            if (!isOnline) {
                Log.e("MemoryService", "No internet connection. Skipping searchMemory call.")
                NetworkNotifier.notifyOffline()
                return "Could not retrieve memories due to no internet connection."
            }
        } catch (e: Exception) {
            Log.e("MemoryService", "Network check failed, assuming offline. ${'$'}{e.message}")
            return "Could not retrieve memories due to connectivity check error."
        }

        return withContext(Dispatchers.IO) {
            try {
                val filters = JSONObject().put("user_id", userId)
                val payload = JSONObject().apply {
                    put("query", query)
                    put("filters", filters)
                }

                val request = Request.Builder()
                    .url("https://api.mem0.ai/v2/memories/search/")
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Token $apiKey")
                    .post(payload.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                client.newCall(request).execute().use { response ->
                    val body = response.body?.string()
                    if (!response.isSuccessful || body == null) {
                        throw Exception("Mem0 search failed with HTTP ${response.code}")
                    }

                    val resultsArray = JSONArray(body)
                    if (resultsArray.length() == 0) {
                        return@withContext "No relevant memories found."
                    }

                    // Format the results into a clean string for the prompt
                    val memories = (0 until resultsArray.length()).joinToString("\n") { i ->
                        val memoryObj = resultsArray.getJSONObject(i)
                        // Use optString to avoid crashing if 'memory' key is missing
                        "- ${memoryObj.optString("memory", "Corrupted memory entry")}"
                    }
                    memories
                }
            } catch (e: Exception) {
                Log.e("MemoryService", "Error searching memory", e)
                "Could not retrieve memories due to an error."
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/api/PicovoiceKeyManager.kt
================================================
package com.blurr.voice.api

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import androidx.core.content.edit
import com.blurr.voice.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.util.concurrent.TimeUnit
import com.blurr.voice.utilities.NetworkConnectivityManager
import com.blurr.voice.utilities.UserIdManager
import com.blurr.voice.utilities.UserProfileManager
import okhttp3.internal.platform.PlatformRegistry.applicationContext
import java.util.UUID

/**
 * Manages the Picovoice access key by fetching it from the API and caching it locally.
 * Only fetches the key once and keeps it permanently.
 */
class PicovoiceKeyManager(private val context: Context) {
    
    companion object {
        private const val TAG = "PicovoiceKeyManager"
        private const val PREFS_NAME = "PicovoicePrefs"
        private const val KEY_ACCESS_KEY = "access_key"
        // Inside companion object
        private const val KEY_USER_PROVIDED_KEY = "user_provided_access_key"
        private const val API_URL = BuildConfig.GCLOUD_GATEWAY_URL
        private const val API_KEY_HEADER = "x-api-key"
        private const val API_KEY_VALUE = BuildConfig.GCLOUD_GATEWAY_PICOVOICE_KEY
        private const val DEVICE_ID_HEADER = "x-device-id"
    }
    private val sharedPreferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build()
    
    /**
     * Gets the Picovoice access key. If not cached, fetches it from the API once.
     * @return The access key, or null if fetching failed
     */
    suspend fun getAccessKey(): String? = withContext(Dispatchers.IO) {
        try {
            val userKey = getUserProvidedKey()
            if (!userKey.isNullOrBlank()) {
                Log.d(TAG, "Using user-provided Picovoice access key")
                return@withContext userKey
            }
            // Check if we have a cached key
            val cachedKey = getCachedAccessKey()
            if (cachedKey != null) {
                Log.d(TAG, "Using cached Picovoice access key")
                return@withContext cachedKey
            }
            
            // Fetch new key from API (only once)
            Log.d(TAG, "Fetching new Picovoice access key from API")
            val newKey = fetchAccessKeyFromApi()
            if (newKey != null) {
                saveAccessKeyToCache(newKey)
                Log.d(TAG, "Successfully fetched and cached new Picovoice access key")
                return@withContext newKey
            } else {
                Log.e(TAG, "Failed to fetch access key from API")
                return@withContext null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting access key", e)
            return@withContext null
        }
    }

    /**
     * Fetches the access key from the API endpoint
     */
    private suspend fun fetchAccessKeyFromApi(): String? = withContext(Dispatchers.IO) {
        try {
            // Network check
            val isOnline = try {
                NetworkConnectivityManager(context).isNetworkAvailable()
            } catch (e: Exception) {
                false
            }
            if (!isOnline) {
                Log.e(TAG, "No internet connection. Skipping Picovoice key fetch.")
                com.blurr.voice.utilities.NetworkNotifier.notifyOffline()
                return@withContext null
            }

            var userEmail = UserProfileManager(context).getEmail()

            if(userEmail==null){
                userEmail = UserIdManager(context).getOrCreateUserId()
                Log.d(TAG,userEmail)
            }
            val request = Request.Builder()
                .url(API_URL)
                .header(API_KEY_HEADER, API_KEY_VALUE)
                .header(DEVICE_ID_HEADER, userEmail)
                .get()
                .build()

            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "API request failed with code: ${response.code}")
                    return@withContext null
                }
                
                val responseBody = response.body?.string()
                if (responseBody.isNullOrEmpty()) {
                    Log.e(TAG, "Empty response from API")
                    return@withContext null
                }
                
                // The response is the key directly (base64 encoded)
                val accessKey = responseBody.trim()
                if (accessKey.isNotEmpty()) {
                    Log.d(TAG, "Successfully fetched access key from API")
                    return@withContext accessKey
                } else {
                    Log.e(TAG, "Empty access key in response")
                    return@withContext null
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching access key from API", e)
            return@withContext null
        }
    }
    
    /**
     * Gets the cached access key from SharedPreferences
     */
    private fun getCachedAccessKey(): String? {
        return sharedPreferences.getString(KEY_ACCESS_KEY, null)
    }
    
    /**
     * Saves the access key to SharedPreferences permanently
     */
    private fun saveAccessKeyToCache(accessKey: String) {
        sharedPreferences.edit {
            putString(KEY_ACCESS_KEY, accessKey)
        }
    }
    
    /**
     * Clears the cached access key (useful for testing or forcing a refresh)
     */
    fun clearCache() {
        sharedPreferences.edit {
            remove(KEY_ACCESS_KEY)
        }
        Log.d(TAG, "Cleared cached Picovoice access key")
    }

    /**
     * Saves a key provided by the user to SharedPreferences.
     */
    fun saveUserProvidedKey(accessKey: String) {
        sharedPreferences.edit {
            putString(KEY_USER_PROVIDED_KEY, accessKey)
        }
    }

    /**
     * Gets the key provided by the user from SharedPreferences.
     */
    fun getUserProvidedKey(): String? {
        return sharedPreferences.getString(KEY_USER_PROVIDED_KEY, null)
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/api/PorcupineWakeWordDetector.kt
================================================
package com.blurr.voice.api

import ai.picovoice.porcupine.PorcupineManager
import ai.picovoice.porcupine.PorcupineManagerCallback
import ai.picovoice.porcupine.PorcupineManagerErrorCallback
import android.content.Context
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class PorcupineWakeWordDetector(
    private val context: Context,
    private val onWakeWordDetected: () -> Unit,
    private val onApiFailure: () -> Unit
) {
    private var porcupineManager: PorcupineManager? = null
    private var isListening = false
    private val keyManager = PicovoiceKeyManager(context)
    private var coroutineScope: CoroutineScope? = null

    companion object {
        private const val TAG = "PorcupineWakeWordDetector"
    }

    fun start() {
        if (isListening) {
            Log.d(TAG, "Already started.")
            return
        }

        // Create a new coroutine scope for this start operation
        coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)

        // Start the key fetching process asynchronously
        coroutineScope?.launch {
            try {
                val accessKey = keyManager.getAccessKey()
                if (accessKey != null) {
                    Log.d(TAG, "Successfully obtained Picovoice access key")
                    startPorcupineWithKey(accessKey)
                } else {
                    Log.e(TAG, "Failed to obtain Picovoice access key. Triggering API failure callback.")
                    onApiFailure()
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error getting access key: ${e.message}")
                onApiFailure()
            }
        }
    }

    private suspend fun startPorcupineWithKey(accessKey: String) = withContext(Dispatchers.Main) {
        try {
            // Create the wake word callback
            val wakeWordCallback = PorcupineManagerCallback { keywordIndex ->
                Log.d(TAG, "Wake word detected! Keyword index: $keywordIndex")
                onWakeWordDetected()
                // PorcupineManager should automatically continue listening after detection
            }

            // Create error callback for debugging
            val errorCallback = PorcupineManagerErrorCallback { error ->
                Log.e(TAG, "Porcupine error: ${error.message}")
                // If there's an error, trigger API failure callback
                if (isListening) {
                    Log.d(TAG, "Porcupine error occurred, triggering API failure callback")
                    onApiFailure()
                }
            }

            // Build and start PorcupineManager
            porcupineManager = PorcupineManager.Builder()
                .setAccessKey(accessKey)
                .setKeywordPaths(arrayOf("Panda_en_android_v3_0_0.ppn"))
                .setSensitivity(0.5f) // Set sensitivity to 0.5 for better detection
                .setErrorCallback(errorCallback)
                .build(context, wakeWordCallback)

            porcupineManager?.start()
            isListening = true
            Log.d(TAG, "Porcupine wake word detection started successfully.")
        } catch (e: Exception) {
            Log.e(TAG, "Error starting Porcupine: ${e.message}")
            // Trigger API failure callback if Porcupine fails
            Log.d(TAG, "Porcupine failed to start, triggering API failure callback")
            onApiFailure()
        }
    }

    fun stop() {
        if (!isListening) {
            Log.d(TAG, "Already stopped.")
            return
        }

        try {
            porcupineManager?.stop()
            porcupineManager?.delete()
            porcupineManager = null
            isListening = false
            Log.d(TAG, "Porcupine wake word detection stopped.")
            
            // Cancel the coroutine scope
            coroutineScope?.cancel()
            coroutineScope = null
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping wake word detection: ${e.message}")
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/api/TavilyApi.kt
================================================
package com.blurr.voice.api

import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import com.blurr.voice.MyApplication
import com.blurr.voice.utilities.NetworkConnectivityManager
import com.blurr.voice.utilities.NetworkNotifier

class TavilyApi(private val apiKey: String) {

    private val client = OkHttpClient()

    // The search function now accepts the full JSON payload
    suspend fun search(searchParameters: JSONObject): String {
        return withContext(Dispatchers.IO) {
            // Network check
            try {
                val isOnline = true
                if (!isOnline) {
                    Log.e("TavilyApi", "No internet connection. Skipping search call.")
                    NetworkNotifier.notifyOffline()
                    return@withContext "{\"error\":\"offline\"}"
                }
            } catch (e: Exception) {
                Log.e("TavilyApi", "Network check failed, assuming offline. ${'$'}{e.message}")
                return@withContext "{\"error\":\"offline\"}"
            }
            val request = Request.Builder()
                .url("https://api.tavily.com/search")
                .header("Content-Type", "application/json")
                .header("Authorization", "Bearer $apiKey")
                .post(searchParameters.toString().toRequestBody("application/json".toMediaType()))
                .build()

            try {
                client.newCall(request).execute().use { response ->
                    val body = response.body?.string()
                    if (!response.isSuccessful || body == null) {
                        val errorBody = body ?: "No response body"
                        Log.e("TavilyApi", "API Error ${response.code}: $errorBody")
                        throw Exception("Tavily API call failed with HTTP ${response.code}")
                    }
                    body
                }
            } catch (e: Exception) {
                Log.e("TavilyApi", "Search failed", e)
                "{\"error\": \"Search failed: ${e.message}\"}"
            }
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/api/WakeWordDetector.kt
================================================
package com.blurr.voice.api

import android.content.Context
import android.media.AudioManager
import android.os.Handler
import android.os.Looper
import android.util.Log
import com.blurr.voice.utilities.STTManager
import java.util.Locale

class WakeWordDetector(
    private val context: Context,
    private val onWakeWordDetected: () -> Unit
) {
    private var sttManager: STTManager? = null
    private val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
    private val wakeWord = "Panda"
    private var isListening = false
    private val handler = Handler(Looper.getMainLooper())
    private val restartDelayMs = 250L

    fun start() {
        if (isListening) {
            Log.d("WakeWordDetector", "Already started.")
            return
        }
        isListening = true
        Log.d("WakeWordDetector", "Starting to listen for wake word.")
        startContinuousListening()
    }

    fun stop() {
        if (!isListening) {
            Log.d("WakeWordDetector", "Already stopped.")
            return
        }
        isListening = false
        handler.removeCallbacksAndMessages(null)
        sttManager?.stopListening()
        sttManager?.shutdown()

        // Ensure the sound is unmuted when the service is stopped
        audioManager.adjustStreamVolume(AudioManager.STREAM_NOTIFICATION, AudioManager.ADJUST_UNMUTE, 0)
        Log.d("WakeWordDetector", "Stopped listening for wake word.")
    }

    private fun startContinuousListening() {
        if (!isListening) return

        // Initialize STT manager if needed
        if (sttManager == null) {
            sttManager = STTManager(context)
        }

        // Mute the notification stream to prevent the startup chime
        audioManager.adjustStreamVolume(AudioManager.STREAM_NOTIFICATION, AudioManager.ADJUST_MUTE, 0)

        sttManager?.startListening(
            onResult = { recognizedText ->
                Log.d("WakeWordDetector", "Recognized: '$recognizedText'")
                if (recognizedText.lowercase(Locale.ROOT).contains(wakeWord.lowercase(Locale.ROOT))) {
                    onWakeWordDetected()
                }
                restartListening()
            },
            onError = { errorMessage ->
                Log.e("WakeWordDetector", "STT Error: $errorMessage")
                restartListening()
            },
            onListeningStateChange = { },
            onPartialResult = { }

        )

        // Unmute the stream shortly after starting to ensure other notifications can be heard
        handler.postDelayed({
            audioManager.adjustStreamVolume(AudioManager.STREAM_NOTIFICATION, AudioManager.ADJUST_UNMUTE, 0)
        }, 500) // 500ms is enough time to suppress the chime
    }

    private fun restartListening() {
        if (!isListening) return
        handler.postDelayed({
            sttManager?.stopListening()
            startContinuousListening()
        }, restartDelayMs)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/crawler/AppMap.kt
================================================
package com.blurr.voice.crawler

/**
 * Data classes that represent the final JSON structure of our AppMap.
 * Using these makes the code type-safe and easy to serialize into JSON.
 */
data class AppMap(
    val app_metadata: AppMetadata,
    val screens: List<Screen>
)

/**
 * A simplified data class representing a clickable element sent to the LLM for analysis.
 */
private data class ElementForLlm(
    val id: Int,
    val resource_id: String?,
    val text: String?,
    val content_description: String?,
    val class_name: String?
)

data class AppMetadata(
    val package_name: String,
    val version_name: String = "1.0.0", // Placeholder, should be retrieved from PackageManager
    val version_code: Int = 1,       // Placeholder
    val screen_title: String         // The user-facing title of the screen
)

data class Screen(
    val screen_id: String, // e.g., a hash of the element structure or activity name
    val ui_elements: List<UIElement>
)

data class UIElement(
    val resource_id: String?,
    var text: String?,
    var content_description: String?,
    val class_name: String?,
    val bounds: String?,
    val is_clickable: Boolean,
    val is_long_clickable: Boolean,
    val is_password: Boolean,
    @Transient var isPruned: Boolean = false // Helper field for pruning, excluded from JSON
)


================================================
FILE: app/src/main/java/com/blurr/voice/crawler/DrawDebugLabeller.kt
================================================
package com.blurr.voice.crawler

import android.content.Context
import android.graphics.Color
import android.graphics.PixelFormat
import android.graphics.Rect
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.view.Gravity
import android.view.View
import android.view.WindowManager
import android.widget.TextView
import java.util.regex.Pattern


/**
 * A helper object to parse the bounds string from the XML into a Rect object.
 */
object BoundsParser {
    // Regex to capture the four numbers from a string like "[x1,y1][x2,y2]"
    private val PATTERN = Pattern.compile("\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]")

    fun parse(boundsString: String?): Rect? {
        if (boundsString == null) return null
        val matcher = PATTERN.matcher(boundsString)
        return if (matcher.matches()) {
            val left = matcher.group(1)?.toIntOrNull() ?: 0
            val top = matcher.group(2)?.toIntOrNull() ?: 0
            val right = matcher.group(3)?.toIntOrNull() ?: 0
            val bottom = matcher.group(4)?.toIntOrNull() ?: 0
            Rect(left, top, right, bottom)
        } else {
            null
        }
    }
}

/**
 * A utility class for drawing temporary, labeled bounding boxes over other apps.
 * This is extremely useful for debugging agent perception.
 */
class DebugOverlayDrawer(private val context: Context) {

    private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    private val mainHandler = Handler(Looper.getMainLooper())
    private var statusBarHeight = -1

    /**
     * Draws labeled bounding boxes for each UIElement on the screen.
     * The boxes and labels will automatically disappear after a short duration.
     *
     * @param elements The list of UIElements to visualize.
     * @param durationMs The time in milliseconds for the boxes to remain on screen.
     */
    fun drawLabeledBoxes(elements: List<UIElement>, durationMs: Long = 5000L) {
        // This check is crucial. The function will not work without the overlay permission.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(context)) {
            Log.w("DebugOverlayDrawer", "Cannot draw bounding boxes: 'Draw over other apps' permission not granted.")
            Log.w("DebugOverlayDrawer", "Please request permission using Settings.ACTION_MANAGE_OVERLAY_PERMISSION.")
            return
        }

        // Calculate status bar height once for accurate positioning.
        if (statusBarHeight < 0) {
            val resourceId = context.resources.getIdentifier("status_bar_height", "dimen", "android")
            statusBarHeight = if (resourceId > 0) context.resources.getDimensionPixelSize(resourceId) else 0
        }

        val viewsToRemove = mutableListOf<View>()

        // All UI operations must be done on the main thread.
        mainHandler.post {
            for (element in elements) {
                val bounds = BoundsParser.parse(element.bounds) ?: continue // Skip if bounds are invalid

                try {
                    // --- Create and add the Bounding Box View ---
                    val boxView = createBoxView(element)
                    val boxParams = createBoxLayoutParams(bounds)
                    windowManager.addView(boxView, boxParams)
                    viewsToRemove.add(boxView)

                    // --- Create and add the Label View ---
                    val labelView = createLabelView(element)
                    val labelParams = createLabelLayoutParams(bounds)
                    windowManager.addView(labelView, labelParams)
                    viewsToRemove.add(labelView)

                } catch (e: Exception) {
                    Log.e("DebugOverlayDrawer", "Failed to add debug view for element: ${element.text}", e)
                }
            }

            // Schedule the removal of all created views after the specified duration.
            mainHandler.postDelayed({
                viewsToRemove.forEach { view ->
                    // Check if the view is still attached to the window before trying to remove it.
                    if (view.isAttachedToWindow) {
                        windowManager.removeView(view)
                    }
                }
            }, durationMs)
        }
    }

    private fun createBoxView(element: UIElement): View {
        return View(context).apply {
            background = GradientDrawable().apply {
                shape = GradientDrawable.RECTANGLE
                // Green for clickable elements, Yellow for non-clickable but visible elements.
                val color = if (element.is_clickable) 0xFF00FF00.toInt() else 0xFFFFFF00.toInt()
                setStroke(6, color) // 6 pixel thick border
            }
        }
    }

    private fun createLabelView(element: UIElement): TextView {
        // Create a descriptive label, preferring text over content description.
        val description = when {
            !element.text.isNullOrBlank() -> element.text
            !element.content_description.isNullOrBlank() -> element.content_description
            else -> element.resource_id ?: "No ID"
        }

        return TextView(context).apply {
            text = description
            setBackgroundColor(Color.parseColor("#BB000000")) // Semi-transparent black
            setTextColor(Color.WHITE)
            textSize = 10f
            setPadding(6, 4, 6, 4)
        }
    }

    private fun createBoxLayoutParams(bounds: Rect): WindowManager.LayoutParams {
        val params = WindowManager.LayoutParams(
            bounds.width(),
            bounds.height(),
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            // These flags make the overlay non-interactive.
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
            PixelFormat.TRANSLUCENT
        )
        params.gravity = Gravity.TOP or Gravity.START
        params.x = bounds.left
        // Adjust for status bar height to align perfectly with screen elements.
        params.y = bounds.top - statusBarHeight
        return params
    }

    private fun createLabelLayoutParams(bounds: Rect): WindowManager.LayoutParams {
        val params = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
            PixelFormat.TRANSLUCENT
        )
        params.gravity = Gravity.TOP or Gravity.START
        params.x = bounds.left
        // Place the label just above the bounding box, ensuring it doesn't go off-screen.
        params.y = (bounds.top - 35).coerceAtLeast(0) - statusBarHeight
        return params
    }
}

/*
--- HOW TO USE THIS CODE ---

1.  **Add Permission to AndroidManifest.xml:**
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

2.  **Check and Request Permission in your Activity/Fragment:**
    You must ask the user to grant the overlay permission before calling the drawer.

    ```kotlin
    private const val OVERLAY_PERMISSION_REQUEST_CODE = 123

    private fun checkAndRequestOverlayPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(this)) {
            val intent = Intent(
                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                Uri.parse("package:$packageName")
            )
            startActivityForResult(intent, OVERLAY_PERMISSION_REQUEST_CODE)
        }
    }
    ```

3.  **How your Agent would use it:**
    After your `XmlToAppMapParser` generates the list of `UIElement` objects:

    ```kotlin
    // In your agent's logic...
    fun visualizeCurrentScreen(context: Context, elements: List<UIElement>) {
        // Create an instance of the drawer
        val overlayDrawer = DebugOverlayDrawer(context)

        // Call the function to draw the boxes. They will disappear automatically.
        overlayDrawer.drawLabeledBoxes(elements)
    }
    ```
*/



================================================
FILE: app/src/main/java/com/blurr/voice/crawler/SemanticParser.kt
================================================
package com.blurr.voice.crawler

import android.content.Context
import android.graphics.Rect
import com.google.gson.GsonBuilder
import org.xmlpull.v1.XmlPullParser
import org.xmlpull.v1.XmlPullParserFactory
import java.io.StringReader
import java.util.regex.Pattern
import kotlin.math.max
import kotlin.math.min

/**
 * Data class to store UI elements with their numeric IDs and coordinates
 */
data class UIElementWithId(
    val id: Int,
    val element: UIElement,
    val centerX: Int,
    val centerY: Int
)

/**
 * A sophisticated parser that simplifies the raw UI XML into a clean,
 * semantically meaningful list of UI elements. It merges descriptive child nodes
 * into their interactive parents and then prunes nested interactive elements.
 */
class SemanticParser(private  val applicationContext: Context) {

    // Internal data class to represent the XML tree structure.
    private data class XmlNode(
        val attributes: MutableMap<String, String> = mutableMapOf(),
        var parent: XmlNode? = null,
        val children: MutableList<XmlNode> = mutableListOf(),
        // --- Fields for merging logic ---
        var mergedText: MutableList<String> = mutableListOf(),
        var isSubsumed: Boolean = false
    ) {
        // Helper to get an attribute
        fun get(key: String): String? = attributes[key]
        fun getBool(key: String): Boolean = attributes[key]?.toBoolean() ?: false
    }

    /**
     * Parses the raw XML hierarchy and returns a simplified, semantically merged JSON string.
     *
     * @param xmlString The raw XML content from the accessibility service.
     * @param screenWidth The physical width of the device screen.
     * @param screenHeight The physical height of the device screen.
     * @return A JSON string representing a list of clean UIElements.
     */
    fun parse(xmlString: String, screenWidth: Int, screenHeight: Int): String {
        // Step 1: Build the complete tree from the XML.
        val rootNode = buildTreeFromXml(xmlString)

        // Step 2: Perform the semantic merge (upward text propagation).
        if (rootNode != null) {
            mergeDescriptiveChildren(rootNode)
        }

        // Step 3: Flatten the tree to a preliminary list of important elements.
        val preliminaryElements = mutableListOf<UIElement>()
        if (rootNode != null) {
            flattenAndFilter(rootNode, preliminaryElements, screenWidth, screenHeight)
        }

        visualizeCurrentScreen(applicationContext, preliminaryElements )

        // Step 5: Serialize the final list to a pretty JSON string.
        val gson = GsonBuilder().setPrettyPrinting().create()
        return gson.toJson(preliminaryElements)
    }

    fun parseToUIElement(xmlString: String, screenWidth: Int, screenHeight: Int):  MutableList<UIElement> {
        // Step 1: Build the complete tree from the XML.
        val rootNode = buildTreeFromXml(xmlString)

        // Step 2: Perform the semantic merge (upward text propagation).
        if (rootNode != null) {
            mergeDescriptiveChildren(rootNode)
        }

        // Step 3: Flatten the tree to a preliminary list of important elements.
        val preliminaryElements = mutableListOf<UIElement>()
        if (rootNode != null) {
            flattenAndFilter(rootNode, preliminaryElements, screenWidth, screenHeight)
        }
        return preliminaryElements

    }

    /**
     * Converts UI elements to markdown format with numeric IDs for easy reference.
     *
     * @param elements List of UI elements to convert
     * @return A markdown string with numbered elements
     */
    fun elementsToMarkdown(elements: List<UIElement>): String {
        if (elements.isEmpty()) {
            return "No interactive elements found on screen."
        }

        val markdown = StringBuilder()
        markdown.appendLine("# Screen Elements")
        markdown.appendLine()
        markdown.appendLine("The following elements are available for interaction:")
        markdown.appendLine()

        elements.forEachIndexed { index, element ->
            val elementId = index + 1
            markdown.appendLine("## $elementId. ${getElementDescription(element)}")
            
            // Add details about the element
            val details = mutableListOf<String>()
            
            if (!element.text.isNullOrBlank()) {
                details.add("**Text:** ${element.text}")
            }
            
            if (!element.content_description.isNullOrBlank()) {
                details.add("**Description:** ${element.content_description}")
            }
            
            if (!element.class_name.isNullOrBlank()) {
                details.add("**Type:** ${element.class_name}")
            }
            
            if (!element.resource_id.isNullOrBlank()) {
                details.add("**ID:** ${element.resource_id}")
            }
            
            if (element.is_clickable) {
                details.add("**Action:** Clickable")
            }
            
            if (element.is_long_clickable) {
                details.add("**Action:** Long-clickable")
            }
            
            if (element.is_password) {
                details.add("**Type:** Password field")
            }
            
            if (details.isNotEmpty()) {
                markdown.appendLine(details.joinToString(" | "))
            }
            
            markdown.appendLine()
        }

        return markdown.toString()
    }

    /**
     * Helper function to get a human-readable description of an element
     */
    private fun getElementDescription(element: UIElement): String {
        val text = element.text
        val contentDesc = element.content_description
        val resourceId = element.resource_id
        val className = element.class_name
        
        return when {
            !text.isNullOrBlank() -> text
            !contentDesc.isNullOrBlank() -> contentDesc
            !resourceId.isNullOrBlank() -> resourceId
            else -> className ?: "Unknown element"
        }
    }

    /**
     * Parses the raw XML hierarchy and returns both JSON and markdown formats.
     *
     * @param xmlString The raw XML content from the accessibility service.
     * @param screenWidth The physical width of the device screen.
     * @param screenHeight The physical height of the device screen.
     * @return A pair containing (JSON string, markdown string)
     */
    fun parseWithMarkdown(xmlString: String, screenWidth: Int, screenHeight: Int): Pair<String, String> {
        // Step 1: Build the complete tree from the XML.
        val rootNode = buildTreeFromXml(xmlString)

        // Step 2: Perform the semantic merge (upward text propagation).
        if (rootNode != null) {
            mergeDescriptiveChildren(rootNode)
        }

        // Step 3: Flatten the tree to a preliminary list of important elements.
        val preliminaryElements = mutableListOf<UIElement>()
        if (rootNode != null) {
            flattenAndFilter(rootNode, preliminaryElements, screenWidth, screenHeight)
        }

        visualizeCurrentScreen(applicationContext, preliminaryElements)

        // Step 4: Generate both JSON and markdown formats
        val gson = GsonBuilder().setPrettyPrinting().create()
        val jsonString = gson.toJson(preliminaryElements)
        val markdownString = elementsToMarkdown(preliminaryElements)
        
        return Pair(jsonString, markdownString)
    }

    /**
     * Parses the raw XML hierarchy and returns elements with IDs and coordinates.
     *
     * @param xmlString The raw XML content from the accessibility service.
     * @param screenWidth The physical width of the device screen.
     * @param screenHeight The physical height of the device screen.
     * @return A list of UIElementWithId containing elements with their IDs and coordinates
     */
    fun parseWithIds(xmlString: String, screenWidth: Int, screenHeight: Int): List<UIElementWithId> {
        // Step 1: Build the complete tree from the XML.
        val rootNode = buildTreeFromXml(xmlString)

        // Step 2: Perform the semantic merge (upward text propagation).
        if (rootNode != null) {
            mergeDescriptiveChildren(rootNode)
        }

        // Step 3: Flatten the tree to a preliminary list of important elements.
        val preliminaryElements = mutableListOf<UIElement>()
        if (rootNode != null) {
            flattenAndFilter(rootNode, preliminaryElements, screenWidth, screenHeight)
        }

        visualizeCurrentScreen(applicationContext, preliminaryElements)

        // Step 4: Convert to UIElementWithId with coordinates
        return preliminaryElements.mapIndexed { index, element ->
            val bounds = parseBounds(element.bounds)
            val centerX = bounds?.let { (it.left + it.right) / 2 } ?: 0
            val centerY = bounds?.let { (it.top + it.bottom) / 2 } ?: 0
            
            UIElementWithId(
                id = index + 1,
                element = element,
                centerX = centerX,
                centerY = centerY
            )
        }
    }

    /**
     * Gets the coordinates of an element by its numeric ID.
     *
     * @param elementId The numeric ID of the element (1-based)
     * @param elementsWithIds List of elements with IDs
     * @return Pair of (x, y) coordinates, or null if element not found
     */
    fun getElementCoordinates(elementId: Int, elementsWithIds: List<UIElementWithId>): Pair<Int, Int>? {
        val element = elementsWithIds.find { it.id == elementId }
        return element?.let { Pair(it.centerX, it.centerY) }
    }


    fun visualizeCurrentScreen(context: Context, elements: List<UIElement>) {
        // Create an instance of the drawer
        val overlayDrawer = DebugOverlayDrawer(context)

        // Call the function to draw the boxes. They will disappear automatically.
//        overlayDrawer.drawLabeledBoxes(elements)
    }
    /**
     * Traverses the XML and builds a tree of XmlNode objects, preserving the hierarchy.
     */
    private fun buildTreeFromXml(xmlString: String): XmlNode? {
        val factory = XmlPullParserFactory.newInstance()
        val parser = factory.newPullParser()
        parser.setInput(StringReader(xmlString))

        var root: XmlNode? = null
        var currentNode: XmlNode? = null
        val nodeStack = ArrayDeque<XmlNode>()

        var eventType = parser.eventType
        while (eventType != XmlPullParser.END_DOCUMENT) {
            when (eventType) {
                XmlPullParser.START_TAG -> {
                    if (parser.name == "node") {
                        val newNode = XmlNode()
                        for (i in 0 until parser.attributeCount) {
                            newNode.attributes[parser.getAttributeName(i)] = parser.getAttributeValue(i)
                        }

                        if (root == null) {
                            root = newNode
                            currentNode = newNode
                        } else {
                            currentNode?.children?.add(newNode)
                            newNode.parent = currentNode
                        }
                        nodeStack.addLast(newNode)
                        currentNode = newNode
                    }
                }
                XmlPullParser.END_TAG -> {
                    if (parser.name == "node") {
                        nodeStack.removeLastOrNull()
                        currentNode = nodeStack.lastOrNull()
                    }
                }
            }
            eventType = parser.next()
        }
        return root
    }

    /**
     * Performs a depth-first traversal. When it finds a descriptive but non-clickable node,
     * it walks up the tree to find a clickable ancestor and "donates" its text to it.
     */
    private fun mergeDescriptiveChildren(node: XmlNode) {
        // First, recurse to the deepest children.
        for (child in node.children) {
            mergeDescriptiveChildren(child)
        }

        // Now, process the current node.
        val text = node.get("text")
        val contentDesc = node.get("content-desc")
        val hasDescriptiveText = !text.isNullOrBlank() || !contentDesc.isNullOrBlank()

        if (hasDescriptiveText && !node.getBool("clickable")) {
            // This node is descriptive but not clickable. Find an interactive ancestor.
            var ancestor = node.parent
            while (ancestor != null) {
                if (ancestor.getBool("clickable")) {
                    // Found a clickable ancestor. Donate text and mark this node for pruning.
                    val description = if (!text.isNullOrBlank()) text else contentDesc!!
                    ancestor.mergedText.add(description)
                    node.isSubsumed = true
                    break // Stop the upward walk
                }
                ancestor = ancestor.parent
            }
        }
    }

    /**
     * Traverses the merged tree and creates the final, flat list of UIElement objects,
     * filtering out subsumed and unimportant nodes.
     */
    private fun flattenAndFilter(node: XmlNode, finalElements: MutableList<UIElement>, screenWidth: Int, screenHeight: Int) {
        // A node is considered important if it's clickable OR has text that wasn't merged away.
        val isImportant = node.getBool("clickable") ||
                (!node.get("text").isNullOrBlank() && !node.isSubsumed) ||
                (!node.get("content-desc").isNullOrBlank() && !node.isSubsumed)

        if (isImportant && !node.isSubsumed) {
            // Add a check to ensure the element is within the visible screen bounds.
            val bounds = parseBounds(node.get("bounds"))
            if (bounds != null &&
//                [2160,690][1080,878]
               bounds.left >= 0 && bounds.right <= screenWidth && // Horizontal check
                bounds.top >= 0 && bounds.bottom <= screenHeight  && // Vertical check
                bounds.left != bounds.right && // none zero widht
                bounds.top != bounds.bottom  // none zero hieght
            ) {
                // Combine original text with any text merged from children.
                val combinedText = mutableListOf<String>()
                node.get("text")?.takeIf { it.isNotBlank() }?.let { combinedText.add(it) }
                combinedText.addAll(node.mergedText)

                finalElements.add(
                    UIElement(
                        resource_id = node.get("resource-id"),
                        text = combinedText.joinToString(" | "), // Join merged texts
                        content_description = node.get("content-desc"),
                        class_name = node.get("class"),
                        bounds = node.get("bounds"),
                        is_clickable = node.getBool("clickable"),
                        is_long_clickable = node.getBool("long-clickable"),
                        is_password = node.getBool("password")
                    )
                )
            }
        }

        // Continue traversal.
        for (child in node.children) {
            flattenAndFilter(child, finalElements, screenWidth, screenHeight)
        }
    }

    /**
     * Helper to parse a bounds string "[x1,y1][x2,y2]" into an Android Rect object.
     * Now includes validation to ensure the rectangle is well-formed.
     */
    private fun parseBounds(boundsString: String?): Rect? {
        if (boundsString == null) return null
        val pattern = Pattern.compile("\\[(-?\\d+),(-?\\d+)\\]\\[(-?\\d+),(-?\\d+)\\]")
        val matcher = pattern.matcher(boundsString)
        return if (matcher.matches()) {
            try {
                val left = matcher.group(1).toInt()
                val top = matcher.group(2).toInt()
                val right = matcher.group(3).toInt()
                val bottom = matcher.group(4).toInt()

                // NEW: Fix reversed coordinates by taking the min and max of the values.
                val fixedLeft = min(left, right)
                val fixedTop = min(top, bottom)
                val fixedRight = max(left, right)
                val fixedBottom = max(top, bottom)

                Rect(fixedLeft, fixedTop, fixedRight, fixedBottom)
            } catch (e: NumberFormatException) {
                // Handle cases where parsing to Int fails
                null
            }
        } else {
            null
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/data/AppDatabase.kt
================================================
package com.blurr.voice.data

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase

/**
 * Room database for storing memories
 */
@Database(entities = [Memory::class], version = 2, exportSchema = false)
abstract class AppDatabase : RoomDatabase() {
    
    abstract fun memoryDao(): MemoryDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "blurr_memory_database"
                )
                .fallbackToDestructiveMigration() // This will recreate the database if schema changes
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/data/Memory.kt
================================================
package com.blurr.voice.data

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Memory entity for storing user information with embeddings
 */
@Entity(tableName = "memories")
data class Memory(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val originalText: String,
    val embedding: String, // Stored as JSON string of numbers
    val timestamp: Long = System.currentTimeMillis()
) 


================================================
FILE: app/src/main/java/com/blurr/voice/data/MemoryDao.kt
================================================
package com.blurr.voice.data

import androidx.room.*
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object for Memory entity
 */
@Dao
interface MemoryDao {
    
    @Insert
    suspend fun insertMemory(memory: Memory): Long
    
    @Query("SELECT * FROM memories ORDER BY timestamp DESC")
    fun getAllMemories(): Flow<List<Memory>>
    
    @Query("SELECT * FROM memories ORDER BY timestamp DESC")
    suspend fun getAllMemoriesList(): List<Memory>
    
    @Query("SELECT * FROM memories WHERE id = :id")
    suspend fun getMemoryById(id: Long): Memory?
    
    @Delete
    suspend fun deleteMemory(memory: Memory)
    
    @Query("DELETE FROM memories WHERE id = :id")
    suspend fun deleteMemoryById(id: Long)
    
    @Query("DELETE FROM memories")
    suspend fun deleteAllMemories()
    
    @Query("SELECT COUNT(*) FROM memories")
    suspend fun getMemoryCount(): Int
} 


================================================
FILE: app/src/main/java/com/blurr/voice/data/MemoryExtractor.kt
================================================
package com.blurr.voice.data

import android.util.Log
//import com.blurr.voice.api.GeminiApi
import com.google.ai.client.generativeai.type.TextPart
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Extracts and stores memories from conversations using LLM-based memory extraction
 */
object MemoryExtractor {
    
    private val memoryExtractionPrompt = """
        You are a memory extraction agent. Analyze the following conversation and extract key, lasting facts about the user which are supposed to be known by perfect friend to understand the user better.
        
        Focus on:
        - Personal details (family, relationships, preferences, life events)
        - Significant experiences or traumas or hobbies
        - Important dates, locations, or circumstances
        - Long-term preferences or goals or habits etc
        Ignore:
        - Fleeting emotions or temporary states
        - Generic statements or hypothetical scenarios
        - Technical details or app-specific information
        
        IMPORTANT: Do NOT extract memories that are semantically equivalent to the following already known memories:
        {used_memories}
        
        Format each memory as a clear, concise sentence that captures the essential fact.
        If no significant memories are found, return "NO_MEMORIES".
        
        Conversation:
        {conversation}
        
        Extracted Memories (one per line):
    """.trimIndent()
    
    /**
     * Extracts memories from a conversation and stores them asynchronously
     * This is a fire-and-forget operation that doesn't block the conversation flow
     * 
     * @param conversationHistory The conversation to extract memories from
     * @param memoryManager The memory manager instance
     * @param scope The coroutine scope for async operations
     * @param usedMemories Set of memories already used in this conversation to avoid duplicates
     */
//    suspend fun extractAndStoreMemories(
//        conversationHistory: List<Pair<String, List<Any>>>,
//        memoryManager: MemoryManager,
//        usedMemories: Set<String> = emptySet()
//    ) {
//        withContext(Dispatchers.IO) {
//            try {
//                Log.d("MemoryExtractor", "Starting memory extraction from conversation")
//                Log.d("MemoryExtractor", "Used memories count: ${usedMemories.size}")
//
//                // Convert conversation to text format for analysis
//                val conversationText = formatConversationForExtraction(conversationHistory)
//
//                // Format used memories for the prompt
//                val usedMemoriesText = if (usedMemories.isNotEmpty()) {
//                    usedMemories.joinToString("\n") { "- $it" }
//                } else {
//                    "None"
//                }
//
//                // Create the extraction prompt with used memories
//                val extractionPrompt = memoryExtractionPrompt
//                    .replace("{conversation}", conversationText)
//                    .replace("{used_memories}", usedMemoriesText)
//
//                // Call LLM for memory extraction
//                val extractionChat = listOf(
//                    "user" to listOf(TextPart(extractionPrompt))
//                )
//
//                val extractionResponse = GeminiApi.generateContent(extractionChat)
//
//                if (extractionResponse != null) {
//                    Log.d("MemoryExtractor", "Memory extraction response: ${extractionResponse.take(200)}...")
//
//                    // Parse the extracted memories
//                    val memories = parseExtractedMemories(extractionResponse)
//
//                    if (memories.isNotEmpty()) {
//                        Log.d("MemoryExtractor", "Extracted ${memories.size} memories")
//
//                        // Store each memory asynchronously (no need for string filtering since LLM handles it)
//                        memories.forEach { memory ->
//                            try {
//                                val success = memoryManager.addMemory(memory)
//                                if (success) {
//                                    Log.d("MemoryExtractor", "Successfully stored memory: $memory")
//                                } else {
//                                    Log.e("MemoryExtractor", "Failed to store memory: $memory")
//                                }
//                            } catch (e: Exception) {
//                                Log.e("MemoryExtractor", "Error storing memory: $memory", e)
//                            }
//                        }
//                    } else {
//                        Log.d("MemoryExtractor", "No significant memories found in conversation")
//                    }
//                } else {
//                    Log.e("MemoryExtractor", "Failed to get memory extraction response")
//                }
//
//            } catch (e: Exception) {
//                Log.e("MemoryExtractor", "Error during memory extraction", e)
//            }
//        }
//    }
//
    /**
     * Formats conversation history for memory extraction analysis
     */
    private fun formatConversationForExtraction(conversationHistory: List<Pair<String, List<Any>>>): String {
        return conversationHistory.joinToString("\n") { (role, parts) ->
            val textParts = parts.filterIsInstance<TextPart>()
            val text = textParts.joinToString(" ") { it.text }
            "$role: $text"
        }
    }
    
    /**
     * Parses the LLM response to extract individual memories
     */
    private fun parseExtractedMemories(response: String): List<String> {
        return try {
            response.lines()
                .filter { it.isNotBlank() }
                .filter { !it.equals("NO_MEMORIES", ignoreCase = true) }
                .filter { !it.startsWith("Extracted Memories") }
                .filter { !it.startsWith("Memories:") }
                .map { it.trim() }
                .filter { it.isNotEmpty() }
        } catch (e: Exception) {
            Log.e("MemoryExtractor", "Error parsing extracted memories", e)
            emptyList()
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/data/MemoryManager.kt
================================================
package com.blurr.voice.data

import android.content.Context
import android.util.Log
import com.blurr.voice.api.EmbeddingService
import com.blurr.voice.MyApplication
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONArray

/**
 * Manager class for handling memory operations with embeddings
 */
class MemoryManager(private val context: Context) {
    
    private val database = AppDatabase.getDatabase(context)
    private val memoryDao = database.memoryDao()
    private val ioScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    /**
     * Add a new memory with embedding, checking for duplicates first
     */
    suspend fun addMemory(originalText: String, checkDuplicates: Boolean = true): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("MemoryManager", "Adding memory: ${originalText.take(100)}...")
                
                if (checkDuplicates) {
                    // Check for similar existing memories first
                    val similarMemories = findSimilarMemories(originalText, similarityThreshold = 0.85f)
                    if (similarMemories.isNotEmpty()) {
                        Log.d("MemoryManager", "Found ${similarMemories.size} similar memories, skipping duplicate")
                        return@withContext true // Return true since we're avoiding a duplicate
                    }
                }
                
                // Generate embedding for the text
                val embedding = EmbeddingService.generateEmbedding(
                    text = originalText,
                    taskType = "RETRIEVAL_DOCUMENT"
                )
                
                if (embedding == null) {
                    Log.e("MemoryManager", "Failed to generate embedding for text")
                    return@withContext false
                }
                
                // Convert embedding to JSON string for storage
                val embeddingJson = JSONArray(embedding).toString()
                
                // Create memory entity
                val memory = Memory(
                    originalText = originalText,
                    embedding = embeddingJson
                )
                
                // Save to database
                val id = memoryDao.insertMemory(memory)
                Log.d("MemoryManager", "Successfully added memory with ID: $id")
                return@withContext true
                
            } catch (e: Exception) {
                Log.e("MemoryManager", "Error adding memory $e", e)
                return@withContext false
            }
        }
    }

    /**
     * Fire-and-forget version of addMemory that is not tied to an Activity scope.
     * Uses an internal SupervisorJob so it won't be cancelled when a caller finishes.
     */
    fun addMemoryFireAndForget(originalText: String, checkDuplicates: Boolean = true) {
        ioScope.launch {
            try {
                val result = addMemory(originalText, checkDuplicates)
                Log.d("MemoryManager", "Fire-and-forget addMemory result=$result")
            } catch (e: Exception) {
                Log.e("MemoryManager", "Fire-and-forget addMemory error", e)
            }
        }
    }
    
    /**
     * Search for relevant memories based on a query
     */
    suspend fun searchMemories(query: String, topK: Int = 3): List<String> {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("MemoryManager", "Searching memories for query: ${query.take(100)}...")
                
                // Generate embedding for the query
                val queryEmbedding = EmbeddingService.generateEmbedding(
                    text = query,
                    taskType = "RETRIEVAL_QUERY"
                )
                
                if (queryEmbedding == null) {
                    Log.e("MemoryManager", "Failed to generate embedding for query")
                    return@withContext emptyList()
                }
                
                // Get all memories from database
                val allMemories = memoryDao.getAllMemoriesList()
                
                if (allMemories.isEmpty()) {
                    Log.d("MemoryManager", "No memories found in database")
                    return@withContext emptyList()
                }
                
                // Calculate similarities and find top matches
                val similarities = allMemories.map { memory ->
                    val memoryEmbedding = parseEmbeddingFromJson(memory.embedding)
                    val similarity = calculateCosineSimilarity(queryEmbedding, memoryEmbedding)
                    Pair(memory.originalText, similarity)
                }.sortedByDescending { it.second }
                
                // Return top K memories
                val topMemories = similarities.take(topK).map { it.first }
                Log.d("MemoryManager", "Found ${topMemories.size} relevant memories")
                return@withContext topMemories
                
            } catch (e: Exception) {
                Log.e("MemoryManager", "Error searching memories", e)
                return@withContext emptyList()
            }
        }
    }
    
    /**
     * Get relevant memories for a task and format them for prompt augmentation
     */
    suspend fun getRelevantMemories(taskDescription: String): String {
        val relevantMemories = searchMemories(taskDescription, topK = 3)
        
        return if (relevantMemories.isNotEmpty()) {
            buildString {
                appendLine("--- Relevant Information ---")
                relevantMemories.forEach { memory ->
                    appendLine("- $memory")
                }
                appendLine()
                appendLine("--- My Task ---")
                appendLine(taskDescription)
            }
        } else {
            // If no relevant memories, just return the original task
            taskDescription
        }
    }
    
    /**
     * Get memory count
     */
    suspend fun getMemoryCount(): Int {
        return withContext(Dispatchers.IO) {
            memoryDao.getMemoryCount()
        }
    }
    
    /**
     * Get all memories as a list
     */
    suspend fun getAllMemoriesList(): List<Memory> {
        return withContext(Dispatchers.IO) {
            memoryDao.getAllMemoriesList()
        }
    }
    
    /**
     * Delete all memories
     */
    suspend fun clearAllMemories() {
        withContext(Dispatchers.IO) {
            memoryDao.deleteAllMemories()
            Log.d("MemoryManager", "All memories cleared")
        }
    }
    
    /**
     * Delete a specific memory by ID
     */
    suspend fun deleteMemoryById(id: Long): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                memoryDao.deleteMemoryById(id)
                Log.d("MemoryManager", "Successfully deleted memory with ID: $id")
                true
            } catch (e: Exception) {
                Log.e("MemoryManager", "Error deleting memory with ID: $id", e)
                false
            }
        }
    }
    
    /**
     * Find memories similar to the given text
     */
    suspend fun findSimilarMemories(text: String, similarityThreshold: Float = 0.8f): List<String> {
        return withContext(Dispatchers.IO) {
            try {
                // Generate embedding for the query text
                val queryEmbedding = EmbeddingService.generateEmbedding(
                    text = text,
                    taskType = "RETRIEVAL_QUERY"
                )
                
                if (queryEmbedding == null) {
                    Log.e("MemoryManager", "Failed to generate embedding for similarity check")
                    return@withContext emptyList()
                }
                
                // Get all memories from database
                val allMemories = memoryDao.getAllMemoriesList()
                
                if (allMemories.isEmpty()) {
                    return@withContext emptyList()
                }
                
                // Calculate similarities and find similar memories
                val similarMemories = allMemories.mapNotNull { memory ->
                    val memoryEmbedding = parseEmbeddingFromJson(memory.embedding)
                    val similarity = calculateCosineSimilarity(queryEmbedding, memoryEmbedding)
                    
                    if (similarity >= similarityThreshold) {
                        Log.d("MemoryManager", "Found similar memory (similarity: $similarity): ${memory.originalText.take(50)}...")
                        memory.originalText
                    } else {
                        null
                    }
                }
                
                Log.d("MemoryManager", "Found ${similarMemories.size} similar memories with threshold $similarityThreshold")
                return@withContext similarMemories
                
            } catch (e: Exception) {
                Log.e("MemoryManager", "Error finding similar memories", e)
                return@withContext emptyList()
            }
        }
    }
    
    /**
     * Parse embedding from JSON string
     */
    private fun parseEmbeddingFromJson(embeddingJson: String): List<Float> {
        return try {
            val jsonArray = JSONArray(embeddingJson)
            (0 until jsonArray.length()).map { i ->
                jsonArray.getDouble(i).toFloat()
            }
        } catch (e: Exception) {
            Log.e("MemoryManager", "Error parsing embedding JSON", e)
            emptyList()
        }
    }
    
    /**
     * Calculate cosine similarity between two vectors
     */
    private fun calculateCosineSimilarity(vector1: List<Float>, vector2: List<Float>): Float {
        if (vector1.size != vector2.size) {
            Log.w("MemoryManager", "Vector dimensions don't match: ${vector1.size} vs ${vector2.size}")
            return 0f
        }
        
        var dotProduct = 0f
        var norm1 = 0f
        var norm2 = 0f
        
        for (i in vector1.indices) {
            dotProduct += vector1[i] * vector2[i]
            norm1 += vector1[i] * vector1[i]
            norm2 += vector2[i] * vector2[i]
        }
        
        val denominator = kotlin.math.sqrt(norm1) * kotlin.math.sqrt(norm2)
        return if (denominator > 0) dotProduct / denominator else 0f
    }
    
    companion object {
        private var instance: MemoryManager? = null
        
        fun getInstance(context: Context = MyApplication.appContext): MemoryManager {
            return instance ?: synchronized(this) {
                instance ?: MemoryManager(context).also { instance = it }
            }
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/data/TaskHistoryItem.kt
================================================
package com.blurr.voice.data

import com.google.firebase.Timestamp

data class TaskHistoryItem(
    val task: String,
    val status: String,
    val startedAt: Timestamp?,
    val completedAt: Timestamp?,
    val success: Boolean?,
    val errorMessage: String?
) {
    fun getStatusEmoji(): String {
        return when (status.lowercase()) {
            "started" -> "🔄"
            "completed" -> if (success == true) "✅" else "❌"
            "failed" -> "❌"
            else -> "⏳"
        }
    }
    
    fun getFormattedStartTime(): String {
        return startedAt?.toDate()?.let { date ->
            val formatter = java.text.SimpleDateFormat("MMM dd, yyyy 'at' h:mm a", java.util.Locale.getDefault())
            formatter.format(date)
        } ?: "Unknown"
    }
    
    fun getFormattedCompletionTime(): String {
        return completedAt?.toDate()?.let { date: java.util.Date ->
            val formatter = java.text.SimpleDateFormat("MMM dd, yyyy 'at' h:mm a", java.util.Locale.getDefault())
            formatter.format(date)
        } ?: "Not completed"
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/intents/AppIntent.kt
================================================
package com.blurr.voice.intents

import android.content.Context
import android.content.Intent

/**
 * Contract for pluggable Android Intents the agent can invoke.
 * Implementations must have a public no-arg constructor to allow reflective discovery.
 */
interface AppIntent {
    /**
     * Unique, human-readable name used by the LLM to refer to this intent.
     * Example: "Dial".
     */
    val name: String

    /** A short description to show in prompts. */
    fun description(): String

    /**
     * Returns the parameters this intent accepts in a stable order, for prompting.
     */
    fun parametersSpec(): List<ParameterSpec>

    /**
     * Builds the actual Android Intent to launch, based on provided params.
     * Should return null if required parameters are missing/invalid.
     */
    fun buildIntent(context: Context, params: Map<String, Any?>): Intent?
}

/** Parameter specification for prompting and validation */
data class ParameterSpec(
    val name: String,
    val type: String,
    val required: Boolean,
    val description: String
)




================================================
FILE: app/src/main/java/com/blurr/voice/intents/IntentRegistry.kt
================================================
package com.blurr.voice.intents

import android.content.Context
import android.util.Log
import com.blurr.voice.intents.impl.DialIntent
import com.blurr.voice.intents.impl.EmailComposeIntent
import com.blurr.voice.intents.impl.ShareTextIntent
import com.blurr.voice.intents.impl.ViewUrlIntent

/**
 * Discovers and manages AppIntent implementations.
 * Convention: Put intent implementations under package com.blurr.voice.intents.impl
 */
object IntentRegistry {
    private const val TAG = "IntentRegistry"

    private val discovered: MutableMap<String, AppIntent> = linkedMapOf()
    @Volatile private var initialized = false

    @Synchronized
    @Suppress("UNUSED_PARAMETER")
    fun init(context: Context) {
        register(DialIntent())
        register(ViewUrlIntent())
        register(ShareTextIntent())
        register(EmailComposeIntent())
        initialized = true
    }
    fun register(intent: AppIntent) {
        val key = intent.name.trim()
        if (discovered.containsKey(key)) {
            Log.w(TAG, "Duplicate intent registration for name: ${intent.name}; overriding")
        }
        discovered[key] = intent
    }

    fun listIntents(context: Context): List<AppIntent> {
        if (!initialized) init(context)
        return discovered.values.toList()
    }

    fun findByName(context: Context, name: String): AppIntent? {
        if (!initialized) init(context)
        // exact match first, then case-insensitive
        discovered[name]?.let { return it }
        return discovered.entries.firstOrNull { it.key.equals(name, ignoreCase = true) }?.value
    }
}




================================================
FILE: app/src/main/java/com/blurr/voice/intents/impl/DialIntent.kt
================================================
package com.blurr.voice.intents.impl

import android.content.Context
import android.content.Intent
import android.net.Uri
import com.blurr.voice.intents.AppIntent
import com.blurr.voice.intents.ParameterSpec
import androidx.core.net.toUri

/**
 * Opens the default dialer app with the given number filled.
 * Does NOT place the call automatically (uses ACTION_DIAL, no permission required).
 */
class DialIntent : AppIntent {
    override val name: String = "Dial"

    override fun description(): String =
        "Open the phone dialer with the specified phone number prefilled (no call is placed)."

    override fun parametersSpec(): List<ParameterSpec> = listOf(
        ParameterSpec(
            name = "phone_number",
            type = "string",
            required = true,
            description = "The phone number to dial. Digits only or may include + and spaces."
        )
    )

    override fun buildIntent(context: Context, params: Map<String, Any?>): Intent? {
        val raw = params["phone_number"]?.toString()?.trim().orEmpty()
        if (raw.isEmpty()) return null
        val sanitized = raw.replace(" ", "")
        val uri = "tel:$sanitized".toUri()
        return Intent(Intent.ACTION_DIAL, uri)
    }
}




================================================
FILE: app/src/main/java/com/blurr/voice/intents/impl/EmailComposeIntent.kt
================================================
package com.blurr.voice.intents.impl

import android.content.Context
import android.content.Intent
import android.net.Uri
import com.blurr.voice.intents.AppIntent
import com.blurr.voice.intents.ParameterSpec
import androidx.core.net.toUri

class EmailComposeIntent : AppIntent {
    override val name: String = "EmailCompose"

    override fun description(): String =
        "Always use this intent when you want to send the email to mail:id. this intent will use the default email app."

    override fun parametersSpec(): List<ParameterSpec> = listOf(
        ParameterSpec("to", "string", false, "Comma-separated email recipients."),
        ParameterSpec("subject", "string", false, "Email subject."),
        ParameterSpec("body", "string", false, "Email body text.")
    )

    override fun buildIntent(context: Context, params: Map<String, Any?>): Intent? {
        val to = params["to"]?.toString()?.trim().orEmpty()
        val mailto = if (to.isBlank()) "mailto:" else "mailto:$to"
        return Intent(Intent.ACTION_SENDTO).apply {
            data = Uri.parse("mailto:")
            putExtra(Intent.EXTRA_EMAIL, arrayOf(mailto))
            params["subject"]?.toString()?.takeIf { it.isNotBlank() }?.let {
                putExtra(Intent.EXTRA_SUBJECT, it)
            }
            params["body"]?.toString()?.takeIf { it.isNotBlank() }?.let {
                putExtra(Intent.EXTRA_TEXT, it)
            }
        }
//        val recipient = "ayush0000ayush@gmail.com"
//        val subject = "Please increase limits"
//        val body = "Hello,\n\nPlease increase the task limits for my account: $userEmail\n\nThank you."
//
//        val intent = Intent(Intent.ACTION_SENDTO).apply {
//            data = Uri.parse("mailto:") // Only email apps should handle this
//            putExtra(Intent.EXTRA_EMAIL, arrayOf(recipient))
//            putExtra(Intent.EXTRA_SUBJECT, subject)
//            putExtra(Intent.EXTRA_TEXT, body)
//        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/intents/impl/ShareTextIntent.kt
================================================
package com.blurr.voice.intents.impl

import android.content.Context
import android.content.Intent
import com.blurr.voice.intents.AppIntent
import com.blurr.voice.intents.ParameterSpec

class ShareTextIntent : AppIntent {
    override val name: String = "ShareText"

    override fun description(): String =
        "Open the system share sheet to send text. Use this when you want to send a text to someone, it will give access to all the apps here"

    override fun parametersSpec(): List<ParameterSpec> = listOf(
        ParameterSpec(
            name = "text",
            type = "string",
            required = true,
            description = "The text to share."
        ),
        ParameterSpec(
            name = "chooser_title",
            type = "string",
            required = false,
            description = "Optional chooser title shown on the share sheet."
        )
    )

    override fun buildIntent(context: Context, params: Map<String, Any?>): Intent? {
        val text = params["text"]?.toString()?.trim().orEmpty()
        if (text.isEmpty()) return null
        val base = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, text)
        }
        val title = params["chooser_title"]?.toString()?.takeIf { it.isNotBlank() } ?: "Share via"
        return Intent.createChooser(base, title)
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/intents/impl/ViewUrlIntent.kt
================================================
package com.blurr.voice.intents.impl

import android.content.Context
import android.content.Intent
import android.net.Uri
import com.blurr.voice.intents.AppIntent
import com.blurr.voice.intents.ParameterSpec
import androidx.core.net.toUri

class ViewUrlIntent : AppIntent {
    override val name: String = "ViewUrl"

    override fun description(): String =
        "Open a web URL in the default browser."

    override fun parametersSpec(): List<ParameterSpec> = listOf(
        ParameterSpec(
            name = "url",
            type = "string",
            required = true,
            description = "The HTTP/HTTPS URL to open."
        )
    )

    override fun buildIntent(context: Context, params: Map<String, Any?>): Intent? {
        val url = params["url"]?.toString()?.trim().orEmpty()
        if (url.isEmpty()) return null
        return Intent(Intent.ACTION_VIEW, url.toUri())
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/services/EnhancedWakeWordService.kt
================================================
package com.blurr.voice.services

import android.Manifest
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.IBinder
import android.util.Log
import android.widget.Toast
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.blurr.voice.ConversationalAgentService
import com.blurr.voice.MainActivity
import com.blurr.voice.R
import com.blurr.voice.api.PorcupineWakeWordDetector
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

class EnhancedWakeWordService : Service() {

    private var porcupineDetector: PorcupineWakeWordDetector? = null
    private var usePorcupine = false
    private val serviceScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    companion object {
        const val CHANNEL_ID = "EnhancedWakeWordServiceChannel"
        var isRunning = false
        const val ACTION_WAKE_WORD_FAILED = "com.blurr.voice.WAKE_WORD_FAILED"
        const val EXTRA_USE_PORCUPINE = "use_porcupine"
    }

    override fun onCreate() {
        super.onCreate()
        isRunning = true
        Log.d("EnhancedWakeWordService", "Service onCreate() called, isRunning set to true")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d("EnhancedWakeWordService", "Service starting...")
        
        // Check if we have the required RECORD_AUDIO permission
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            Log.e("EnhancedWakeWordService", "RECORD_AUDIO permission not granted. Cannot start foreground service.")
            Toast.makeText(this, "Microphone permission required for wake word", Toast.LENGTH_LONG).show()
            // Make sure to reset the isRunning flag
            isRunning = false
            stopSelf()
            return START_NOT_STICKY
        }
        
        usePorcupine = intent?.getBooleanExtra(EXTRA_USE_PORCUPINE, false) ?: false
        
        createNotificationChannel()

        val notificationIntent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            PendingIntent.FLAG_IMMUTABLE
        )

        val engineName = if (usePorcupine) "Porcupine" else "STT"
        val notification: Notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Blurr Wake Word")
            .setContentText("Listening for 'Panda' with Porcupine engine...")
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentIntent(pendingIntent)
            .build()

        try {
            startForeground(1338, notification)
        } catch (e: SecurityException) {
            Log.e("EnhancedWakeWordService", "Failed to start foreground service: ${e.message}")
            Toast.makeText(this, "Cannot start wake word service - permission missing", Toast.LENGTH_LONG).show()
            // Make sure to reset the isRunning flag
            isRunning = false
            stopSelf()
            return START_NOT_STICKY
        }

        // Start the appropriate wake word detector
        startWakeWordDetection()

        return START_STICKY
    }

    private fun startWakeWordDetection() {
        val onWakeWordDetected: () -> Unit = {
            // Check if the conversational agent isn't already running
            if (!ConversationalAgentService.isRunning) {
                val serviceIntent = Intent(this, ConversationalAgentService::class.java)
                ContextCompat.startForegroundService(this, serviceIntent)

                Toast.makeText(this, "Panda listening...", Toast.LENGTH_SHORT).show()
            } else {
                Log.d("EnhancedWakeWordService", "Conversational agent is already running.")
            }
        }

        val onApiFailure: () -> Unit = {
            Log.d("EnhancedWakeWordService", "Porcupine API failed, starting floating button service")
            // Start the floating button service when API fails
            val intent = Intent(ACTION_WAKE_WORD_FAILED)
            sendBroadcast(intent)
            stopSelf()
        }

        try {
            if (usePorcupine) {
                Log.d("EnhancedWakeWordService", "Using Porcupine wake word detection")
                porcupineDetector = PorcupineWakeWordDetector(this, onWakeWordDetected, onApiFailure)
                porcupineDetector?.start()
            } else {
                Log.d("EnhancedWakeWordService", "Using Porcupine wake word detection")
                porcupineDetector = PorcupineWakeWordDetector(this, onWakeWordDetected, onApiFailure)
                porcupineDetector?.start()
            }
        } catch (e: Exception) {
            Log.e("EnhancedWakeWordService", "Error starting wake word detection: ${e.message}")
            // If there's any error, start the floating button service
            onApiFailure()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        
        Log.d("EnhancedWakeWordService", "Service onDestroy() called")
        
        porcupineDetector?.stop()
        porcupineDetector = null
        
        isRunning = false
        Log.d("EnhancedWakeWordService", "Service destroyed, isRunning set to false")
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                CHANNEL_ID,
                "Enhanced Wake Word Service Channel",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/services/FloatingPandaButtonService.kt
================================================
package com.blurr.voice.services

import android.app.Service
import android.content.Context
import android.content.Intent
import android.graphics.Color
import android.graphics.PixelFormat
import android.os.Build
import android.os.IBinder
import android.provider.Settings
import android.util.Log
import android.view.Gravity
import android.view.View
import android.view.WindowManager
import android.widget.Button
import androidx.core.content.ContextCompat
import com.blurr.voice.ConversationalAgentService
import com.blurr.voice.R

class FloatingPandaButtonService : Service() {

    private var windowManager: WindowManager? = null
    private var floatingButton: View? = null

    companion object {
        private const val TAG = "FloatingPandaButton"
        var isRunning = false
    }

    override fun onCreate() {
        super.onCreate()
        isRunning = true
        Log.d(TAG, "Floating Panda Button Service created")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "Floating Panda Button Service starting...")

        if (!Settings.canDrawOverlays(this)) {
            Log.w(TAG, "Cannot show floating button: 'Draw over other apps' permission not granted.")
            stopSelf()
            return START_NOT_STICKY
        }

        try {
            showFloatingButton()
            if (floatingButton == null) {
                Log.w(TAG, "Failed to show floating button, stopping service")
                stopSelf()
                return START_NOT_STICKY
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error showing floating button", e)
            stopSelf()
            return START_NOT_STICKY
        }

        return START_STICKY
    }

    private fun showFloatingButton() {
        if (floatingButton != null) {
            Log.d(TAG, "Floating button already showing")
            return
        }

        windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager

        try {
            // Create the button programmatically
            floatingButton = createFloatingView()
            val button = floatingButton as Button

            // Set up the button click listener
            button.setOnClickListener {
                Log.d(TAG, "Floating Panda button clicked!")
                triggerPandaActivation()
            }

            val displayMetrics = resources.displayMetrics
            val margin = (16 * displayMetrics.density).toInt() // 16dp margin

            val windowType = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
            } else {
                WindowManager.LayoutParams.TYPE_PHONE
            }

            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.WRAP_CONTENT,
                windowType,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.BOTTOM or Gravity.END
                x = margin
                y = margin
            }

            windowManager?.addView(floatingButton, params)
            Log.d(TAG, "Floating Panda button added successfully")
        } catch (e: Exception) {
            Log.e(TAG, "Error adding floating button", e)
            floatingButton = null
        }
    }

    private fun createFloatingView(): Button {
        return Button(this).apply {
            text = "Hey Panda"
            // Prevent text from being all caps for a softer look
            isAllCaps = false
            setTextColor(Color.WHITE)
            // Use the new pill-shaped background
            background = ContextCompat.getDrawable(context, R.drawable.floating_panda_text_background)

            // Add elevation for a floating shadow effect
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                elevation = 8f * resources.displayMetrics.density
                // Remove the default button press animation for a cleaner look
                stateListAnimator = null
            }
        }
    }


    private fun triggerPandaActivation() {
        try {
            if (!ConversationalAgentService.isRunning) {
                Log.d(TAG, "Starting ConversationalAgentService from floating button")
                val serviceIntent = Intent(this, ConversationalAgentService::class.java)
                ContextCompat.startForegroundService(this, serviceIntent)
            } else {
                Log.d(TAG, "ConversationalAgentService is already running")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error starting ConversationalAgentService", e)
        }
    }

    private fun hideFloatingButton() {
        floatingButton?.let { button ->
            try {
                if (button.isAttachedToWindow) {
                    windowManager?.removeView(button)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error removing floating button", e)
            }
        }
        floatingButton = null
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Floating Panda Button Service destroying...")
        hideFloatingButton()
        isRunning = false
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/services/WakeWorkService.kt
================================================
package com.blurr.voice.services

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.blurr.voice.MainActivity
import com.blurr.voice.R
import com.blurr.voice.api.WakeWordDetector

class WakeWordService : Service() {

    private lateinit var wakeWordDetector: WakeWordDetector

    companion object {
        const val CHANNEL_ID = "WakeWordServiceChannel"
        var isRunning = false
    }

    override fun onCreate() {
        super.onCreate()
        wakeWordDetector = WakeWordDetector(this) {
            // This is the callback that gets triggered when the wake word is detected
            Log.d("WakeWordService", "Wake word detected! Launching MainActivity.")
            val intent = Intent(this, MainActivity::class.java).apply {
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            }
            startActivity(intent)
        }
        isRunning = true
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d("WakeWordService", "Service starting...")
        createNotificationChannel()

        val notificationIntent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            PendingIntent.FLAG_IMMUTABLE
        )

        val notification: Notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Blurr Wake Word")
            .setContentText("Listening for 'Panda'...")
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentIntent(pendingIntent)
            .build()

        startForeground(1337, notification)

        // Start listening for the wake word
        wakeWordDetector.start()

        return START_STICKY
    }

    override fun onDestroy() {
        super.onDestroy()
        wakeWordDetector.stop()
        isRunning = false
        Log.d("WakeWordService", "Service destroyed.")
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                CHANNEL_ID,
                "Wake Word Service Channel",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/triggers/BootReceiver.kt
================================================
package com.blurr.voice.triggers

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class BootReceiver : BroadcastReceiver() {

    private val TAG = "BootReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d(TAG, "Device boot completed. Rescheduling alarms.")
            val triggerManager = TriggerManager.getInstance(context)

            // It's good practice to do this work off the main thread
            // Start the TriggerMonitoringService
            val serviceIntent = Intent(context, TriggerMonitoringService::class.java)
            context.startService(serviceIntent)
            Log.d(TAG, "Started TriggerMonitoringService on boot.")

            CoroutineScope(Dispatchers.IO).launch {
                val triggers = triggerManager.getTriggers()
                val scheduledTriggers = triggers.filter { it.isEnabled && it.type == TriggerType.SCHEDULED_TIME }
                scheduledTriggers.forEach { trigger ->
                    // In the future, we might have different logic for rescheduling
                    // but for now, just calling schedule is fine as it will recreate the alarm.
                    triggerManager.updateTrigger(trigger)
                }
                Log.d(TAG, "Finished rescheduling ${scheduledTriggers.size} alarms.")
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ChargingStateReceiver.kt
================================================
package com.blurr.voice.triggers

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.BatteryManager
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class ChargingStateReceiver : BroadcastReceiver() {

    private val TAG = "ChargingStateReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        Log.d(TAG, "Received broadcast: $action")

        if (action != Intent.ACTION_POWER_CONNECTED && action != Intent.ACTION_POWER_DISCONNECTED) {
            return
        }

        val status = if (action == Intent.ACTION_POWER_CONNECTED) "Connected" else "Disconnected"
        Log.d(TAG, "Device charging status: $status")

        CoroutineScope(Dispatchers.IO).launch {
            val triggerManager = TriggerManager.getInstance(context)
            val triggers = triggerManager.getTriggers()
            val matchingTriggers = triggers.filter {
                it.isEnabled && it.type == TriggerType.CHARGING_STATE && it.chargingStatus == status
            }

            Log.d(TAG, "Found ${matchingTriggers.size} matching triggers for status '$status'")

            matchingTriggers.forEach { trigger ->
                Log.d(TAG, "Executing trigger: ${trigger.id} - ${trigger.instruction}")
                val executeIntent = Intent(context, TriggerReceiver::class.java).apply {
                    this.action = TriggerReceiver.ACTION_EXECUTE_TASK
                    putExtra(TriggerReceiver.EXTRA_TASK_INSTRUCTION, trigger.instruction)
                }
                context.sendBroadcast(executeIntent)
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/PandaNotificationListenerService.kt
================================================
package com.blurr.voice.triggers

import android.service.notification.NotificationListenerService
import android.service.notification.StatusBarNotification
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class PandaNotificationListenerService : NotificationListenerService() {

    private val TAG = "PandaNotification"
    private lateinit var triggerManager: TriggerManager

    override fun onCreate() {
        super.onCreate()
        triggerManager = TriggerManager.getInstance(this)
    }

    override fun onNotificationPosted(sbn: StatusBarNotification?) {
        super.onNotificationPosted(sbn)
        if (sbn == null) return

        val packageName = sbn.packageName
        Log.d(TAG, "Notification posted from package: $packageName")

        if (packageName == this.packageName) {
            Log.d(TAG, "Ignoring notification from own package.")
            return
        }

        CoroutineScope(Dispatchers.IO).launch {
            val notificationTriggers = triggerManager.getTriggers()
                .filter { it.type == TriggerType.NOTIFICATION && it.isEnabled }

            // First, check for the "All Applications" trigger
            var matchingTrigger = notificationTriggers.find { it.packageName == "*" }

            // If no "All Applications" trigger is found, check for a specific app trigger
            if (matchingTrigger == null) {
                matchingTrigger = notificationTriggers.find { it.packageName == packageName }
            }

            if (matchingTrigger != null) {
                val extras = sbn.notification.extras
                val title = extras.getString("android.title") ?: ""
                val text = extras.getCharSequence("android.text")?.toString() ?: ""
                val notificationContent = "Notification Content: $title - $text"
                val finalInstruction = "${matchingTrigger.instruction}\n\n$notificationContent"

                Log.d(TAG, "Found matching trigger for package: $packageName. Executing instruction: $finalInstruction")
                // Use the TriggerReceiver to start the agent service
                val intent = android.content.Intent(this@PandaNotificationListenerService, TriggerReceiver::class.java).apply {
                    action = TriggerReceiver.ACTION_EXECUTE_TASK
                    putExtra(TriggerReceiver.EXTRA_TASK_INSTRUCTION, finalInstruction)
                }
                sendBroadcast(intent)
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/PermissionUtils.kt
================================================
package com.blurr.voice.triggers

import android.content.Context
import android.provider.Settings

import android.app.AlarmManager
import android.os.Build

object PermissionUtils {

    fun isNotificationListenerEnabled(context: Context): Boolean {
        val enabledListeners = Settings.Secure.getString(context.contentResolver, "enabled_notification_listeners")
        val componentName = PandaNotificationListenerService::class.java.canonicalName
        return enabledListeners?.contains(componentName) == true
    }

    fun canScheduleExactAlarms(context: Context): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            alarmManager.canScheduleExactAlarms()
        } else {
            true // Permission is granted by default on older versions
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/Trigger.kt
================================================
package com.blurr.voice.triggers

import java.util.UUID

enum class TriggerType {
    SCHEDULED_TIME,
    NOTIFICATION,
    CHARGING_STATE
}

data class Trigger(
    val id: String = UUID.randomUUID().toString(),
    val type: TriggerType,
    val instruction: String,
    var isEnabled: Boolean = true,
    // For SCHEDULED_TIME triggers
    val hour: Int? = null,
    val minute: Int? = null,
    // For NOTIFICATION triggers
    val packageName: String? = null,
    val appName: String? = null, // For display purposes
    // For SCHEDULED_TIME triggers
    val daysOfWeek: Set<Int> = setOf(1, 2, 3, 4, 5, 6, 7), // Default to all days
    // For CHARGING_STATE triggers
    val chargingStatus: String? = null // e.g., "Connected", "Disconnected"
)



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/TriggerManager.kt
================================================
package com.blurr.voice.triggers

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Intent
import java.util.Calendar

class TriggerManager(private val context: Context) {

    private val sharedPreferences: SharedPreferences by lazy {
        context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }
    private val alarmManager: AlarmManager by lazy {
        context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    }
    private val gson = Gson()

    fun addTrigger(trigger: Trigger) {
        val triggers = loadTriggers()
        triggers.add(trigger)
        saveTriggers(triggers)
        if (trigger.isEnabled) {
            scheduleAlarm(trigger)
        }
    }

    fun removeTrigger(trigger: Trigger) {
        val triggers = loadTriggers()
        val triggerToRemove = triggers.find { it.id == trigger.id }
        if (triggerToRemove != null) {
            cancelAlarm(triggerToRemove)
            triggers.remove(triggerToRemove)
            saveTriggers(triggers)
        }
    }

    fun getTriggers(): List<Trigger> {
        return loadTriggers()
    }

    fun rescheduleTrigger(triggerId: String) {
        val triggers = loadTriggers()
        val trigger = triggers.find { it.id == triggerId }
        if (trigger != null && trigger.isEnabled) {
            // This will calculate the next day's time and set a new exact alarm
            scheduleAlarm(trigger)
            android.util.Log.d("TriggerManager", "Rescheduled trigger: ${trigger.id}")
        }
    }

    fun updateTrigger(trigger: Trigger) {
        val triggers = loadTriggers()
        val index = triggers.indexOfFirst { it.id == trigger.id }
        if (index != -1) {
            triggers[index] = trigger
            saveTriggers(triggers)
            if (trigger.isEnabled) {
                scheduleAlarm(trigger)
            } else {
                cancelAlarm(trigger)
            }
        }
    }

    fun executeInstruction(instruction: String) {
        android.util.Log.d("TriggerManager", "Executing instruction: $instruction")
        val intent = Intent(context, TriggerReceiver::class.java).apply {
            action = TriggerReceiver.ACTION_EXECUTE_TASK
            putExtra(TriggerReceiver.EXTRA_TASK_INSTRUCTION, instruction)
        }
        context.sendBroadcast(intent)
    }

    private fun scheduleAlarm(trigger: Trigger) {
        if (trigger.type != TriggerType.SCHEDULED_TIME) {
            android.util.Log.w("TriggerManager", "Attempted to schedule alarm for non-time-based trigger: ${trigger.id}")
            return
        }

        val intent = Intent(context, TriggerReceiver::class.java).apply {
            action = TriggerReceiver.ACTION_EXECUTE_TASK
            putExtra(TriggerReceiver.EXTRA_TASK_INSTRUCTION, trigger.instruction)
            putExtra(TriggerReceiver.EXTRA_TRIGGER_ID, trigger.id)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            trigger.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val nextTriggerTime = getNextTriggerTime(trigger.hour!!, trigger.minute!!, trigger.daysOfWeek)
        if (nextTriggerTime == null) {
            android.util.Log.w("TriggerManager", "No valid day of week for trigger: ${trigger.id}")
            return
        }

        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            if (alarmManager.canScheduleExactAlarms()) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    nextTriggerTime.timeInMillis,
                    pendingIntent
                )
            } else {
                // Handle case where permission is not granted.
                // For now, we'll log a warning. The UI part of the plan will handle prompting the user.
                android.util.Log.w("TriggerManager", "Cannot schedule exact alarm, permission not granted.")
            }
        } else {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                nextTriggerTime.timeInMillis,
                pendingIntent
            )
        }
    }

    private fun getNextTriggerTime(hour: Int, minute: Int, daysOfWeek: Set<Int>): Calendar? {
        val now = Calendar.getInstance()
        var nextTrigger = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }

        for (i in 0..7) {
            val day = (now.get(Calendar.DAY_OF_WEEK) + i - 1) % 7 + 1
            if (day in daysOfWeek) {
                nextTrigger.add(Calendar.DAY_OF_YEAR, i)
                if (nextTrigger.after(now)) {
                    return nextTrigger
                }
                // Reset for next iteration
                nextTrigger.add(Calendar.DAY_OF_YEAR, -i)
            }
        }
        return null // Should not happen if at least one day is selected
    }

    private fun cancelAlarm(trigger: Trigger) {
        if (trigger.type != TriggerType.SCHEDULED_TIME) {
            return // No alarm to cancel for non-time-based triggers
        }
        val intent = Intent(context, TriggerReceiver::class.java).apply {
            action = TriggerReceiver.ACTION_EXECUTE_TASK
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            trigger.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        alarmManager.cancel(pendingIntent)
    }

    private fun saveTriggers(triggers: List<Trigger>) {
        val json = gson.toJson(triggers)
        sharedPreferences.edit().putString(KEY_TRIGGERS, json).apply()
    }

    private fun loadTriggers(): MutableList<Trigger> {
        val json = sharedPreferences.getString(KEY_TRIGGERS, null)
        return if (json != null) {
            val type = object : TypeToken<MutableList<Trigger>>() {}.type
            gson.fromJson(json, type)
        } else {
            mutableListOf()
        }
    }

    companion object {
        private const val PREFS_NAME = "com.blurr.voice.triggers.prefs"
        private const val KEY_TRIGGERS = "triggers_list"

        @Volatile
        private var INSTANCE: TriggerManager? = null

        fun getInstance(context: Context): TriggerManager {
            return INSTANCE ?: synchronized(this) {
                val instance = TriggerManager(context.applicationContext)
                INSTANCE = instance
                instance
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/TriggerMonitoringService.kt
================================================
package com.blurr.voice.triggers

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.blurr.voice.MainActivity
import com.blurr.voice.R

class TriggerMonitoringService : Service() {

    private val TAG = "TriggerMonitoringSvc"
    private val chargingStateReceiver = ChargingStateReceiver()

    companion object {
        const val CHANNEL_ID = "TriggerMonitoringServiceChannel"
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Service onCreate")
        createNotificationChannel()
        registerReceivers()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "Service onStartCommand")
        val notificationIntent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, PendingIntent.FLAG_IMMUTABLE)

        val notification: Notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Blurr Trigger Service")
            .setContentText("Monitoring for app triggers in the background.")
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentIntent(pendingIntent)
            .build()

        startForeground(1339, notification)

        return START_STICKY
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Service onDestroy")
        unregisterReceiver(chargingStateReceiver)
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                CHANNEL_ID,
                "Trigger Monitoring Service Channel",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }

    private fun registerReceivers() {
        val intentFilter = IntentFilter().apply {
            addAction(Intent.ACTION_POWER_CONNECTED)
            addAction(Intent.ACTION_POWER_DISCONNECTED)
        }
        registerReceiver(chargingStateReceiver, intentFilter)
        Log.d(TAG, "ChargingStateReceiver registered")
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/TriggerReceiver.kt
================================================
package com.blurr.voice.triggers

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import com.blurr.voice.v2.AgentService
import kotlinx.coroutines.launch
import java.util.concurrent.ConcurrentHashMap

class TriggerReceiver : BroadcastReceiver() {

    companion object {
        const val ACTION_EXECUTE_TASK = "com.blurr.voice.action.EXECUTE_TASK"
        const val EXTRA_TASK_INSTRUCTION = "com.blurr.voice.EXTRA_TASK_INSTRUCTION"
        const val EXTRA_TRIGGER_ID = "com.blurr.voice.EXTRA_TRIGGER_ID"
        private const val TAG = "TriggerReceiver"
        private const val DEBOUNCE_INTERVAL_MS = 60 * 1000 // 1 minute

        // Cache to store recent task instructions and their timestamps
        private val recentTasks = ConcurrentHashMap<String, Long>()
    }

    override fun onReceive(context: Context?, intent: Intent?) {
        if (context == null || intent == null) {
            Log.w(TAG, "Received null context or intent, cannot proceed.")
            return
        }

        if (intent.action == ACTION_EXECUTE_TASK) {
            val taskInstruction = intent.getStringExtra(EXTRA_TASK_INSTRUCTION)

            if (taskInstruction.isNullOrBlank()) {
                Log.e(TAG, "Received execute task action but instruction was null or empty.")
                return
            }

            val currentTime = System.currentTimeMillis()
            val lastExecutionTime = recentTasks[taskInstruction]

            if (lastExecutionTime != null && (currentTime - lastExecutionTime) < DEBOUNCE_INTERVAL_MS) {
                Log.d(TAG, "Debouncing duplicate task: '$taskInstruction'")
                return
            }

            // Update the cache with the new execution time
            recentTasks[taskInstruction] = currentTime

            Log.d(TAG, "Received task to execute: '$taskInstruction'")

            // Directly start the v2 AgentService
            AgentService.start(context, taskInstruction)

            // Reschedule the alarm for the next day
            val triggerId = intent.getStringExtra(EXTRA_TRIGGER_ID)
            if (triggerId != null) {
                kotlinx.coroutines.GlobalScope.launch(kotlinx.coroutines.Dispatchers.IO) {
                    TriggerManager.getInstance(context).rescheduleTrigger(triggerId)
                }
            }

            // Clean up old entries from the cache
            cleanupRecentTasks(currentTime)
        }
    }

    private fun cleanupRecentTasks(currentTime: Long) {
        // For simplicity, this example cleans up tasks older than the debounce interval.
        // A more sophisticated approach might use a background thread or a more complex cache eviction policy.
        val iterator = recentTasks.entries.iterator()
        while (iterator.hasNext()) {
            val entry = iterator.next()
            if ((currentTime - entry.value) > DEBOUNCE_INTERVAL_MS) {
                iterator.remove()
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ui/AppAdapter.kt
================================================
package com.blurr.voice.triggers.ui

import android.graphics.drawable.Drawable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.Filter
import android.widget.Filterable
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.R
import java.util.Locale

data class AppInfo(
    val appName: String,
    val packageName: String,
    val icon: Drawable? = null
)

class AppAdapter(
    private var apps: List<AppInfo>,
    private val onSelectionChanged: (List<AppInfo>) -> Unit
) : RecyclerView.Adapter<AppAdapter.AppViewHolder>(), Filterable {

    private var filteredApps: List<AppInfo> = apps
    private val selectedApps = mutableSetOf<AppInfo>()

    fun updateApps(newApps: List<AppInfo>) {
        this.apps = newApps
        this.filteredApps = newApps
        notifyDataSetChanged()
    }

    fun setSelectedApps(apps: List<AppInfo>) {
        selectedApps.clear()
        selectedApps.addAll(apps)
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AppViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_app, parent, false)
        return AppViewHolder(view)
    }

    override fun onBindViewHolder(holder: AppViewHolder, position: Int) {
        val app = filteredApps[position]
        holder.bind(app, selectedApps.contains(app))
    }

    override fun getItemCount(): Int = filteredApps.size

    override fun getFilter(): Filter {
        return object : Filter() {
            override fun performFiltering(constraint: CharSequence?): FilterResults {
                val charString = constraint?.toString()?.lowercase(Locale.getDefault()) ?: ""
                val filteredList = if (charString.isEmpty()) {
                    apps
                } else {
                    apps.filter {
                        it.appName.lowercase(Locale.getDefault()).contains(charString)
                    }
                }
                val filterResults = FilterResults()
                filterResults.values = filteredList
                return filterResults
            }

            @Suppress("UNCHECKED_CAST")
            override fun publishResults(constraint: CharSequence?, results: FilterResults?) {
                filteredApps = results?.values as? List<AppInfo> ?: emptyList()
                notifyDataSetChanged()
            }
        }
    }

    inner class AppViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val appIconImageView: ImageView = itemView.findViewById(R.id.appIconImageView)
        private val appNameTextView: TextView = itemView.findViewById(R.id.appNameTextView)
        private val appCheckBox: CheckBox = itemView.findViewById(R.id.appCheckBox)

        fun bind(app: AppInfo, isSelected: Boolean) {
            appIconImageView.setImageDrawable(app.icon)
            appNameTextView.text = app.appName
            appCheckBox.isChecked = isSelected

            itemView.setOnClickListener {
                if (selectedApps.contains(app)) {
                    selectedApps.remove(app)
                } else {
                    selectedApps.add(app)
                }
                notifyItemChanged(bindingAdapterPosition)
                onSelectionChanged(selectedApps.toList())
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ui/ChooseTriggerTypeActivity.kt
================================================
package com.blurr.voice.triggers.ui

import android.content.Intent
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.cardview.widget.CardView
import com.blurr.voice.R
import com.blurr.voice.triggers.TriggerType

class ChooseTriggerTypeActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_choose_trigger_type)

        val toolbar = findViewById<androidx.appcompat.widget.Toolbar>(R.id.toolbar)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)

        findViewById<CardView>(R.id.scheduledTimeCard).setOnClickListener {
            launchCreateTriggerActivity(TriggerType.SCHEDULED_TIME)
        }

        findViewById<CardView>(R.id.notificationCard).setOnClickListener {
            launchCreateTriggerActivity(TriggerType.NOTIFICATION)
        }

        findViewById<CardView>(R.id.chargingStateCard).setOnClickListener {
            launchCreateTriggerActivity(TriggerType.CHARGING_STATE)
        }
    }

    private fun launchCreateTriggerActivity(triggerType: TriggerType) {
        val intent = Intent(this, CreateTriggerActivity::class.java).apply {
            putExtra("EXTRA_TRIGGER_TYPE", triggerType)
        }
        startActivity(intent)
    }

    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ui/CreateTriggerActivity.kt
================================================
package com.blurr.voice.triggers.ui

import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.provider.Settings
import android.text.Editable
import android.text.TextWatcher
import android.view.View
import android.widget.Button
import android.widget.CheckBox
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.RadioGroup
import android.widget.ScrollView
import android.widget.TimePicker
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.R
import com.blurr.voice.triggers.PermissionUtils
import com.blurr.voice.triggers.Trigger
import com.blurr.voice.triggers.TriggerManager
import com.blurr.voice.triggers.TriggerType
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class CreateTriggerActivity : AppCompatActivity() {

    private lateinit var triggerManager: TriggerManager
    private lateinit var instructionEditText: EditText
    private lateinit var searchEditText: EditText
    private lateinit var scheduledTimeOptions: LinearLayout
    private lateinit var notificationOptions: LinearLayout
    private lateinit var chargingStateOptions: LinearLayout
    private lateinit var timePicker: TimePicker
    private lateinit var appsRecyclerView: RecyclerView
    private lateinit var dayOfWeekChipGroup: com.google.android.material.chip.ChipGroup
    private lateinit var appAdapter: AppAdapter
    private lateinit var scrollView: ScrollView
    private lateinit var selectAllAppsCheckbox: CheckBox
    private lateinit var notificationPermissionWarning: LinearLayout
    private lateinit var grantNotificationPermissionButton: Button
    private lateinit var alarmPermissionWarning: LinearLayout
    private lateinit var grantAlarmPermissionButton: Button

    private var selectedTriggerType = TriggerType.SCHEDULED_TIME
    private var selectedApps = listOf<AppInfo>()
    private var existingTrigger: Trigger? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_create_trigger)

        val toolbar = findViewById<androidx.appcompat.widget.Toolbar>(R.id.toolbar)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)

        triggerManager = TriggerManager.getInstance(this)
        instructionEditText = findViewById(R.id.instructionEditText)
        searchEditText = findViewById(R.id.searchEditText)
        scheduledTimeOptions = findViewById(R.id.scheduledTimeOptions)
        notificationOptions = findViewById(R.id.notificationOptions)
        chargingStateOptions = findViewById(R.id.chargingStateOptions)
        timePicker = findViewById(R.id.timePicker)
        appsRecyclerView = findViewById(R.id.appsRecyclerView)
        dayOfWeekChipGroup = findViewById(R.id.dayOfWeekChipGroup)
        notificationPermissionWarning = findViewById(R.id.notificationPermissionWarning)
        grantNotificationPermissionButton = findViewById(R.id.grantNotificationPermissionButton)
        alarmPermissionWarning = findViewById(R.id.alarmPermissionWarning)
        grantAlarmPermissionButton = findViewById(R.id.grantAlarmPermissionButton)
//        scrollView = findViewById(R.id.scrollView)

//        instructionEditText.setOnFocusChangeListener { view, hasFocus ->
//            if (hasFocus) {
//                // Delay scrolling until the keyboard is likely to be visible
//                view.postDelayed({
//                    scrollView.smoothScrollTo(0, view.bottom)
//                }, 200)
//            }
//        }

        val saveButton = findViewById<Button>(R.id.saveTriggerButton)

        val triggerId = intent.getStringExtra("EXTRA_TRIGGER_ID")
        if (triggerId != null) {
            // Edit mode
            lifecycleScope.launch {
                existingTrigger = withContext(Dispatchers.IO) {
                    triggerManager.getTriggers().find { it.id == triggerId }
                }
                if (existingTrigger != null) {
                    selectedTriggerType = existingTrigger!!.type
                    populateUiWithTriggerData(existingTrigger!!)
                    saveButton.text = "Update Trigger"
                } else {
                    // Trigger not found, something is wrong.
                    Toast.makeText(this@CreateTriggerActivity, "Trigger not found.", Toast.LENGTH_SHORT).show()
                    finish()
                }
            }
        } else {
            // Create mode
            selectedTriggerType = intent.getSerializableExtra("EXTRA_TRIGGER_TYPE") as TriggerType
            // Set default checked state for all day chips
            for (i in 0 until dayOfWeekChipGroup.childCount) {
                (dayOfWeekChipGroup.getChildAt(i) as com.google.android.material.chip.Chip).isChecked = true
            }
        }


        setupInitialView()

        setupRecyclerView()
        loadApps()

        searchEditText.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                appAdapter.filter.filter(s)
            }
            override fun afterTextChanged(s: Editable?) {}
        })

        selectAllAppsCheckbox = findViewById(R.id.selectAllAppsCheckbox)
        selectAllAppsCheckbox.setOnCheckedChangeListener { _, isChecked ->
            appsRecyclerView.isEnabled = !isChecked
            appsRecyclerView.alpha = if (isChecked) 0.5f else 1.0f
            if (isChecked) {
                appAdapter.setSelectedApps(emptyList())
                selectedApps = emptyList()
            }
        }

        saveButton.setOnClickListener {
            saveTrigger()
        }

        val testButton = findViewById<Button>(R.id.testTriggerButton)
        testButton.setOnClickListener {
            testTrigger()
        }
    }

    override fun onResume() {
        super.onResume()
        checkNotificationPermission()
        checkAlarmPermission()
    }

    private fun checkNotificationPermission() {
        if (selectedTriggerType == TriggerType.NOTIFICATION) {
            if (PermissionUtils.isNotificationListenerEnabled(this)) {
                notificationPermissionWarning.visibility = View.GONE
            } else {
                notificationPermissionWarning.visibility = View.VISIBLE
                grantNotificationPermissionButton.setOnClickListener {
                    val intent = Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS)
                    startActivity(intent)
                }
            }
        }
    }

    private fun checkAlarmPermission() {
        if (selectedTriggerType == TriggerType.SCHEDULED_TIME) {
            if (PermissionUtils.canScheduleExactAlarms(this)) {
                alarmPermissionWarning.visibility = View.GONE
            } else {
                alarmPermissionWarning.visibility = View.VISIBLE
                grantAlarmPermissionButton.setOnClickListener {
                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
                        startActivity(Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM))
                    }
                }
            }
        }
    }

    private fun testTrigger() {
        val instruction = instructionEditText.text.toString()
        if (instruction.isBlank()) {
            Toast.makeText(this, "Instruction cannot be empty", Toast.LENGTH_SHORT).show()
            return
        }

        triggerManager.executeInstruction(instruction)
        Toast.makeText(this, "Test trigger fired!", Toast.LENGTH_SHORT).show()
    }

    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }

    private fun populateUiWithTriggerData(trigger: Trigger) {
        instructionEditText.setText(trigger.instruction)

        when (trigger.type) {
            TriggerType.SCHEDULED_TIME -> {
                timePicker.hour = trigger.hour ?: 0
                timePicker.minute = trigger.minute ?: 0
                // Clear all chips first
                for (i in 0 until dayOfWeekChipGroup.childCount) {
                    (dayOfWeekChipGroup.getChildAt(i) as com.google.android.material.chip.Chip).isChecked = false
                }
                // Then check the ones from the trigger
                trigger.daysOfWeek.forEach { day ->
                    (dayOfWeekChipGroup.getChildAt(day - 1) as com.google.android.material.chip.Chip).isChecked = true
                }
            }
            TriggerType.NOTIFICATION -> {
                if (trigger.packageName == "*") {
                    selectAllAppsCheckbox.isChecked = true
                } else {
                    // This will be handled in loadApps now
                }
            }
            TriggerType.CHARGING_STATE -> {
                val radioGroup = findViewById<RadioGroup>(R.id.chargingStatusRadioGroup)
                if (trigger.chargingStatus == "Connected") {
                    radioGroup.check(R.id.radioConnected)
                } else {
                    radioGroup.check(R.id.radioDisconnected)
                }
            }
        }
    }

    private fun setupInitialView() {
        when (selectedTriggerType) {
            TriggerType.SCHEDULED_TIME -> {
                scheduledTimeOptions.visibility = View.VISIBLE
                notificationOptions.visibility = View.GONE
                chargingStateOptions.visibility = View.GONE
                // Hide other permission warnings
                notificationPermissionWarning.visibility = View.GONE
            }
            TriggerType.NOTIFICATION -> {
                scheduledTimeOptions.visibility = View.GONE
                notificationOptions.visibility = View.VISIBLE
                chargingStateOptions.visibility = View.GONE
                // Hide other permission warnings
                alarmPermissionWarning.visibility = View.GONE
            }
            TriggerType.CHARGING_STATE -> {
                scheduledTimeOptions.visibility = View.GONE
                notificationOptions.visibility = View.GONE
                chargingStateOptions.visibility = View.VISIBLE
                // Hide other permission warnings
                notificationPermissionWarning.visibility = View.GONE
                alarmPermissionWarning.visibility = View.GONE
            }
        }
    }

    private fun setupRecyclerView() {
        appsRecyclerView.layoutManager = LinearLayoutManager(this)
        appAdapter = AppAdapter(emptyList()) { apps ->
            selectedApps = apps
        }
        appsRecyclerView.adapter = appAdapter
    }

    private fun loadApps() {
        lifecycleScope.launch(Dispatchers.IO) {
            val pm = packageManager
            val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
                .filter { pm.getLaunchIntentForPackage(it.packageName) != null }
                .map {
                    AppInfo(
                        appName = it.loadLabel(pm).toString(),
                        packageName = it.packageName,
                        icon = it.loadIcon(pm)
                    )
                }
                .sortedBy { it.appName }

            withContext(Dispatchers.Main) {
                appAdapter.updateApps(apps)
                if (existingTrigger != null && existingTrigger!!.type == TriggerType.NOTIFICATION) {
                    val selectedPackageNames = existingTrigger!!.packageName?.split(",") ?: emptyList()
                    val preSelectedApps = apps.filter { it.packageName in selectedPackageNames }
                    appAdapter.setSelectedApps(preSelectedApps)
                    selectedApps = preSelectedApps
                }
            }
        }
    }

    private fun saveTrigger() {
        val instruction = instructionEditText.text.toString()
        if (instruction.isBlank()) {
            Toast.makeText(this, "Instruction cannot be empty", Toast.LENGTH_SHORT).show()
            return
        }

        val trigger: Trigger
        when (selectedTriggerType) {
            TriggerType.SCHEDULED_TIME -> {
                if (!com.blurr.voice.triggers.PermissionUtils.canScheduleExactAlarms(this)) {
                    showExactAlarmPermissionDialog()
                    return
                }
                val selectedDays = getSelectedDays()
                if (selectedDays.isEmpty()) {
                    Toast.makeText(this, "Please select at least one day", Toast.LENGTH_SHORT).show()
                    return
                }
                trigger = Trigger(
                    id = existingTrigger?.id ?: UUID.randomUUID().toString(),
                    type = TriggerType.SCHEDULED_TIME,
                    hour = timePicker.hour,
                    minute = timePicker.minute,
                    instruction = instruction,
                    daysOfWeek = selectedDays,
                    isEnabled = existingTrigger?.isEnabled ?: true
                )
            }
            TriggerType.NOTIFICATION -> {
                if (!PermissionUtils.isNotificationListenerEnabled(this)) {
                    Toast.makeText(this, "Notification listener permission is required.", Toast.LENGTH_SHORT).show()
                    checkNotificationPermission()
                    return
                }

                val packageName: String
                val appName: String
                if (selectAllAppsCheckbox.isChecked) {
                    packageName = "*"
                    appName = "All Applications"
                } else {
                    if (selectedApps.isEmpty()) {
                        Toast.makeText(this, "Please select at least one app", Toast.LENGTH_SHORT).show()
                        return
                    }
                    packageName = selectedApps.joinToString(",") { it.packageName }
                    appName = selectedApps.joinToString(",") { it.appName }
                }

                trigger = Trigger(
                    id = existingTrigger?.id ?: UUID.randomUUID().toString(),
                    type = TriggerType.NOTIFICATION,
                    packageName = packageName,
                    appName = appName,
                    instruction = instruction,
                    isEnabled = existingTrigger?.isEnabled ?: true
                )
            }
            TriggerType.CHARGING_STATE -> {
                val radioGroup = findViewById<RadioGroup>(R.id.chargingStatusRadioGroup)
                val selectedStatus = if (radioGroup.checkedRadioButtonId == R.id.radioConnected) {
                    "Connected"
                } else {
                    "Disconnected"
                }
                trigger = Trigger(
                    id = existingTrigger?.id ?: UUID.randomUUID().toString(),
                    type = TriggerType.CHARGING_STATE,
                    chargingStatus = selectedStatus,
                    instruction = instruction,
                    isEnabled = existingTrigger?.isEnabled ?: true
                )
            }
        }

        if (existingTrigger != null) {
            triggerManager.updateTrigger(trigger)
            Toast.makeText(this, "Trigger updated!", Toast.LENGTH_SHORT).show()
        } else {
            triggerManager.addTrigger(trigger)
            Toast.makeText(this, "Trigger saved!", Toast.LENGTH_SHORT).show()
        }
        finish()
    }

    private fun getSelectedDays(): Set<Int> {
        val selectedDays = mutableSetOf<Int>()
        for (i in 0 until dayOfWeekChipGroup.childCount) {
            val chip = dayOfWeekChipGroup.getChildAt(i) as com.google.android.material.chip.Chip
            if (chip.isChecked) {
                // Mapping index to Calendar.DAY_OF_WEEK constants (Sunday=1, Monday=2, etc.)
                selectedDays.add(i + 1)
            }
        }
        return selectedDays
    }

    private fun showExactAlarmPermissionDialog() {
        val dialog = androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Permission Required")
            .setMessage("To schedule tasks at a precise time, Panda needs the 'Alarms & Reminders' permission. Please grant this in the next screen.")
            .setPositiveButton("Grant Permission") { _, _ ->
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
                    startActivity(android.content.Intent(android.provider.Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM))
                }
            }
            .setNegativeButton("Cancel", null)
            .show()

        dialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE).setTextColor(getColor(R.color.white))
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ui/TriggerAdapter.kt
================================================
package com.blurr.voice.triggers.ui

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.widget.SwitchCompat
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.R
import com.blurr.voice.triggers.Trigger
import com.blurr.voice.triggers.TriggerType
import java.util.Locale

class TriggerAdapter(
    private val triggers: MutableList<Trigger>,
    private val onCheckedChange: (Trigger, Boolean) -> Unit,
    private val onDeleteClick: (Trigger) -> Unit,
    private val onEditClick: (Trigger) -> Unit
) : RecyclerView.Adapter<TriggerAdapter.TriggerViewHolder>() {

    private var interactionsEnabled: Boolean = true

    fun setInteractionsEnabled(enabled: Boolean) {
        this.interactionsEnabled = enabled
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TriggerViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_trigger, parent, false)
        return TriggerViewHolder(view)
    }

    override fun onBindViewHolder(holder: TriggerViewHolder, position: Int) {
        val trigger = triggers[position]
        holder.bind(trigger)
    }

    override fun getItemCount(): Int = triggers.size

    fun updateTriggers(newTriggers: List<Trigger>) {
        triggers.clear()
        triggers.addAll(newTriggers)
        notifyDataSetChanged()
    }

    inner class TriggerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val instructionTextView: TextView = itemView.findViewById(R.id.triggerInstructionTextView)
        private val timeTextView: TextView = itemView.findViewById(R.id.triggerTimeTextView)
        private val enabledSwitch: SwitchCompat = itemView.findViewById(R.id.triggerEnabledSwitch)
        private val deleteButton: android.widget.ImageButton = itemView.findViewById(R.id.deleteTriggerButton)
        private val editButton: android.widget.ImageButton = itemView.findViewById(R.id.editTriggerButton)

        fun bind(trigger: Trigger) {
            instructionTextView.text = trigger.instruction

            deleteButton.setOnClickListener {
                onDeleteClick(trigger)
            }

            editButton.setOnClickListener {
                onEditClick(trigger)
            }

            when (trigger.type) {
                TriggerType.SCHEDULED_TIME -> {
                    timeTextView.text = String.format(
                        Locale.getDefault(),
                        "At %02d:%02d",
                        trigger.hour ?: 0,
                        trigger.minute ?: 0
                    )
                }
                TriggerType.NOTIFICATION -> {
                    timeTextView.text = "On notification from ${trigger.appName}"
                }

                TriggerType.CHARGING_STATE -> {
                    timeTextView.text = "battery state"
                }
            }

            enabledSwitch.setOnCheckedChangeListener(null) // Avoid triggering listener during bind
            enabledSwitch.isChecked = trigger.isEnabled
            enabledSwitch.setOnCheckedChangeListener { _, isChecked ->
                onCheckedChange(trigger, isChecked)
            }

            enabledSwitch.isEnabled = interactionsEnabled
            deleteButton.isEnabled = interactionsEnabled
            editButton.isEnabled = interactionsEnabled
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/triggers/ui/TriggersActivity.kt
================================================
package com.blurr.voice.triggers.ui

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.graphics.Color
import android.os.Bundle
import android.provider.Settings
import android.widget.CheckBox
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import com.blurr.voice.BaseNavigationActivity
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.blurr.voice.R
import com.blurr.voice.triggers.TriggerManager
import com.blurr.voice.triggers.TriggerMonitoringService
import com.blurr.voice.triggers.TriggerType
import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton

class TriggersActivity : BaseNavigationActivity() {

    private lateinit var triggerManager: TriggerManager
    private lateinit var triggerAdapter: TriggerAdapter
    private lateinit var enableTriggersCheckbox: CheckBox
    private lateinit var triggersNotWorkingText: TextView
    private lateinit var addTriggerFab: ExtendedFloatingActionButton
    private lateinit var triggersRecyclerView: RecyclerView

    private lateinit var sharedPreferences: SharedPreferences

    companion object {
        const val PREFS_NAME = "TriggerPrefs"
        const val KEY_TRIGGERS_ENABLED = "triggers_enabled"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_triggers)

        val toolbar = findViewById<androidx.appcompat.widget.Toolbar>(R.id.toolbar)
        setSupportActionBar(toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)

        triggerManager = TriggerManager.getInstance(this)
        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        enableTriggersCheckbox = findViewById(R.id.enable_triggers_checkbox)
        triggersNotWorkingText = findViewById(R.id.triggers_not_working_text)
        addTriggerFab = findViewById(R.id.addTriggerFab)
        triggersRecyclerView = findViewById(R.id.triggersRecyclerView)

        setupRecyclerView()
        setupFab()
        setupTriggerControls()
    }

    private fun setupTriggerControls() {
        val triggersEnabled = sharedPreferences.getBoolean(KEY_TRIGGERS_ENABLED, false)
        enableTriggersCheckbox.isChecked = triggersEnabled
        updateUiState(triggersEnabled)

        enableTriggersCheckbox.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                showBatteryOptimizationWarning {
                    startTriggerService()
                    sharedPreferences.edit().putBoolean(KEY_TRIGGERS_ENABLED, true).apply()
                    updateUiState(true)
                }
            } else {
                stopTriggerService()
                sharedPreferences.edit().putBoolean(KEY_TRIGGERS_ENABLED, false).apply()
                updateUiState(false)
            }
        }

        triggersNotWorkingText.setOnClickListener {
            showBatteryOptimizationWarning {}
        }
    }

    private fun updateUiState(enabled: Boolean) {
        triggersRecyclerView.alpha = if (enabled) 1.0f else 0.5f
        addTriggerFab.isEnabled = enabled
        triggerAdapter.setInteractionsEnabled(enabled)
    }


    private fun showBatteryOptimizationWarning(onAcknowledge: () -> Unit) {
        val dialog = AlertDialog.Builder(this)
            .setTitle("Vendor Battery Optimization")
            .setMessage("Your vendor might not support Panda background trigger monitoring. To ensure Panda works properly, please disable any kind of battery optimization for the app.")
            .setPositiveButton("OK") { dialog, _ ->
                onAcknowledge()
                dialog.dismiss()
            }
            .show()

        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(Color.parseColor("#4CAF50"))
    }

    private fun startTriggerService() {
        val serviceIntent = Intent(this, TriggerMonitoringService::class.java)
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent)
        } else {
            startService(serviceIntent)
        }
    }

    private fun stopTriggerService() {
        val serviceIntent = Intent(this, TriggerMonitoringService::class.java)
        stopService(serviceIntent)
    }


    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }

    override fun onResume() {
        super.onResume()
        loadTriggers()
        checkNotificationPermission()
    }

    private fun checkNotificationPermission() {
        val hasNotificationTriggers = triggerManager.getTriggers().any { it.type == TriggerType.NOTIFICATION && it.isEnabled }
        if (hasNotificationTriggers && !com.blurr.voice.triggers.PermissionUtils.isNotificationListenerEnabled(this)) {
            showPermissionDialog()
        }
    }

    private fun showPermissionDialog() {
        val dialog = AlertDialog.Builder(this)
            .setTitle("Permission Required")
            .setMessage("To use notification-based triggers, you need to grant Panda the Notification Listener permission in your system settings.")
            .setPositiveButton("Grant Permission") { _, _ ->
                startActivity(Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS))
            }
            .setNegativeButton("Cancel", null)
            .show()

        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(getColor(R.color.white))
    }

    private fun setupRecyclerView() {
        triggersRecyclerView.layoutManager = LinearLayoutManager(this)
        triggerAdapter = TriggerAdapter(
            mutableListOf(),
            onCheckedChange = { trigger, isEnabled ->
                trigger.isEnabled = isEnabled
                triggerManager.updateTrigger(trigger)
            },
            onDeleteClick = { trigger ->
                showDeleteConfirmationDialog(trigger)
            },
            onEditClick = { trigger ->
                val intent = Intent(this, CreateTriggerActivity::class.java).apply {
                    putExtra("EXTRA_TRIGGER_ID", trigger.id)
                }
                startActivity(intent)
            }
        )
        triggersRecyclerView.adapter = triggerAdapter
    }

    private fun showDeleteConfirmationDialog(trigger: com.blurr.voice.triggers.Trigger) {
        val dialog = AlertDialog.Builder(this)
            .setTitle("Delete Trigger")
            .setMessage("Are you sure you want to delete this trigger?")
            .setPositiveButton("Delete") { _, _ ->
                triggerManager.removeTrigger(trigger)
                loadTriggers() // Refresh the list
            }
            .setNegativeButton("Cancel", null)
            .show()

        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(getColor(R.color.white))
    }

    private fun setupFab() {
        addTriggerFab.setOnClickListener {
            startActivity(Intent(this, ChooseTriggerTypeActivity::class.java))
        }
    }

    private fun loadTriggers() {
        val triggers = triggerManager.getTriggers()
        triggerAdapter.updateTriggers(triggers)
    }
    
    override fun getContentLayoutId(): Int = R.layout.activity_triggers
    
    override fun getCurrentNavItem(): BaseNavigationActivity.NavItem = BaseNavigationActivity.NavItem.TRIGGERS
}



================================================
FILE: app/src/main/java/com/blurr/voice/ui/DeltaSymbolView.kt
================================================
package com.blurr.voice.views

import android.animation.ValueAnimator
import android.content.Context
import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.Path
import android.util.AttributeSet
import android.view.View
import android.view.animation.AccelerateDecelerateInterpolator
import androidx.core.content.ContextCompat
import com.blurr.voice.R
import kotlin.math.sqrt

class DeltaSymbolView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private var glowAnimator: ValueAnimator? = null
    // 1. Define stroke widths based on your request (0.3dp and 0.6dp)
    private val thinStrokeWidthPx = 0.75f * resources.displayMetrics.density
    private val thickStrokeWidthPx = 2f * resources.displayMetrics.density

    // Create three separate paint objects for each side
    private val leftPaint = createStrokePaint(thinStrokeWidthPx)
    private val bottomPaint = createStrokePaint(thinStrokeWidthPx)
    private val rightPaint = createStrokePaint(thickStrokeWidthPx)
    private val allPaints = listOf(leftPaint, bottomPaint, rightPaint)

    // Create three separate paths for each side
    private val leftPath = Path()
    private val bottomPath = Path()
    private val rightPath = Path()
    private val allPaths = listOf(leftPath, bottomPath, rightPath)

    private var currentGlowRadius = MIN_GLOW_RADIUS

    private companion object {
        const val ANIMATION_DURATION = 1500L
        const val MIN_GLOW_RADIUS = 10f
        const val MAX_GLOW_RADIUS = 30f
        const val START_SCALE = 1.0f
        const val END_SCALE = 1.05f
        // 2. Define a fixed side length for the equilateral triangle in DP
        const val SIDE_LENGTH_DP = 250f
    }

    init {
        setLayerType(LAYER_TYPE_SOFTWARE, null)
    }

    private fun createStrokePaint(strokeWidth: Float): Paint {
        return Paint(Paint.ANTI_ALIAS_FLAG).apply {
            style = Paint.Style.STROKE
            this.strokeWidth = strokeWidth
            color = ContextCompat.getColor(context, R.color.delta_idle)
            // Use ROUND caps to make the corners where paths meet look better
            strokeCap = Paint.Cap.ROUND
        }
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)

        // 3. Calculate triangle dimensions based on the fixed DP size
        val sideLengthPx = SIDE_LENGTH_DP * resources.displayMetrics.density
        val triangleHeight = sideLengthPx * sqrt(3f) / 2f

        // Center the fixed-size triangle within the view
        val centerX = w / 2f
        val centerY = h / 2f

        val topPoint = Pair(centerX, centerY - triangleHeight / 2f)
        val bottomLeftPoint = Pair(centerX - sideLengthPx / 2f, centerY + triangleHeight / 2f)
        val bottomRightPoint = Pair(centerX + sideLengthPx / 2f, centerY + triangleHeight / 2f)

        // Update the path for the left side
        leftPath.reset()
        leftPath.moveTo(topPoint.first, topPoint.second)
        leftPath.lineTo(bottomLeftPoint.first, bottomLeftPoint.second)

        // Update the path for the bottom side
        bottomPath.reset()
        bottomPath.moveTo(bottomLeftPoint.first, bottomLeftPoint.second)
        bottomPath.lineTo(bottomRightPoint.first, bottomRightPoint.second)

        // Update the path for the right side
        rightPath.reset()
        rightPath.moveTo(bottomRightPoint.first, bottomRightPoint.second)
        rightPath.lineTo(topPoint.first, topPoint.second)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // 4. Draw each side with its corresponding path and paint
        canvas.drawPath(leftPath, leftPaint)
        canvas.drawPath(bottomPath, bottomPaint)
        canvas.drawPath(rightPath, rightPaint)
    }

    fun setColor(color: Int) {
        allPaints.forEach { it.color = color }
        if (glowAnimator?.isRunning == true) {
            allPaints.forEach { it.setShadowLayer(currentGlowRadius, 0f, 0f, color) }
        }
        invalidate()
    }

    fun startGlow() {
        if (glowAnimator?.isRunning == true) {
            return
        }

        glowAnimator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = ANIMATION_DURATION
            interpolator = AccelerateDecelerateInterpolator()
            repeatCount = ValueAnimator.INFINITE
            repeatMode = ValueAnimator.REVERSE

            addUpdateListener { animator ->
                val fraction = animator.animatedValue as Float
                val glowRadius = MIN_GLOW_RADIUS + (MAX_GLOW_RADIUS - MIN_GLOW_RADIUS) * fraction
                currentGlowRadius = glowRadius

                // Animate glow and scale on all three paints
                allPaints.forEach { it.setShadowLayer(glowRadius, 0f, 0f, it.color) }

//                val scale = START_SCALE + (END_SCALE - START_SCALE) * fraction
//                scaleX = scale
//                scaleY = scale

                invalidate()
            }
        }
        glowAnimator?.start()
    }

    fun stopGlow() {
        glowAnimator?.cancel()
        glowAnimator = null

        // Reset all three paints
        allPaints.forEach { it.clearShadowLayer() }
        scaleX = 1.0f
        scaleY = 1.0f
        currentGlowRadius = MIN_GLOW_RADIUS
        invalidate()
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        stopGlow()
    }
}




================================================
FILE: app/src/main/java/com/blurr/voice/ui/SmallDeltaGlowView.kt
================================================
package com.blurr.voice.ui

import android.animation.ValueAnimator
import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Path
import android.util.AttributeSet
import android.view.View
import android.view.animation.AccelerateDecelerateInterpolator
import androidx.core.content.ContextCompat
import com.blurr.voice.R
import kotlin.math.sqrt

class SmallDeltaGlowView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    // Paint for the circular black background
    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
//        style = Paint.Style.FILL
        color = Color.BLACK
        alpha = 255
    }

    // Adjusted stroke widths for a smaller size
    private val thinStrokeWidthPx = 0.6f * resources.displayMetrics.density
    private val thickStrokeWidthPx = 1.5f * resources.displayMetrics.density

    // Paint objects for each side of the delta
    private val leftPaint = createStrokePaint(thinStrokeWidthPx)
    private val bottomPaint = createStrokePaint(thinStrokeWidthPx)
    private val rightPaint = createStrokePaint(thickStrokeWidthPx)
    private val allPaints = listOf(leftPaint, bottomPaint, rightPaint)

    // Path objects for each side of the delta
    private val leftPath = Path()
    private val bottomPath = Path()
    private val rightPath = Path()

    // Animation properties
    private var glowAnimator: ValueAnimator? = null
    private var currentGlowRadius = MIN_GLOW_RADIUS

    companion object {
        private const val ANIMATION_DURATION = 1500L
        // Adjusted glow radius for a smaller visual effect
        private const val MIN_GLOW_RADIUS = 4f
        private const val MAX_GLOW_RADIUS = 12f
        // Scale factor to determine the triangle's size relative to the view's diameter
        private const val TRIANGLE_SCALE_FACTOR = 0.5f
    }

    init {
        // Required for shadow layers (glow effect) to work
        setLayerType(LAYER_TYPE_SOFTWARE, null)
    }

    private fun createStrokePaint(strokeWidth: Float): Paint {
        return Paint(Paint.ANTI_ALIAS_FLAG).apply {
            style = Paint.Style.STROKE
            this.strokeWidth = strokeWidth
            color = ContextCompat.getColor(context, R.color.delta_idle)
            strokeCap = Paint.Cap.ROUND // Makes corners look smoother
        }
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)

        // Calculate triangle dimensions based on the view's size, not a fixed DP value
        val diameter = w.coerceAtMost(h).toFloat()
        val sideLengthPx = diameter * TRIANGLE_SCALE_FACTOR
        val triangleHeight = sideLengthPx * sqrt(3f) / 2f

        val centerX = w / 2f
        val centerY = h / 2f

        val topPoint = Pair(centerX, centerY - triangleHeight / 2f)
        val bottomLeftPoint = Pair(centerX - sideLengthPx / 2f, centerY + triangleHeight / 2f)
        val bottomRightPoint = Pair(centerX + sideLengthPx / 2f, centerY + triangleHeight / 2f)

        // Update the paths for each side
        leftPath.reset()
        leftPath.moveTo(topPoint.first, topPoint.second)
        leftPath.lineTo(bottomLeftPoint.first, bottomLeftPoint.second)

        bottomPath.reset()
        bottomPath.moveTo(bottomLeftPoint.first, bottomLeftPoint.second)
        bottomPath.lineTo(bottomRightPoint.first, bottomRightPoint.second)

        rightPath.reset()
        rightPath.moveTo(bottomRightPoint.first, bottomRightPoint.second)
        rightPath.lineTo(topPoint.first, topPoint.second)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        val centerX = width / 2f
        val centerY = height / 2f
        val radius = width.coerceAtMost(height) / 2f

        // 1. Draw the circular background first
        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)

        // 2. Draw the delta symbol on top
        canvas.drawPath(leftPath, leftPaint)
        canvas.drawPath(bottomPath, bottomPaint)
        canvas.drawPath(rightPath, rightPaint)
    }

    fun setColor(color: Int) {
        allPaints.forEach { it.color = color }
        if (glowAnimator?.isRunning == true) {
            allPaints.forEach { it.setShadowLayer(currentGlowRadius, 0f, 0f, color) }
        }
        invalidate()
    }

    fun startGlow() {
        if (glowAnimator?.isRunning == true) return

        glowAnimator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = ANIMATION_DURATION
            interpolator = AccelerateDecelerateInterpolator()
            repeatCount = ValueAnimator.INFINITE
            repeatMode = ValueAnimator.REVERSE
            addUpdateListener { animator ->
                val fraction = animator.animatedValue as Float
                currentGlowRadius = MIN_GLOW_RADIUS + (MAX_GLOW_RADIUS - MIN_GLOW_RADIUS) * fraction
                allPaints.forEach { it.setShadowLayer(currentGlowRadius, 0f, 0f, it.color) }
                invalidate()
            }
        }
        glowAnimator?.start()
    }

    fun stopGlow() {
        glowAnimator?.cancel()
        glowAnimator = null
        allPaints.forEach { it.clearShadowLayer() }
        invalidate()
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        stopGlow() // Ensure animation is cleaned up
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/ui/theme/Color.kt
================================================
package com.blurr.voice.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)


================================================
FILE: app/src/main/java/com/blurr/voice/ui/theme/Theme.kt
================================================
package com.blurr.voice.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun BlurrTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}


================================================
FILE: app/src/main/java/com/blurr/voice/ui/theme/Type.kt
================================================
package com.blurr.voice.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/ApiKeyManager.kt
================================================
package com.blurr.voice.utilities

import com.blurr.voice.BuildConfig
import java.util.concurrent.atomic.AtomicInteger

/**
 * A thread-safe, singleton object to manage and rotate a list of API keys.
 * This ensures that every part of the app gets the next key in the sequence.
 */
object ApiKeyManager {

    private val apiKeys: List<String> = if (BuildConfig.GEMINI_API_KEYS.isNotEmpty()) {
        BuildConfig.GEMINI_API_KEYS.split(",")
    } else {
        emptyList()
    }

    private val currentIndex = AtomicInteger(0)

    /**
     * Gets the next API key from the list in a circular, round-robin fashion.
     * @return The next API key as a String.
     */
    fun getNextKey(): String {
        if (apiKeys.isEmpty()) {
            throw IllegalStateException("API key list is empty. Please add keys to ApiKeyManager.")
        }
        // Get the current index, then increment it for the next call.
        // The modulo operator (%) makes it loop back to 0 when it reaches the end.
        val index = currentIndex.getAndIncrement() % apiKeys.size
        return apiKeys[index]
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/AppContextUtility.kt
================================================
package com.blurr.voice.utilities

import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.util.Log


// TODO This fiel is not used anywhere but we still keep it because
//  this implement a agent that adds apps in the context of the agent which can be used for multiple app tasks
data class AppInfo(
    val appName: String,
    val packageName: String,
    val isSystemApp: Boolean,
    val isEnabled: Boolean,
    val versionName: String? = null,
    val versionCode: Long = 0
)

class AppContextUtility(private val context: Context) {

    companion object {
        private const val TAG = "AppListUtility"
    }

    /**
     * Get all installed applications with basic information
     */
    @SuppressLint("QueryPermissionsNeeded")
    fun getAllApps(): List<AppInfo> {
        return try {
            val pm = context.packageManager
            val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)

            apps.map { app ->
                AppInfo(
                    appName = app.loadLabel(pm).toString(),
                    packageName = app.packageName,
                    isSystemApp = (app.flags and ApplicationInfo.FLAG_SYSTEM) != 0,
                    isEnabled = app.enabled
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting all apps", e)
            emptyList()
        }
    }

    /**
     * Get only user-installed applications (non-system apps)
     */
    @SuppressLint("QueryPermissionsNeeded")
    fun getUserApps(): List<AppInfo> {
        return try {
            val pm = context.packageManager
            val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)

            apps.filter { app ->
                (app.flags and ApplicationInfo.FLAG_SYSTEM) == 0
            }.map { app ->
                AppInfo(
                    appName = app.loadLabel(pm).toString(),
                    packageName = app.packageName,
                    isSystemApp = false,
                    isEnabled = app.enabled
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting user apps", e)
            emptyList()
        }
    }

    /**
     * MAIN FUNCTION: Uses Gemini API to intelligently filter and format app data based on user instruction
     * This avoids using large context windows by letting AI determine what's relevant
     */
//    suspend fun getAppsForInstruction(userInstruction: String, includeSystemApps: Boolean = false): String {
//        return withContext(Dispatchers.IO) {
//            try {
//                // Get all apps data
//                val allApps = if (includeSystemApps) getAllApps() else getUserApps()
//                println("All apps:")
//                for(i in allApps){
//                    println(i)
//                }
//                if (allApps.isEmpty()) {
//                    return@withContext "No apps found on this device."
//                }
//
//                // Create the apps data string
//                val appsData = allApps.joinToString("\n") { app ->
//                    "Application Name: \"${app.appName}\", Package Name: \"${app.packageName}\""
//                }
//
//                // Create the prompt for Gemini API
//                val prompt = """
//                    Based on the user's instruction, analyze the following list of applications.
//                    If the user is asking to open or interact with a specific app, return only the line for that single application.
//                    If the user's instruction is general and doesn't mention a specific app, return the entire list unchanged.
//
//                    USER INSTRUCTION:
//                    "$userInstruction"
//
//                    FULL APP LIST:
//                    $appsData
//                """.trimIndent()
//
//                Log.d(TAG, "Sending request to Gemini API for instruction: $userInstruction")
//
//                // Call Gemini API
////                val response = GeminiApi.generateContent(
////                    prompt = prompt,
////                    context = context
////                )
//
////                if (response.isNullOrEmpty()) {
////                    Log.e(TAG, "Gemini API returned null or empty response")
////                    return@withContext "Error: Could not process app data. Please try again."
////                }
////
////                Log.d(TAG, "Gemini API response received: ${response.length} characters")
////
////                // Clean up the response - remove any markdown formatting or extra text
////                val cleanedResponse = response.trim()
////                    .removePrefix("```")
////                    .removeSuffix("```")
////                    .trim()
//
//                return@withContext cleanedResponse
//
//            } catch (e: Exception) {
//                Log.e(TAG, "Error getting apps for instruction: $userInstruction", e)
//                return@withContext "Error: Failed to process app data. ${e.message}"
//            }
//        }
//    }
}




================================================
FILE: app/src/main/java/com/blurr/voice/utilities/DeltaStateColorMapper.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import androidx.core.content.ContextCompat
import com.blurr.voice.R

/**
 * Utility class for mapping PandaState values to their corresponding colors
 * and providing state-related information for the delta symbol.
 */
object DeltaStateColorMapper {

    /**
     * Data class representing the visual state of the delta symbol
     */
    data class DeltaVisualState(
        val state: PandaState,
        val color: Int,
        val statusText: String,
        val colorHex: String
    )

    /**
     * Get the color resource ID for a given PandaState
     */
    fun getColorResourceId(state: PandaState): Int {
        return when (state) {
            PandaState.IDLE -> R.color.delta_idle
            PandaState.LISTENING -> R.color.delta_listening
            PandaState.PROCESSING -> R.color.delta_processing
            PandaState.SPEAKING -> R.color.delta_speaking
            PandaState.ERROR -> R.color.delta_error
        }
    }

    /**
     * Get the resolved color value for a given PandaState
     */
    fun getColor(context: Context, state: PandaState): Int {
        val colorResId = getColorResourceId(state)
        return ContextCompat.getColor(context, colorResId)
    }

    /**
     * Get the status text for a given PandaState
     */
    fun getStatusText(state: PandaState): String {
        return when (state) {
            PandaState.IDLE -> "Ready, tap delta to wake me up!"
            PandaState.LISTENING -> "Listening..."
            PandaState.PROCESSING -> "Processing..."
            PandaState.SPEAKING -> "Speaking..."
            PandaState.ERROR -> "Error"
        }
    }

    /**
     * Get the hex color string for a given PandaState (for debugging/logging)
     */
    fun getColorHex(context: Context, state: PandaState): String {
        val color = getColor(context, state)
        return String.format("#%08X", color)
    }

    /**
     * Get complete visual state information for a given PandaState
     */
    fun getDeltaVisualState(context: Context, state: PandaState): DeltaVisualState {
        return DeltaVisualState(
            state = state,
            color = getColor(context, state),
            statusText = getStatusText(state),
            colorHex = getColorHex(context, state)
        )
    }

    /**
     * Get all available states with their visual information
     */
    fun getAllStates(context: Context): List<DeltaVisualState> {
        return PandaState.values().map { state ->
            getDeltaVisualState(context, state)
        }
    }

    /**
     * Check if a state represents an active operation (not idle or error)
     */
    fun isActiveState(state: PandaState): Boolean {
        return when (state) {
            PandaState.LISTENING, PandaState.PROCESSING, PandaState.SPEAKING -> true
            PandaState.IDLE, PandaState.ERROR -> false
        }
    }

    /**
     * Check if a state represents an error condition
     */
    fun isErrorState(state: PandaState): Boolean {
        return state == PandaState.ERROR
    }

    /**
     * Get the priority of a state for determining which state to display
     * when multiple conditions might be true. Higher numbers = higher priority.
     */
    fun getStatePriority(state: PandaState): Int {
        return when (state) {
            PandaState.ERROR -> 5      // Highest priority
            PandaState.SPEAKING -> 4   // High priority
            PandaState.LISTENING -> 3  // Medium-high priority
            PandaState.PROCESSING -> 2 // Medium priority
            PandaState.IDLE -> 1       // Lowest priority
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/DeltaSymbolAnimator.kt
================================================
package com.blurr.voice.utilities

import android.animation.ArgbEvaluator
import android.animation.ValueAnimator
import android.content.Context
import android.graphics.drawable.VectorDrawable
import android.util.Log
import android.widget.ImageView
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.DrawableCompat
import com.blurr.voice.R

/**
 * Utility class for animating the delta symbol with smooth color transitions
 * based on PandaState changes.
 */
class DeltaSymbolAnimator(private val context: Context) {

    companion object {
        private const val TAG = "DeltaSymbolAnimator"
        private const val ANIMATION_DURATION = 300L // 300ms for smooth transitions
    }

    private var currentAnimator: ValueAnimator? = null
    private var currentColor: Int = ContextCompat.getColor(context, R.color.delta_idle)

    /**
     * Animate the delta symbol to the color associated with the given state
     */
    fun animateToState(imageView: ImageView, state: PandaState) {
        val targetColor = getColorForState(state)
        animateColorTransition(imageView, currentColor, targetColor)
        currentColor = targetColor
    }

    /**
     * Set the delta symbol color immediately without animation
     */
    fun setStateColor(imageView: ImageView, state: PandaState) {
        val color = getColorForState(state)
        applyColorToImageView(imageView, color)
        currentColor = color
    }

    /**
     * Get the color associated with a specific PandaState
     */
    private fun getColorForState(state: PandaState): Int {
        return when (state) {
            PandaState.IDLE -> ContextCompat.getColor(context, R.color.delta_idle)
            PandaState.LISTENING -> ContextCompat.getColor(context, R.color.delta_listening)
            PandaState.PROCESSING -> ContextCompat.getColor(context, R.color.delta_processing)
            PandaState.SPEAKING -> ContextCompat.getColor(context, R.color.delta_speaking)
            PandaState.ERROR -> ContextCompat.getColor(context, R.color.delta_error)
        }
    }

    /**
     * Animate smooth color transition between two colors
     */
    private fun animateColorTransition(imageView: ImageView, fromColor: Int, toColor: Int) {
        // Cancel any existing animation
        currentAnimator?.cancel()

        if (fromColor == toColor) {
            Log.d(TAG, "Colors are the same, skipping animation")
            return
        }

        Log.d(TAG, "Animating color transition from ${Integer.toHexString(fromColor)} to ${Integer.toHexString(toColor)}")

        currentAnimator = ValueAnimator.ofObject(ArgbEvaluator(), fromColor, toColor).apply {
            duration = ANIMATION_DURATION
            
            addUpdateListener { animator ->
                val animatedColor = animator.animatedValue as Int
                applyColorToImageView(imageView, animatedColor)
            }
            
            start()
        }
    }

    /**
     * Apply color to the ImageView's drawable
     */
    private fun applyColorToImageView(imageView: ImageView, color: Int) {
        try {
            val drawable = imageView.drawable
            if (drawable != null) {
                val wrappedDrawable = DrawableCompat.wrap(drawable).mutate()
                DrawableCompat.setTint(wrappedDrawable, color)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error applying color to ImageView", e)
        }
    }

    /**
     * Clean up resources and cancel any running animations
     */
    fun cleanup() {
        currentAnimator?.cancel()
        currentAnimator = null
    }

    /**
     * Get the current color being displayed
     */
    fun getCurrentColor(): Int = currentColor
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/DeltaSymbolTestUtil.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.util.Log

/**
 * Utility class for testing delta symbol functionality
 */
object DeltaSymbolTestUtil {
    
    private const val TAG = "DeltaSymbolTestUtil"
    
    /**
     * Test all state color mappings and log the results
     */
    fun testStateColorMappings(context: Context) {
        Log.d(TAG, "Testing delta symbol state color mappings:")
        
        PandaState.values().forEach { state ->
            val visualState = DeltaStateColorMapper.getDeltaVisualState(context, state)
            Log.d(TAG, "State: ${state.name}")
            Log.d(TAG, "  Color: ${visualState.colorHex}")
            Log.d(TAG, "  Status Text: ${visualState.statusText}")
            Log.d(TAG, "  Is Active: ${DeltaStateColorMapper.isActiveState(state)}")
            Log.d(TAG, "  Priority: ${DeltaStateColorMapper.getStatePriority(state)}")
            Log.d(TAG, "  ---")
        }
    }
    
    /**
     * Test state transitions and verify they work correctly
     */
    fun testStateTransitions(context: Context) {
        Log.d(TAG, "Testing state transitions:")
        
        val stateManager = PandaStateManager.getInstance(context)
        val currentState = stateManager.getCurrentState()
        val visualState = stateManager.getDeltaVisualState()
        
        Log.d(TAG, "Current State: ${currentState.name}")
        Log.d(TAG, "Current Color: ${visualState.colorHex}")
        Log.d(TAG, "Current Status: ${visualState.statusText}")
    }
    
    /**
     * Verify that all required drawable resources exist
     */
    fun verifyDrawableResources(context: Context): Boolean {
        return try {
            // Test main delta symbol
            context.getDrawable(com.blurr.voice.R.drawable.ic_delta_symbol)
            Log.d(TAG, "✓ ic_delta_symbol drawable found")
            
            // Test small delta symbol
            context.getDrawable(com.blurr.voice.R.drawable.ic_delta_small)
            Log.d(TAG, "✓ ic_delta_small drawable found")
            
            true
        } catch (e: Exception) {
            Log.e(TAG, "✗ Drawable resource verification failed", e)
            false
        }
    }
    
    /**
     * Verify that all required color resources exist
     */
    fun verifyColorResources(context: Context): Boolean {
        return try {
            PandaState.values().forEach { state ->
                val colorResId = DeltaStateColorMapper.getColorResourceId(state)
                val color = DeltaStateColorMapper.getColor(context, state)
                Log.d(TAG, "✓ Color for ${state.name}: ${String.format("#%08X", color)}")
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "✗ Color resource verification failed", e)
            false
        }
    }
    
    /**
     * Run all tests and return overall success
     */
    fun runAllTests(context: Context): Boolean {
        Log.d(TAG, "Running all delta symbol tests...")
        
        val drawableTest = verifyDrawableResources(context)
        val colorTest = verifyColorResources(context)
        
        if (drawableTest && colorTest) {
            testStateColorMappings(context)
            testStateTransitions(context)
            Log.d(TAG, "✓ All tests passed!")
            return true
        } else {
            Log.e(TAG, "✗ Some tests failed!")
            return false
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/FreemiumManager.kt
================================================
package com.blurr.voice.utilities

import android.util.Log
import com.android.billingclient.api.BillingClient
import com.android.billingclient.api.Purchase
import com.android.billingclient.api.QueryPurchasesParams
import com.android.billingclient.api.queryPurchasesAsync
import com.blurr.voice.MyApplication
import com.google.firebase.Firebase
import com.google.firebase.Timestamp
import com.google.firebase.auth.auth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withTimeoutOrNull
import java.util.Calendar

class FreemiumManager {

    private val db = Firebase.firestore
    private val auth = Firebase.auth
    private val billingClient: BillingClient = MyApplication.billingClient

    companion object {
        const val DAILY_TASK_LIMIT = 15 // Set your daily task limit here
        private const val PRO_SKU = "pro" // The SKU for the pro subscription
    }

    suspend fun getDeveloperMessage(): String {
        return try {
            val document = db.collection("settings").document("freemium").get().await()
            document.getString("developerMessage") ?: ""
        } catch (e: Exception) {
            Log.e("FreemiumManager", "Error fetching developer message from Firestore.", e)
            ""
        }
    }
    suspend fun isUserSubscribed(): Boolean {
        val currentUser = auth.currentUser ?: return false // If not logged in, not pro
        return try {
            val document = db.collection("users").document(currentUser.uid).get().await()
            if (document.exists()) {
                val plan = document.getString("plan")
                plan == "pro"
            } else {
                false // Document doesn't exist, so user can't be pro
            }
        } catch (e: Exception) {
            Logger.e("FreemiumManager", "Error checking user plan from Firestore", e)
            false // In case of error, default to not pro
        }
    }



    suspend fun provisionUserIfNeeded() {
        val currentUser = auth.currentUser ?: return
        val userDocRef = db.collection("users").document(currentUser.uid)

        try {
            val document = userDocRef.get().await()
            if (!document.exists()) {
                Logger.d("FreemiumManager", "Provisioning new user: ${currentUser.uid}")
                val newUser = hashMapOf(
                    "email" to currentUser.email,
                    "plan" to "free",
                    "createdAt" to FieldValue.serverTimestamp()
                )
                userDocRef.set(newUser).await()
            }
        } catch (e: Exception) {
            Logger.e("FreemiumManager", "Error provisioning user", e)
        }
    }

    suspend fun getTasksRemaining(): Long? {
        if (isUserSubscribed()) return Long.MAX_VALUE
        val currentUser = auth.currentUser ?: return null
        return try {
            val document = db.collection("users").document(currentUser.uid).get().await()
            document.getLong("tasksRemaining")
        } catch (e: Exception) {
            Logger.e("FreemiumManager", "Error fetching tasks remaining", e)
            null
        }
    }

    suspend fun canPerformTask(): Boolean {
        if (isUserSubscribed()) return true
        val currentUser = auth.currentUser ?: return false

        return try {
            val document = db.collection("users").document(currentUser.uid).get().await()
            val tasksRemaining = document.getLong("tasksRemaining") ?: 0
            Logger.d("FreemiumManager", "User has $tasksRemaining tasks remaining today.")
            tasksRemaining > 0
        } catch (e: Exception) {
            Logger.e("FreemiumManager", "Error fetching user task count", e)
            false
        }
    }

    suspend fun decrementTaskCount() {
        if (isUserSubscribed()) return
        val currentUser = auth.currentUser ?: return

        val userDocRef = db.collection("users").document(currentUser.uid)
        
        try {
            userDocRef.update("tasksRemaining", FieldValue.increment(-1)).await()
            Logger.d("FreemiumManager", "Successfully decremented task count for user ${currentUser.uid}.")
        } catch (e: Exception) {
            Logger.e("FreemiumManager", "Failed to decrement task count.", e)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/LLMHelperFunctions.kt
================================================
package com.blurr.voice.utilities

import android.graphics.Bitmap
import com.blurr.voice.api.GeminiApi
import com.google.ai.client.generativeai.type.ImagePart
import com.google.ai.client.generativeai.type.TextPart

fun addResponse(
    role: String,
    prompt: String,
    chatHistory: List<Pair<String, List<Any>>>,
    imageBitmap: Bitmap? = null // MODIFIED: Accepts a Bitmap directly
): List<Pair<String, List<Any>>> {
    val updatedChat = chatHistory.toMutableList()

    val messageParts = mutableListOf<Any>()
    messageParts.add(TextPart(prompt))

    if (imageBitmap != null) {
        messageParts.add(ImagePart(imageBitmap))
    }

    updatedChat.add(Pair(role, messageParts))
    return updatedChat
}

fun addResponsePrePost(
    role: String,
    prompt: String,
    chatHistory: List<Pair<String, List<Any>>>,
    imageBefore: Bitmap? = null, // MODIFIED: Accepts a Bitmap
    imageAfter: Bitmap? = null  // MODIFIED: Accepts a Bitmap
): List<Pair<String, List<Any>>> {
    val updatedChat = chatHistory.toMutableList()
    val messageParts = mutableListOf<Any>()

    messageParts.add(TextPart(prompt))

    // Attach "before" image directly if available
    imageBefore?.let {
        messageParts.add(ImagePart(it))
    }

    // Attach "after" image directly if available
    imageAfter?.let {
        messageParts.add(ImagePart(it))
    }

    updatedChat.add(Pair(role, messageParts))
    return updatedChat
}

suspend fun getReasoningModelApiResponse(
    chat: List<Pair<String, List<Any>>>,
): String? {
    return GeminiApi.generateContent(chat) // MODIFIED: Pass agent state
}




================================================
FILE: app/src/main/java/com/blurr/voice/utilities/Logger.kt
================================================
package com.blurr.voice.utilities

import android.util.Log
import com.blurr.voice.BuildConfig

object Logger {
    private const val DEFAULT_TAG = "BlurrVoice"
    
    // Enable logging based on build configuration
    private val isLoggingEnabled = BuildConfig.ENABLE_LOGGING
    
    fun d(tag: String = DEFAULT_TAG, message: String) {
        if (isLoggingEnabled) {
            Log.d(tag, message)
        }
    }
    
    fun i(tag: String = DEFAULT_TAG, message: String) {
        if (isLoggingEnabled) {
            Log.i(tag, message)
        }
    }
    
    fun w(tag: String = DEFAULT_TAG, message: String) {
        if (isLoggingEnabled) {
            Log.w(tag, message)
        }
    }
    
    fun e(tag: String = DEFAULT_TAG, message: String, throwable: Throwable? = null) {
        if (isLoggingEnabled) {
            if (throwable != null) {
                Log.e(tag, message, throwable)
            } else {
                Log.e(tag, message)
            }
        }
    }
    
    fun v(tag: String = DEFAULT_TAG, message: String) {
        if (isLoggingEnabled) {
            Log.v(tag, message)
        }
    }
    
    fun wtf(tag: String = DEFAULT_TAG, message: String, throwable: Throwable? = null) {
        if (isLoggingEnabled) {
            if (throwable != null) {
                Log.wtf(tag, message, throwable)
            } else {
                Log.wtf(tag, message)
            }
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/NetworkConnectivityManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.os.Build
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import kotlinx.coroutines.withTimeoutOrNull
import java.io.IOException
import java.net.URL
import java.net.URLConnection

/**
 * Utility class to handle network connectivity checks and provide a clean API
 * for the rest of the app to check internet connectivity.
 */
class NetworkConnectivityManager(private val context: Context) {
    
    companion object {
        private const val TAG = "NetworkConnectivityManager"
        private const val CONNECTIVITY_TIMEOUT_MS = 5000L // 5 seconds timeout
        private const val TEST_URL = "https://www.google.com" // URL to test connectivity
    }
    
    private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    
    /**
     * Check if the device has an active internet connection
     * @return true if internet is available, false otherwise
     */
    suspend fun isNetworkAvailable(): Boolean = withContext(Dispatchers.IO) {
        val sc = SpeechCoordinator.getInstance(context)

        try {

            // First check if network is connected
            if (!isNetworkConnected()) {
                sc.speakText("Network is not connected")
                Log.d(TAG, "Network is not connected")
                return@withContext false
            }

            // Then check if internet is actually accessible
            return@withContext checkInternetConnectivity()
        } catch (e: Exception) {
            sc.speakText("Network is not connected")
            Log.e(TAG, "Error checking network availability", e)
            return@withContext false
        }
    }
    
    /**
     * Check if network is connected (doesn't guarantee internet access)
     */
    private fun isNetworkConnected(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = connectivityManager.activeNetwork
            val networkCapabilities = connectivityManager.getNetworkCapabilities(network)
            networkCapabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true &&
                    networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
        } else {
            @Suppress("DEPRECATION")
            val networkInfo = connectivityManager.activeNetworkInfo
            networkInfo?.isConnected == true
        }
    }
    
    /**
     * Check if internet is actually accessible by trying to connect to a test URL
     */
    private suspend fun checkInternetConnectivity(): Boolean = withTimeoutOrNull(CONNECTIVITY_TIMEOUT_MS) {
        try {
            val url = URL(TEST_URL)
            val connection: URLConnection = url.openConnection()
            connection.connectTimeout = 3000
            connection.readTimeout = 3000
            connection.connect()
            Log.d(TAG, "Internet connectivity confirmed")
            true
        } catch (e: IOException) {
            Log.d(TAG, "Internet connectivity check failed: ${e.message}")
            false
        } catch (e: Exception) {
            Log.e(TAG, "Unexpected error during internet connectivity check", e)
            false
        }
    } ?: false
    
    /**
     * Check network connectivity with a timeout and return detailed result
     */
    suspend fun checkConnectivityWithTimeout(timeoutMs: Long = CONNECTIVITY_TIMEOUT_MS): ConnectivityResult {
        return try {
            withTimeout(timeoutMs) {
                val isAvailable = isNetworkAvailable()
                if (isAvailable) {
                    ConnectivityResult.Success
                } else {
                    ConnectivityResult.NoInternet
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Connectivity check failed with timeout", e)
            ConnectivityResult.Timeout
        }
    }
    
    /**
     * Register a network callback to listen for network state changes
     */
    fun registerNetworkCallback(callback: NetworkCallback) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            val networkRequest = NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build()
            
            connectivityManager.registerNetworkCallback(networkRequest, object : ConnectivityManager.NetworkCallback() {
                override fun onAvailable(network: Network) {
                    Log.d(TAG, "Network became available")
                    callback.onNetworkAvailable()
                }
                
                override fun onLost(network: Network) {
                    Log.d(TAG, "Network became unavailable")
                    callback.onNetworkLost()
                }
            })
        }
    }
    
    /**
     * Unregister network callback
     */
    fun unregisterNetworkCallback(callback: ConnectivityManager.NetworkCallback) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }
    
    /**
     * Result of connectivity check
     */
    sealed class ConnectivityResult {
        object Success : ConnectivityResult()
        object NoInternet : ConnectivityResult()
        object Timeout : ConnectivityResult()
    }
    
    /**
     * Callback interface for network state changes
     */
    interface NetworkCallback {
        fun onNetworkAvailable()
        fun onNetworkLost()
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/NetworkNotifier.kt
================================================
package com.blurr.voice.utilities

import android.os.Handler
import android.os.Looper
import android.widget.Toast
import android.util.Log
import com.blurr.voice.MyApplication

/**
 * Shows a user-facing offline notification (toast) and speaks a short TTS message.
 * Debounced to avoid spamming the user when multiple calls occur in a short time.
 */
object NetworkNotifier {

    private const val TAG = "NetworkNotifier"
    private const val MIN_INTERVAL_MS = 10_000L // 10 seconds
    @Volatile private var lastNotifiedAt: Long = 0L

    suspend fun notifyOffline(message: String = defaultMessage) {
        val now = System.currentTimeMillis()
        if (now - lastNotifiedAt < MIN_INTERVAL_MS) {
            Log.d(TAG, "Skipping offline notify due to debounce interval")
            return
        }
        lastNotifiedAt = now

        val context = MyApplication.appContext

        // Show a toast popup on the main thread
        Handler(Looper.getMainLooper()).post {
            Toast.makeText(
                context,
                "No internet connection. Panda won’t be able to help right now.",
                Toast.LENGTH_LONG
            ).show()
        }

        try {
            // Speak out loud via TTS
            val tts = TTSManager.getInstance(context)
            tts.speakText(message)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to speak offline message", e)
        }
    }

    private const val defaultMessage =
        "It looks like the internet is offline. I won’t be able to help right now. Please try again later."
}





================================================
FILE: app/src/main/java/com/blurr/voice/utilities/OnboardingManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.content.SharedPreferences

class OnboardingManager(context: Context) {

    private val sharedPreferences: SharedPreferences =
        context.getSharedPreferences("onboarding_prefs", Context.MODE_PRIVATE)

    companion object {
        private const val KEY_ONBOARDING_COMPLETED = "onboarding_completed"
    }

    fun isOnboardingCompleted(): Boolean {
        return sharedPreferences.getBoolean(KEY_ONBOARDING_COMPLETED, false)
    }

    fun setOnboardingCompleted(completed: Boolean) {
        sharedPreferences.edit().putBoolean(KEY_ONBOARDING_COMPLETED, completed).apply()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/PandaState.kt
================================================
package com.blurr.voice.utilities

/**
 * Represents the different states of the Panda app for visual feedback
 */
enum class PandaState {
    /**
     * App is ready and idle, no active conversation or processing
     */
    IDLE,
    
    /**
     * App is actively listening for user input via STT
     */
    LISTENING,
    
    /**
     * App is processing user request (thinking/reasoning)
     */
    PROCESSING,
    
    /**
     * App is speaking to the user via TTS
     */
    SPEAKING,
    
    /**
     * App encountered an error (STT errors, service issues, etc.)
     */
    ERROR
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/PandaStateManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.util.Log
import com.blurr.voice.ConversationalAgentService
import java.util.concurrent.CopyOnWriteArrayList

/**
 * Manages the state of the Panda app and provides callbacks for state changes.
 * This class monitors various service components to determine the current app state.
 */
class PandaStateManager private constructor(private val context: Context) {

    companion object {
        private const val TAG = "PandaStateManager"
        
        @Volatile private var INSTANCE: PandaStateManager? = null

        fun getInstance(context: Context): PandaStateManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: PandaStateManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    private val mainHandler = Handler(Looper.getMainLooper())
    private val speechCoordinator by lazy { SpeechCoordinator.getInstance(context) }
    private val visualFeedbackManager by lazy { VisualFeedbackManager.getInstance(context) }
    
    // State management
    private var currentState: PandaState = PandaState.IDLE
    private var hasRecentError: Boolean = false
    private var errorClearRunnable: Runnable? = null
    
    // Listeners for state changes
    private val stateChangeListeners = CopyOnWriteArrayList<(PandaState) -> Unit>()
    
    // Monitoring flags
    private var isMonitoring = false
    private var monitoringRunnable: Runnable? = null
    
    /**
     * Add a listener for state changes
     */
    fun addStateChangeListener(listener: (PandaState) -> Unit) {
        stateChangeListeners.add(listener)
    }
    
    /**
     * Remove a state change listener
     */
    fun removeStateChangeListener(listener: (PandaState) -> Unit) {
        stateChangeListeners.remove(listener)
    }
    
    /**
     * Get the current state
     */
    fun getCurrentState(): PandaState = currentState
    
    /**
     * Start monitoring service states and updating the current state
     */
    fun startMonitoring() {
        if (isMonitoring) {
            Log.d(TAG, "Already monitoring, skipping start")
            return
        }
        
        isMonitoring = true
        Log.d(TAG, "Starting state monitoring")
        
        // Start periodic state checking
        scheduleStateUpdate()
    }
    
    /**
     * Stop monitoring service states
     */
    fun stopMonitoring() {
        if (!isMonitoring) {
            return
        }
        
        isMonitoring = false
        Log.d(TAG, "Stopping state monitoring")
        
        // Cancel scheduled updates
        monitoringRunnable?.let { mainHandler.removeCallbacks(it) }
        errorClearRunnable?.let { mainHandler.removeCallbacks(it) }
        
        // Reset to idle state
        updateState(PandaState.IDLE)
    }
    
    /**
     * Manually trigger an error state (called from service error callbacks)
     */
    fun triggerErrorState() {
        Log.d(TAG, "Error state triggered")
        hasRecentError = true
        
        // Clear error flag after 5 seconds
        errorClearRunnable?.let { mainHandler.removeCallbacks(it) }
        errorClearRunnable = Runnable {
            hasRecentError = false
            Log.d(TAG, "Error flag cleared")
            updateStateFromServices()
        }
        mainHandler.postDelayed(errorClearRunnable!!, 5000)
        
        updateStateFromServices()
    }
    
    /**
     * Schedule the next state update check
     */
    private fun scheduleStateUpdate() {
        if (!isMonitoring) return
        
        monitoringRunnable = Runnable {
            updateStateFromServices()
            scheduleStateUpdate() // Schedule next update
        }
        
        // Check state every 200ms for responsive updates
        mainHandler.postDelayed(monitoringRunnable!!, 200)
    }
    
    /**
     * Update the current state based on service states
     */
    private fun updateStateFromServices() {
        if (!isMonitoring) return
        
        val newState = determineCurrentState()
        
        if (newState != currentState) {
            Log.d(TAG, "State changed from $currentState to $newState")
            updateState(newState)
        }
    }
    
    /**
     * Determine the current state based on service conditions
     */
    private fun determineCurrentState(): PandaState {
        return when {
            // Error state takes highest priority
            hasRecentError -> PandaState.ERROR
            
            // Service not running means idle
            !ConversationalAgentService.isRunning -> PandaState.IDLE
            
            // Speaking state (TTS active)
            speechCoordinator.isCurrentlySpeaking() -> PandaState.SPEAKING
            
            // Listening state (STT active)
            speechCoordinator.isCurrentlyListening() -> PandaState.LISTENING
            
            // Processing state (thinking indicator visible)
            isThinkingIndicatorVisible() -> PandaState.PROCESSING
            
            // Default to idle if service is running but no active operations
            else -> PandaState.IDLE
        }
    }
    
    /**
     * Check if thinking indicator is currently visible
     * This is a proxy for determining if the app is in processing state
     */
    private fun isThinkingIndicatorVisible(): Boolean {
        // We use reflection to check if the thinking indicator is visible
        // since VisualFeedbackManager doesn't expose this state directly
        return try {
            val field = VisualFeedbackManager::class.java.getDeclaredField("thinkingIndicatorView")
            field.isAccessible = true
            val thinkingIndicatorView = field.get(visualFeedbackManager)
            thinkingIndicatorView != null
        } catch (e: Exception) {
            Log.w(TAG, "Could not check thinking indicator visibility: ${e.message}")
            false
        }
    }
    
    /**
     * Update the current state and notify listeners
     */
    private fun updateState(newState: PandaState) {
        val previousState = currentState
        currentState = newState
        
        Log.d(TAG, "State updated: $previousState -> $newState")
        
        // Notify all listeners on the main thread
        mainHandler.post {
            stateChangeListeners.forEach { listener ->
                try {
                    listener(newState)
                } catch (e: Exception) {
                    Log.e(TAG, "Error notifying state change listener", e)
                }
            }
        }
    }
    
    /**
     * Get a human-readable status text for the current state
     */
    fun getStatusText(): String {
        return when (currentState) {
            PandaState.IDLE -> "Ready"
            PandaState.LISTENING -> "Listening..."
            PandaState.PROCESSING -> "Processing..."
            PandaState.SPEAKING -> "Speaking..."
            PandaState.ERROR -> "Error"
        }
    }
    
    /**
     * Get the color associated with the current state
     */
    fun getStateColor(): Int {
        return DeltaStateColorMapper.getColor(context, currentState)
    }
    
    /**
     * Get the complete visual state information for the current state
     */
    fun getDeltaVisualState(): DeltaStateColorMapper.DeltaVisualState {
        return DeltaStateColorMapper.getDeltaVisualState(context, currentState)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/PermissionManager.kt
================================================
package com.blurr.voice.utilities

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.text.TextUtils
import android.util.Log
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.blurr.voice.ScreenInteractionService

/**
 * Utility class to handle all permission-related functionality
 */
class PermissionManager(private val activity: AppCompatActivity) {

        private var permissionLauncher: ActivityResultLauncher<String>? = null
        private var onPermissionResult: ((String, Boolean) -> Unit)? = null

    /**
     * NEW: Checks if all essential permissions are granted.
     */
    fun areAllPermissionsGranted(): Boolean {
        return isAccessibilityServiceEnabled() &&
                isMicrophonePermissionGranted() &&
                isOverlayPermissionGranted() &&
                isNotificationPermissionGranted()
    }

        /**
         * Initialize the permission launcher
         */
        fun initializePermissionLauncher() {
                permissionLauncher = activity.registerForActivityResult(
                    androidx.activity.result.contract.ActivityResultContracts.RequestPermission()
                ) { isGranted: Boolean ->
                        val permission = onPermissionResult?.let { callback ->
                            callback("", isGranted)
                        }
                        
                        if (isGranted) {
                            Log.i("PermissionManager", "Permission GRANTED.")
                            Toast.makeText(activity, "Permission granted!", Toast.LENGTH_SHORT).show()
                        } else {
                            Log.w("PermissionManager", "Permission DENIED.")
                            Toast.makeText(activity, "Permission denied. Some features may not work properly.", Toast.LENGTH_LONG).show()
                        }
                    }
            }

        /**
         * Request notification permission (Android 13+)
         */
        fun requestNotificationPermission() {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        when {
                            ContextCompat.checkSelfPermission(activity, Manifest.permission.POST_NOTIFICATIONS) ==
                                    PackageManager.PERMISSION_GRANTED -> {
                                Log.i("PermissionManager", "Notification permission is already granted.")
                            }
                            activity.shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
                                Log.w("PermissionManager", "Showing rationale and requesting notification permission.")
                                permissionLauncher?.launch(Manifest.permission.POST_NOTIFICATIONS)
                            }
                            else -> {
                                Log.i("PermissionManager", "Requesting notification permission for the first time.")
                                permissionLauncher?.launch(Manifest.permission.POST_NOTIFICATIONS)
                            }
                        }
                    }
            }

        /**
         * Request microphone permission for voice input
         */
        fun requestMicrophonePermission() {
                when {
                        ContextCompat.checkSelfPermission(activity, Manifest.permission.RECORD_AUDIO) ==
                                PackageManager.PERMISSION_GRANTED -> {
                            Log.i("PermissionManager", "Microphone permission is already granted.")
                        }
                        activity.shouldShowRequestPermissionRationale(Manifest.permission.RECORD_AUDIO) -> {
                            Log.w("PermissionManager", "Showing rationale and requesting microphone permission.")
                            permissionLauncher?.launch(Manifest.permission.RECORD_AUDIO)
                        }
                        else -> {
                            Log.i("PermissionManager", "Requesting microphone permission for the first time.")
                            permissionLauncher?.launch(Manifest.permission.RECORD_AUDIO)
                        }
                    }
            }

        /**
         * Request all necessary permissions for the app
         */
        fun requestAllPermissions() {
                requestNotificationPermission()
                requestMicrophonePermission()
            }

        /**
         * Check if microphone permission is granted
         */
        fun isMicrophonePermissionGranted(): Boolean {
                return ContextCompat.checkSelfPermission(activity, Manifest.permission.RECORD_AUDIO) ==
                        PackageManager.PERMISSION_GRANTED
            }

        /**
         * Check if notification permission is granted
         */
        fun isNotificationPermissionGranted(): Boolean {
                return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        ContextCompat.checkSelfPermission(activity, Manifest.permission.POST_NOTIFICATIONS) ==
                                PackageManager.PERMISSION_GRANTED
                    } else {
                        true // Notification permission not required before Android 13
                    }
            }

        /**
         * Check if accessibility service is enabled
         */
        fun isAccessibilityServiceEnabled(): Boolean {
                val service = activity.packageName + "/" + ScreenInteractionService::class.java.canonicalName
                val accessibilityEnabled = Settings.Secure.getInt(
                    activity.applicationContext.contentResolver,
                    Settings.Secure.ACCESSIBILITY_ENABLED,
                    0
                )
                if (accessibilityEnabled == 1) {
                        val settingValue = Settings.Secure.getString(
                            activity.applicationContext.contentResolver,
                            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
                        )
                        if (settingValue != null) {
                            val splitter = TextUtils.SimpleStringSplitter(':')
                            splitter.setString(settingValue)
                            while (splitter.hasNext()) {
                                val componentName = splitter.next()
                                if (componentName.equals(service, ignoreCase = true)) {
                                    return true
                                }
                            }
                        }
                    }
                return false
            }

        /**
         * Open accessibility settings
         */
        fun openAccessibilitySettings() {
                val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
                activity.startActivity(intent)
            }

        /**
         * Check and request overlay permission
         */
        fun checkAndRequestOverlayPermission() {
                if (!Settings.canDrawOverlays(activity)) {
                        val intent = Intent(
                            Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                            Uri.parse("package:${activity.packageName}")
                        )
                        activity.startActivity(intent)
                    }
            }

        /**
         * Check if overlay permission is granted
         */
        fun isOverlayPermissionGranted(): Boolean {
                return Settings.canDrawOverlays(activity)
            }

        /**
         * Set callback for permission results
         */
        fun setPermissionResultCallback(callback: (String, Boolean) -> Unit) {
                onPermissionResult = callback
            }

        /**
         * Get permission status summary
         */
        fun getPermissionStatusSummary(): String {
                val status = mutableListOf<String>()
                
                if (isMicrophonePermissionGranted()) {
                        status.add("Microphone: ✓")
                    } else {
                        status.add("Microphone: ✗")
                    }
                
                if (isNotificationPermissionGranted()) {
                        status.add("Notifications: ✓")
                    } else {
                        status.add("Notifications: ✗")
                    }
                
                if (isAccessibilityServiceEnabled()) {
                        status.add("Accessibility: ✓")
                    } else {
                        status.add("Accessibility: ✗")
                    }
                
                if (isOverlayPermissionGranted()) {
                        status.add("Overlay: ✓")
                    } else {
                        status.add("Overlay: ✗")
                    }
                
                return status.joinToString(", ")
            }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/Persistent.kt
================================================
package com.blurr.voice.utilities

import android.graphics.Bitmap
import android.os.Environment
import android.util.Log

import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class Persistent {


    fun saveTipsToFile(file: File, tips: String) {
        file.writeText(tips)
    }
    fun loadTipsFromFile(file: File): String {
        return if (file.exists()) file.readText() else ""
    }

    fun saveBitmapForDebugging(bitmap: Bitmap) {
        val publicPicturesDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)
        val screenshotDir = File(publicPicturesDir, "ScreenAgent")
        screenshotDir.mkdirs()
        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
        val file = File(screenshotDir, "SS_$timestamp.png")
        try {
            val fos = java.io.FileOutputStream(file)
            fos.use { bitmap.compress(Bitmap.CompressFormat.PNG, 100, it) }
            Log.d("MainActivity", "Debug screenshot saved to ${file.absolutePath}")
        } catch (e: Exception) {
            Log.e("MainActivity", "Failed to save debug screenshot", e)
        }
    }


}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/ServicePermissionManager.kt
================================================
package com.blurr.voice.utilities

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings
import android.text.TextUtils
import androidx.core.content.ContextCompat
import com.blurr.voice.ScreenInteractionService

/**
 * Utility class to handle all permission-related functionality from a Service context.
 */
class ServicePermissionManager(private val context: Context) {

    /**
     * Checks if all essential permissions are granted.
     */
    fun areAllPermissionsGranted(): Boolean {
        return isAccessibilityServiceEnabled() &&
                isMicrophonePermissionGranted() &&
                isOverlayPermissionGranted() &&
                isNotificationPermissionGranted()
    }

    /**
     * Check if microphone permission is granted
     */
    fun isMicrophonePermissionGranted(): Boolean {
        return ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) ==
                PackageManager.PERMISSION_GRANTED
    }

    /**
     * Check if notification permission is granted
     */
    fun isNotificationPermissionGranted(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) ==
                    PackageManager.PERMISSION_GRANTED
        } else {
            true // Notification permission not required before Android 13
        }
    }

    /**
     * Check if accessibility service is enabled
     */
    fun isAccessibilityServiceEnabled(): Boolean {
        val service = context.packageName + "/" + ScreenInteractionService::class.java.canonicalName
        val accessibilityEnabled = Settings.Secure.getInt(
            context.contentResolver,
            Settings.Secure.ACCESSIBILITY_ENABLED,
            0
        )
        if (accessibilityEnabled == 1) {
            val settingValue = Settings.Secure.getString(
                context.contentResolver,
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
            )
            if (settingValue != null) {
                val splitter = TextUtils.SimpleStringSplitter(':')
                splitter.setString(settingValue)
                while (splitter.hasNext()) {
                    val componentName = splitter.next()
                    if (componentName.equals(service, ignoreCase = true)) {
                        return true
                    }
                }
            }
        }
        return false
    }

    /**
     * Check if overlay permission is granted
     */
    fun isOverlayPermissionGranted(): Boolean {
        return Settings.canDrawOverlays(context)
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/utilities/SpeechCoordinator.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.util.Log
import com.blurr.voice.api.GoogleTts
import com.blurr.voice.api.TTSVoice
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlin.coroutines.cancellation.CancellationException

class SpeechCoordinator private constructor(private val context: Context) {

    companion object {
        private const val TAG = "SpeechCoordinator"

        @Volatile private var INSTANCE: SpeechCoordinator? = null

        fun getInstance(context: Context): SpeechCoordinator {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: SpeechCoordinator(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    private val ttsManager = TTSManager.getInstance(context)
    private val sttManager = STTManager(context)

    // Mutex to ensure only one speech operation at a time
    private val speechMutex = Mutex()
    private var ttsPlaybackJob: Job? = null
    // State tracking
    private var isSpeaking = false
    private var isListening = false

    /**
     * Speak text using TTS, ensuring STT is not listening
     * @param text The text to speak
     */
    suspend fun speakText(text: String) {
        val cleanedText = text.replace("*", "")
        speechMutex.withLock {
            try {
                if (isListening) {
                    Log.d(TAG, "Stopping STT before speaking: $cleanedText")
                    sttManager.stopListening()
                    isListening = false
                    delay(250) // Brief pause to ensure STT is fully stopped
                }

                isSpeaking = true
                Log.d(TAG, "Starting TTS: $cleanedText")

                // This is a suspend call that will wait until TTS is actually done.
                ttsManager.speakText(cleanedText)

                // FIXED: The inaccurate, estimated delay has been removed!

                Log.d(TAG, "TTS completed: $cleanedText")

            } finally {
                // Ensure the speaking flag is always reset
                isSpeaking = false
            }
        }
    }

    /**
     * Speak text to user, ensuring STT is not listening
     * @param text The text to speak to the user
     */
    suspend fun speakToUser(text: String) {
        val cleanedText = text.replace("*", "")
        speechMutex.withLock {
            try {
                if (isListening) {
                    Log.d(TAG, "Stopping STT before speaking to user: $cleanedText")
                    sttManager.stopListening()
                    isListening = false
                    delay(250) // Brief pause
                }

                isSpeaking = true
                Log.d(TAG, "Starting TTS to user: $cleanedText")

                ttsManager.speakToUser(cleanedText)


                Log.d(TAG, "TTS to user completed: $cleanedText")

            } finally {
                // Ensure the speaking flag is always reset
                isSpeaking = false
            }
        }
    }
    /**
     * Plays raw audio data directly using TTSManager, bypassing synthesis.
     * Ideal for playing cached voice samples.
     */
    suspend fun playAudioData(data: ByteArray) {
        ttsPlaybackJob?.cancel(CancellationException("New audio data request received"))
        ttsPlaybackJob = CoroutineScope(Dispatchers.IO).launch {
            speechMutex.withLock {
                try {
                    if (isListening) {
                        sttManager.stopListening()
                        isListening = false
                        delay(200)
                    }
                    // Directly use the TTSManager's playback function
                    ttsManager.playAudioData(data)
                } catch (e: CancellationException) {
                    throw e
                } catch (e: Exception) {
                    Log.e(TAG, "Error during audio data playback", e)
                }
            }
        }
    }
    /**
     * Start listening with STT, ensuring TTS is not speaking
     * @param onResult Callback for speech recognition results
     * @param onError Callback for speech recognition errors
     * @param onListeningStateChange Callback for listening state changes
     */
    suspend fun testVoice(text: String, voice: TTSVoice) {
        ttsPlaybackJob?.cancel(CancellationException("New voice test request received"))
        ttsPlaybackJob = CoroutineScope(Dispatchers.IO).launch {
            speechMutex.withLock {
                try {
                    if (isListening) {
                        sttManager.stopListening()
                        isListening = false
                        delay(200)
                    }
                    // 1. Synthesize audio with the specific voice HERE
                    val audioData = GoogleTts.synthesize(text, voice)

                    // 2. Play the synthesized audio data
                    ttsManager.playAudioData(audioData)

                } catch (e: CancellationException) {
                    throw e
                } catch (e: Exception) {
                    Log.e(TAG, "Error during voice test", e)
                }
            }
        }
    }

    fun stop() {
        // Cancel the coroutine managing the playback
        ttsPlaybackJob?.cancel(CancellationException("Playback stopped by user action"))
        // Call the underlying TTS Manager's stop function to halt the hardware
        ttsManager.stop()
        Log.d(TAG, "All TTS playback stopped by coordinator.")
    }

    suspend fun startListening(
        onResult: (String) -> Unit,
        onError: (String) -> Unit,
        onListeningStateChange: (Boolean) -> Unit,
        onPartialResult: (String) -> Unit
    ) {
        stop() // Use our new stop function to ensure TTS is stopped before listening
        speechMutex.withLock {
            try {

                // If TTS is speaking, wait for it to complete. This loop is now
                // much more efficient as isSpeaking is updated accurately.
                if (isSpeaking) {
                    Log.d(TAG, "Waiting for TTS to complete before starting STT")
                    while (isSpeaking) {
                        delay(100) // Check every 100ms
                    }
                    delay(250) // Additional pause after TTS completes
                }

                isListening = true
                sttManager.startListening(
                    onResult = { result -> onResult(result) },
                    onError = { error -> onError(error) },
                    onListeningStateChange = { listening ->
                        isListening = listening
                        onListeningStateChange(listening)
                    },
                    onPartialResult = { partialText -> onPartialResult(partialText) }
                )

            } catch (e: Exception) {
                isListening = false
                onError("Failed to start speech recognition: ${e.message}")
            }
        }
    }

    fun stopListening() {
        if (isListening) {
            sttManager.stopListening()
            isListening = false
        }
    }
    fun stopSpeaking() {
        ttsManager.stop()
        Log.d("SpeechCoordinator", "Speaking explicitly stopped.")
    }


    fun isCurrentlySpeaking(): Boolean = isSpeaking

    fun isCurrentlyListening(): Boolean = isListening

    fun isSpeechActive(): Boolean = isSpeaking || isListening

    suspend fun waitForSpeechCompletion() {
        while (isSpeechActive()) {
            delay(100)
        }
    }

    fun shutdown() {
        stopListening()
        sttManager.shutdown()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/STTManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.*

class STTManager(private val context: Context) {
    
    private var speechRecognizer: SpeechRecognizer? = null
    private var isListening = false
    private var onResultCallback: ((String) -> Unit)? = null
    private var onErrorCallback: ((String) -> Unit)? = null
    private var onListeningStateChange: ((Boolean) -> Unit)? = null
    private var onPartialResultCallback: ((String) -> Unit)? = null
    private var isInitialized = false
    private val visualizerManager = STTVisualizer(context)
    private val COMPLETE_SILENCE_MS = 2500  // time of silence to consider input complete
    private val POSSIBLE_SILENCE_MS = 2000  // shorter silence hint window
    private val MIN_UTTERANCE_MS     = 1500 // enforce a minimum listening duration

    

    private fun initializeSpeechRecognizer() {
        if (isInitialized) return
        
        if (SpeechRecognizer.isRecognitionAvailable(context)) {
            try {
                speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)
                speechRecognizer?.setRecognitionListener(createRecognitionListener())
                isInitialized = true
                Log.d("STTManager", "Speech recognizer initialized successfully")
            } catch (e: Exception) {
                Log.e("STTManager", "Failed to initialize speech recognizer", e)
            }
        } else {
            Log.e("STTManager", "Speech recognition not available on this device")
        }
    }
    

    
    private fun createRecognitionListener(): RecognitionListener {
        return object : RecognitionListener {
            override fun onReadyForSpeech(params: Bundle?) {
                Log.d("STTManager", "Ready for speech")
                isListening = true
                onListeningStateChange?.invoke(true)
            }
            
            override fun onBeginningOfSpeech() {
                Log.d("STTManager", "Beginning of speech")
            }

            override fun onRmsChanged(rmsdB: Float) {
                visualizerManager.onRmsChanged(rmsdB)
            }
            
            override fun onBufferReceived(buffer: ByteArray?) {
            }
            
            override fun onEndOfSpeech() {
                Log.d("STTManager", "End of speech")
                isListening = false
                onListeningStateChange?.invoke(false)
                onPartialResultCallback = null
            }
            
            override fun onError(error: Int) {
                isListening = false
                onListeningStateChange?.invoke(false)
                visualizerManager.hide()

                val errorMessage = when (error) {
                    SpeechRecognizer.ERROR_AUDIO -> "Audio recording error"
                    SpeechRecognizer.ERROR_CLIENT -> "Client side error"
                    SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Insufficient permissions"
                    SpeechRecognizer.ERROR_NETWORK -> "Network error"
                    SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "Network timeout"
                    SpeechRecognizer.ERROR_NO_MATCH -> "No speech match"
                    SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Recognizer busy"
                    SpeechRecognizer.ERROR_SERVER -> "Server error"
                    SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "Speech timeout"
                    else -> "Unknown error: $error"
                }
                
                Log.e("STTManager", "Speech recognition error: $errorMessage")
                onErrorCallback?.invoke(errorMessage)
                onPartialResultCallback = null
            }
            
            override fun onResults(results: Bundle?) {
                isListening = false
                onListeningStateChange?.invoke(false)
                visualizerManager.hide()

                val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                if (!matches.isNullOrEmpty()) {
                    val recognizedText = matches[0]
                    Log.d("STTManager", "Recognized text: $recognizedText")
                    onResultCallback?.invoke(recognizedText)
                } else {
                    Log.w("STTManager", "No results from speech recognition")
                    onErrorCallback?.invoke("No speech detected")
                }
            }

            override fun onPartialResults(partialResults: Bundle?) {
                val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                if (!matches.isNullOrEmpty()) {
                    val partialText = matches[0]
                    Log.d("STTManager", "Partial result: $partialText")
                    onPartialResultCallback?.invoke(partialText)
                }
            }
            
            override fun onEvent(eventType: Int, params: Bundle?) {
            }
        }
    }
    
    fun startListening(
        onResult: (String) -> Unit,
        onError: (String) -> Unit,
        onListeningStateChange: (Boolean) -> Unit,
        onPartialResult: (String) -> Unit
    ) {
        if (isListening) {
            Log.w("STTManager", "Already listening")
            return
        }
        
        this.onResultCallback = onResult
        this.onErrorCallback = onError
        this.onListeningStateChange = onListeningStateChange
        this.onPartialResultCallback = onPartialResult

        CoroutineScope(Dispatchers.Main).launch {
            initializeSpeechRecognizer()
            
            if (speechRecognizer == null) {
                onError("Speech recognition not available")
                return@launch
            }
            visualizerManager.show()


            val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
                putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
                putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
                putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
                putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
//                putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS, COMPLETE_SILENCE_MS)
//                putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS, POSSIBLE_SILENCE_MS)
//                putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_MINIMUM_LENGTH_MILLIS, MIN_UTTERANCE_MS)
            }
            
            try {
                speechRecognizer?.startListening(intent)
                Log.d("STTManager", "Started listening")
            } catch (e: Exception) {
                Log.e("STTManager", "Error starting speech recognition", e)
                onError("Failed to start speech recognition: ${e.message}")
            }
        }
    }
    
    fun stopListening() {
        if (isListening && speechRecognizer != null) {
            try {
                speechRecognizer?.stopListening()
                Log.d("STTManager", "Stopped listening")
            } catch (e: Exception) {
                Log.e("STTManager", "Error stopping speech recognition", e)
            }
        }
    }
    
    fun isCurrentlyListening(): Boolean = isListening
    
    fun shutdown() {
        try {
            speechRecognizer?.destroy()
        } catch (e: Exception) {
            Log.e("STTManager", "Error destroying speech recognizer", e)
        }
        visualizerManager.hide()

        speechRecognizer = null
        isListening = false
        isInitialized = false
        Log.d("STTManager", "STT Manager shutdown")
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/STTVisualizer.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.graphics.PixelFormat
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.view.Gravity
import android.view.WindowManager
import android.util.Log
import com.blurr.voice.AudioWaveView // CHANGED: Import the new wave view

class STTVisualizer(private val context: Context) {

    private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    // CHANGED: The view is now an AudioWaveView
    private var visualizerView: AudioWaveView? = null
    private val mainHandler = Handler(Looper.getMainLooper())

    fun show() {
        // Ensure all UI operations are on the main thread
        mainHandler.post {
            if (visualizerView != null) {
                return@post // Already showing
            }
            Log.d("STTVisualizer", "Showing visualizer")

            // CHANGED: Instantiate the new wave view
            visualizerView = AudioWaveView(context)

            // CHANGED: Layout parameters are adjusted for the wave view
            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                300, // Give the view a fixed height (e.g., 300 pixels)
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                    WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                else
                    WindowManager.LayoutParams.TYPE_PHONE,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.BOTTOM // Position at the very bottom
                // y = 0 // No offset from the bottom
            }

            try {
                windowManager.addView(visualizerView, params)
            } catch (e: Exception) {
                Log.e("STTVisualizer", "Failed to add view. Do you have overlay permissions?", e)
            }
        }
    }

    fun hide() {
        mainHandler.post {
            visualizerView?.let {
                if (it.isAttachedToWindow) {
                    Log.d("STTVisualizer", "Hiding visualizer")
                    windowManager.removeView(it)
                }
            }
            visualizerView = null
        }
    }

    /**
     * This function works without any changes because AudioWaveView
     * also has an updateAmplitude(rmsdB: Float) method.
     */
    fun onRmsChanged(rmsdB: Float) {
        mainHandler.post {
            visualizerView?.updateAmplitude(rmsdB)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/TTSManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.graphics.PixelFormat
import android.graphics.drawable.GradientDrawable
import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import android.os.Handler
import android.os.Looper
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import android.view.Gravity
import android.view.View
import android.view.WindowManager
import android.widget.TextView
import com.blurr.voice.BuildConfig
import com.blurr.voice.api.GoogleTts
import com.blurr.voice.api.TTSVoice
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import kotlin.coroutines.cancellation.CancellationException
import java.io.File
import java.security.MessageDigest
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.LinkedBlockingDeque

class TTSManager private constructor(private val context: Context) : TextToSpeech.OnInitListener {

    private var nativeTts: TextToSpeech? = null
    private var isNativeTtsInitialized = CompletableDeferred<Unit>()

    // --- NEW: Properties for Caption Management ---
    private val windowManager by lazy { context.getSystemService(Context.WINDOW_SERVICE) as WindowManager }
    private val mainHandler = Handler(Looper.getMainLooper())
    private var captionView: View? = null
    private var captionsEnabled = false

    private var audioTrack: AudioTrack? = null
    private var googleTtsPlaybackDeferred: CompletableDeferred<Unit>? = null

    var utteranceListener: ((isSpeaking: Boolean) -> Unit)? = null

    private var isDebugMode: Boolean = try {
        BuildConfig.SPEAK_INSTRUCTIONS
    } catch (e: Exception) {
        true
    }

    // --- NEW: Caching System ---
    private val cacheDir by lazy { File(context.cacheDir, "tts_cache") }
    private val cache = ConcurrentHashMap<String, CachedAudio>()
    private val accessOrder = LinkedBlockingDeque<String>()
    private val cacheMutex = Any()
    private val MAX_CACHE_SIZE = 100
    private val MAX_WORDS_FOR_CACHING = 10

    companion object {
        @Volatile private var INSTANCE: TTSManager? = null
        private const val SAMPLE_RATE = 24000

        fun getInstance(context: Context): TTSManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: TTSManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    init {
        nativeTts = TextToSpeech(context, this)
        setupAudioTrack()
        initializeCache()
    }

    /**
     * Data class for cached audio entries
     */
    private data class CachedAudio(
        val text: String,
        val audioData: ByteArray,
        val voiceName: String,
        val timestamp: Long = System.currentTimeMillis()
    ) {
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (javaClass != other?.javaClass) return false
            other as CachedAudio
            return text == other.text && voiceName == other.voiceName
        }

        override fun hashCode(): Int {
            var result = text.hashCode()
            result = 31 * result + voiceName.hashCode()
            return result
        }
    }

    /**
     * Initialize the cache directory and load existing cached items
     */
    private fun initializeCache() {
        try {
            if (!cacheDir.exists()) {
                cacheDir.mkdirs()
            }
            loadCacheFromDisk()
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to initialize cache", e)
        }
    }

    /**
     * Generate a hash for the text and voice combination
     */
    private fun generateCacheKey(text: String, voice: TTSVoice): String {
        val combined = "${text.trim().lowercase()}_${voice.name}"
        val digest = MessageDigest.getInstance("SHA-256")
        val hash = digest.digest(combined.toByteArray())
        return hash.joinToString("") { "%02x".format(it) }
    }

    /**
     * Check if text should be cached (10 words or less)
     */
    private fun shouldCache(text: String): Boolean {
        val wordCount = text.trim().split(Regex("\\s+")).size
        return wordCount <= MAX_WORDS_FOR_CACHING
    }

    /**
     * Get cached audio data if available
     */
    private fun getCachedAudio(text: String, voice: TTSVoice): ByteArray? {
        if (!shouldCache(text)) return null
        
        val cacheKey = generateCacheKey(text, voice)
        synchronized(cacheMutex) {
            val cachedAudio = cache[cacheKey]
            if (cachedAudio != null) {
                // Update access order (move to end)
                accessOrder.remove(cacheKey)
                accessOrder.addLast(cacheKey)
                Log.d("TTSManager", "Cache hit for: ${text.take(50)}...")
                return cachedAudio.audioData
            }
        }
        return null
    }

    /**
     * Store audio data in cache
     */
    private fun cacheAudio(text: String, audioData: ByteArray, voice: TTSVoice) {
        if (!shouldCache(text)) return
        
        val cacheKey = generateCacheKey(text, voice)
        synchronized(cacheMutex) {
            // Remove if already exists
            cache.remove(cacheKey)
            accessOrder.remove(cacheKey)
            
            // Add new entry
            val cachedAudio = CachedAudio(text.trim(), audioData, voice.name)
            cache[cacheKey] = cachedAudio
            accessOrder.addLast(cacheKey)
            
            // Enforce cache size limit
            if (cache.size > MAX_CACHE_SIZE) {
                val oldestKey = accessOrder.removeFirst()
                cache.remove(oldestKey)
                deleteCacheFile(oldestKey)
            }
            
            // Save to disk
            saveCacheToDisk(cacheKey, cachedAudio)
            Log.d("TTSManager", "Cached audio for: ${text.take(50)}... (Cache size: ${cache.size})")
        }
    }

    /**
     * Save cached audio to disk
     */
    private fun saveCacheToDisk(cacheKey: String, cachedAudio: CachedAudio) {
        try {
            val file = File(cacheDir, cacheKey)
            file.writeBytes(cachedAudio.audioData)
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to save cache to disk", e)
        }
    }

    /**
     * Load cache from disk
     */
    private fun loadCacheFromDisk() {
        try {
            val files = cacheDir.listFiles() ?: return
            for (file in files) {
                if (file.isFile && file.length() > 0) {
                    val cacheKey = file.name
                    val audioData = file.readBytes()
                    // Note: We can't fully reconstruct CachedAudio without metadata
                    // This is a simplified version - in production you might want to store metadata
                    Log.d("TTSManager", "Loaded cached audio: $cacheKey")
                }
            }
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to load cache from disk", e)
        }
    }

    /**
     * Delete cache file from disk
     */
    private fun deleteCacheFile(cacheKey: String) {
        try {
            val file = File(cacheDir, cacheKey)
            if (file.exists()) {
                file.delete()
            }
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to delete cache file", e)
        }
    }

    /**
     * Clear all cached data
     */
    fun clearCache() {
        synchronized(cacheMutex) {
            cache.clear()
            accessOrder.clear()
            try {
                cacheDir.listFiles()?.forEach { it.delete() }
            } catch (e: Exception) {
                Log.e("TTSManager", "Failed to clear cache directory", e)
            }
        }
    }

    private fun setupAudioTrack() {
        val bufferSize = AudioTrack.getMinBufferSize(
            SAMPLE_RATE,
            AudioFormat.CHANNEL_OUT_MONO,
            AudioFormat.ENCODING_PCM_16BIT
        )
        audioTrack = AudioTrack.Builder()
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_MEDIA)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build()
            )
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setSampleRate(SAMPLE_RATE)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize)
            .build()

        audioTrack?.setPlaybackPositionUpdateListener(object : AudioTrack.OnPlaybackPositionUpdateListener {
            override fun onMarkerReached(track: AudioTrack?) {
                googleTtsPlaybackDeferred?.complete(Unit)
            }
            override fun onPeriodicNotification(track: AudioTrack?) {}
        }, Handler(Looper.getMainLooper()))
    }

    fun setCaptionsEnabled(enabled: Boolean) {
        this.captionsEnabled = enabled
        // If captions are disabled while one is showing, remove it immediately.
        if (!enabled) {
            mainHandler.post { removeCaption() }
        }
    }

    fun getCaptionStatus(): Boolean{
        return this.captionsEnabled
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            nativeTts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) { utteranceListener?.invoke(true) }
                override fun onDone(utteranceId: String?) {
                    mainHandler.post { removeCaption() }
                    utteranceListener?.invoke(false) 
                }
                override fun onError(utteranceId: String?) {
                    mainHandler.post { removeCaption() }
                    utteranceListener?.invoke(false) 
                }
            })
            isNativeTtsInitialized.complete(Unit)
        } else {
            isNativeTtsInitialized.completeExceptionally(Exception("Native TTS Initialization failed"))
        }
    }

    // --- NEW PUBLIC FUNCTION TO STOP PLAYBACK ---
    fun stop() {
        // Stop the AudioTrack if it's currently playing
        if (audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
            audioTrack?.stop()
            audioTrack?.flush() // Clear any buffered data
        }
        // Immediately cancel any coroutine that is awaiting playback completion
        if (googleTtsPlaybackDeferred?.isActive == true) {
            googleTtsPlaybackDeferred?.completeExceptionally(CancellationException("Playback stopped by new request."))
        }
    }

    suspend fun speakText(text: String) {
        if (!isDebugMode) return
        speak(text)
    }

    suspend fun speakToUser(text: String) {
        speak(text)
    }

    fun getAudioSessionId(): Int {
        return audioTrack?.audioSessionId ?: 0
    }

    private suspend fun speak(text: String) {
        try {
            val selectedVoice = VoicePreferenceManager.getSelectedVoice(context)
            
            // Smart chunking: Break text into sentences of ~50 words each
            val textChunks = chunkTextIntoSentences(text, maxWordsPerChunk = 50)
            
            if (textChunks.size == 1) {
                // Single chunk - process normally
                speakChunk(textChunks[0].trim(), selectedVoice)
            } else {
                // Multiple chunks - use smart queue-based playback
                playWithSmartQueue(textChunks, selectedVoice)
            }

        } catch (e: Exception) {
            if (e is CancellationException) throw e // Re-throw cancellation to stop execution
            Log.e("TTSManager", "Google TTS failed: ${e.message}. Falling back to native engine.")
            isNativeTtsInitialized.await()
            nativeTts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, this.hashCode().toString())
        }
    }
    
    /**
     * Smart queue-based playback that starts playing immediately while preloading in background
     */
    private suspend fun playWithSmartQueue(textChunks: List<String>, selectedVoice: TTSVoice) {
        val audioQueue = mutableListOf<Pair<String, ByteArray>>()
        val queueMutex = Any()
        
        // Start preloading the first chunk immediately
        val firstChunk = textChunks[0].trim()
        val firstAudioData = getCachedAudio(firstChunk, selectedVoice) ?: try {
            GoogleTts.synthesize(firstChunk, selectedVoice).also { audioData ->
                cacheAudio(firstChunk, audioData, selectedVoice)
            }
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to synthesize first chunk: ${e.message}")
            return
        }
        
        // Add first chunk to queue and start playing
        synchronized(queueMutex) {
            audioQueue.add(Pair(firstChunk, firstAudioData))
        }
        
        // Start background preloading for remaining chunks
        val preloadJob = CoroutineScope(Dispatchers.IO).launch {
            for (i in 1 until textChunks.size) {
                val chunk = textChunks[i].trim()
                if (chunk.isNotEmpty()) {
                    try {
                        val audioData = getCachedAudio(chunk, selectedVoice) ?: GoogleTts.synthesize(chunk, selectedVoice).also { audioData ->
                            cacheAudio(chunk, audioData, selectedVoice)
                        }
                        synchronized(queueMutex) {
                            audioQueue.add(Pair(chunk, audioData))
                        }
                        Log.d("TTSManager", "Preloaded chunk ${i + 1}/${textChunks.size}: ${chunk.take(50)}...")
                    } catch (e: Exception) {
                        Log.e("TTSManager", "Failed to preload chunk ${i + 1}: ${e.message}")
                    }
                }
            }
        }
        
        // Start playing from queue
        while (true) {
            val currentChunk: Pair<String, ByteArray>?
            
            synchronized(queueMutex) {
                if (audioQueue.isNotEmpty()) {
                    currentChunk = audioQueue.removeAt(0)
                } else {
                    currentChunk = null
                }
            }
            
            if (currentChunk == null) {
                // No more chunks in queue, check if preloading is complete
                if (preloadJob.isCompleted) {
                    break
                } else {
                    // Wait a bit for more chunks to be preloaded
                    delay(100)
                    continue
                }
            }
            
            // Play current chunk
            try {
                val (chunkText, audioData) = currentChunk
                
                // This deferred will complete when onMarkerReached is called.
                googleTtsPlaybackDeferred = CompletableDeferred()
                
                // Show caption for current chunk
                withContext(Dispatchers.Main) {
                    showCaption(chunkText)
                    utteranceListener?.invoke(true)
                }
                
                // Play audio on background thread
                withContext(Dispatchers.IO) {
                    audioTrack?.play()
                    val numFrames = audioData.size / 2
                    audioTrack?.setNotificationMarkerPosition(numFrames)
                    audioTrack?.write(audioData, 0, audioData.size)
                }
                
                // Wait for playback completion
                withTimeoutOrNull(10000) { // 10-second timeout per chunk
                    googleTtsPlaybackDeferred?.await()
                }
                
                audioTrack?.stop()
                audioTrack?.flush()
                
                withContext(Dispatchers.Main) {
                    removeCaption()
                    utteranceListener?.invoke(false)
                }
                
                Log.d("TTSManager", "Successfully played queued audio chunk: ${chunkText.take(50)}...")
                
            } catch (e: Exception) {
                if (e is CancellationException) throw e
                Log.e("TTSManager", "Failed to play queued chunk: ${currentChunk.first.take(50)}... Error: ${e.message}")
            }
        }
        
        // Cancel preloading job if it's still running
        if (preloadJob.isActive) {
            preloadJob.cancel()
        }
    }
    
    /**
     * Breaks text into sentences of approximately maxWordsPerChunk words each
     */
    private fun chunkTextIntoSentences(text: String, maxWordsPerChunk: Int): List<String> {
        if (text.length <= 500) {
            // For short text, return as is
            return listOf(text)
        }
        
        val sentences = text.split(Regex("(?<=[.!?])\\s+")).filter { it.trim().isNotEmpty() }
        val chunks = mutableListOf<String>()
        var currentChunk = StringBuilder()
        var currentWordCount = 0
        
        for (sentence in sentences) {
            val sentenceWordCount = sentence.split(Regex("\\s+")).size
            
            // If adding this sentence would exceed the limit and we already have content
            if (currentWordCount + sentenceWordCount > maxWordsPerChunk && currentChunk.isNotEmpty()) {
                // Add current chunk to results
                chunks.add(currentChunk.toString().trim())
                currentChunk.clear()
                currentWordCount = 0
            }
            
            // Add sentence to current chunk
            if (currentChunk.isNotEmpty()) {
                currentChunk.append(" ")
            }
            currentChunk.append(sentence)
            currentWordCount += sentenceWordCount
        }
        
        // Add the last chunk if it has content
        if (currentChunk.isNotEmpty()) {
            chunks.add(currentChunk.toString().trim())
        }
        
        // If no chunks were created (e.g., very long single sentence), 
        // break by words instead
        if (chunks.isEmpty() || chunks.size == 1 && chunks[0].split(Regex("\\s+")).size > maxWordsPerChunk * 2) {
            return chunkTextByWords(text, maxWordsPerChunk)
        }
        
        return chunks
    }
    
    /**
     * Fallback method to break text by words when sentence-based chunking fails
     */
    private fun chunkTextByWords(text: String, maxWordsPerChunk: Int): List<String> {
        val words = text.split(Regex("\\s+"))
        val chunks = mutableListOf<String>()
        
        for (i in words.indices step maxWordsPerChunk) {
            val chunk = words.drop(i).take(maxWordsPerChunk).joinToString(" ")
            if (chunk.isNotEmpty()) {
                chunks.add(chunk)
            }
        }
        
        return chunks
    }
    
    /**
     * Speaks a single chunk of text (used for single chunks or fallback)
     */
    private suspend fun speakChunk(chunk: String, selectedVoice: TTSVoice) {
        try {
            // Check cache first
            val audioData = getCachedAudio(chunk, selectedVoice) ?: GoogleTts.synthesize(chunk, selectedVoice).also { audioData ->
                cacheAudio(chunk, audioData, selectedVoice)
            }
            
            // This deferred will complete when onMarkerReached is called.
            googleTtsPlaybackDeferred = CompletableDeferred()
            
            // Correctly signal start and wait for completion.
            withContext(Dispatchers.Main) {
                showCaption(chunk)
                utteranceListener?.invoke(true)
            }
            
            // Write and play audio on a background thread
            withContext(Dispatchers.IO) {
                audioTrack?.play()
                // The number of frames is the size of the data divided by the size of each frame (2 bytes for 16-bit audio).
                val numFrames = audioData.size / 2
                audioTrack?.setNotificationMarkerPosition(numFrames)
                audioTrack?.write(audioData, 0, audioData.size)
            }
            
            // Wait for the playback to complete, with a timeout for safety.
            withTimeoutOrNull(15000) { // 15-second timeout per chunk
                googleTtsPlaybackDeferred?.await()
            }
            
            audioTrack?.stop()
            audioTrack?.flush()
            
            withContext(Dispatchers.Main) {
                removeCaption()
                utteranceListener?.invoke(false)
            }
            
            Log.d("TTSManager", "Successfully played audio chunk: ${chunk.take(50)}...")
            
        } catch (e: Exception) {
            if (e is CancellationException) throw e
            Log.e("TTSManager", "Failed to speak chunk: ${chunk.take(50)}... Error: ${e.message}")
            // Continue with next chunk instead of falling back to native TTS for the entire text
        }
    }

    suspend fun playAudioData(audioData: ByteArray) {
        try {
            googleTtsPlaybackDeferred = CompletableDeferred()
            withContext(Dispatchers.Main) {
                utteranceListener?.invoke(true)
            }

            withContext(Dispatchers.IO) {
                audioTrack?.play()
                val numFrames = audioData.size / 2
                audioTrack?.setNotificationMarkerPosition(numFrames)
                audioTrack?.write(audioData, 0, audioData.size)
            }

            withTimeoutOrNull(30000) { googleTtsPlaybackDeferred?.await() }

            withContext(Dispatchers.Main) { utteranceListener?.invoke(false) }
        } catch (e: Exception) {
            if (e is CancellationException) throw e
            Log.e("TTSManager", "Error playing audio data", e)
        } finally {
            if (audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                audioTrack?.stop()
                audioTrack?.flush()
            }
            if (utteranceListener != null && Looper.myLooper() != Looper.getMainLooper()) {
                withContext(Dispatchers.Main) { utteranceListener?.invoke(false) }
            } else {
                utteranceListener?.invoke(false)
            }
        }
    }

    // --- NEW: Private method to display the caption view ---
    private fun showCaption(text: String) {
        if (!captionsEnabled) return

        removeCaption() // Remove any previous caption first

        // Create and style the new TextView.
        val textView = TextView(context).apply {
            this.text = text
            background = GradientDrawable().apply {
                setColor(0xCC000000.toInt()) // 80% opaque black
                cornerRadius = 24f
            }
            setTextColor(0xFFFFFFFF.toInt()) // White text
            textSize = 16f
            setPadding(24, 16, 24, 16)
        }

        val params = WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
            PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            y = 250 // Pixels up from the bottom of the screen
        }

        try {
            windowManager.addView(textView, params)
            captionView = textView // Save a reference to the new view.
        } catch (e: Exception) {
            Log.e("TTSManager", "Failed to display caption on screen.", e)
        }
    }

    // --- NEW: Private method to remove the caption view ---
    private fun removeCaption() {
        captionView?.let {
            if (it.isAttachedToWindow) {
                try {
                    windowManager.removeView(it)
                } catch (e: Exception) {
                    Log.e("TTSManager", "Error removing caption view.", e)
                }
            }
        }
        captionView = null
    }

    fun shutdown() {
        stop()
        nativeTts?.shutdown()
        audioTrack?.release()
        audioTrack = null
        INSTANCE = null
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/TtsVisualizer.kt
================================================
package com.blurr.voice.utilities

import android.media.audiofx.Visualizer
import android.util.Log

class TtsVisualizer(
    private val audioSessionId: Int,
    private val onAmplitudeChanged: (Float) -> Unit
) {
    private var visualizer: Visualizer? = null

    fun start() {
        if (visualizer != null) return // Already running
        Log.d("TtsVisualizer", "Starting to visualize audio session: $audioSessionId")
        try {
            visualizer = Visualizer(audioSessionId).apply {
                captureSize = Visualizer.getCaptureSizeRange()[0] // Use a small capture size for waveform
                setDataCaptureListener(object : Visualizer.OnDataCaptureListener {
                    override fun onWaveFormDataCapture(
                        visualizer: Visualizer?,
                        waveform: ByteArray?,
                        samplingRate: Int
                    ) {
                        if (waveform == null) return

                        // Calculate amplitude from the waveform data
                        var maxAmplitude = 0.0
                        for (i in waveform.indices step 2) {
                            // Combine two bytes to form a 16-bit sample
                            val sample = (waveform[i+1].toInt() shl 8) or (waveform[i].toInt() and 0xFF)
                            if(sample > maxAmplitude) {
                                maxAmplitude = sample.toDouble()
                            }
                        }
                        // Normalize the amplitude to a 0.0f to 1.0f range
                        val normalized = (maxAmplitude / 32767.0).toFloat()
                        onAmplitudeChanged(normalized)
                    }

                    override fun onFftDataCapture(p0: Visualizer?, p1: ByteArray?, p2: Int) {
                        // We don't need FFT data for this effect
                    }
                }, Visualizer.getMaxCaptureRate() / 2, true, false)
                enabled = true
            }
        } catch (e: Exception) {
            Log.e("TtsVisualizer", "Error initializing Visualizer", e)
        }
    }

    fun stop() {
        Log.d("TtsVisualizer", "Stopping visualization.")
        visualizer?.enabled = false
        visualizer?.release()
        visualizer = null
        // Reset amplitude to 0 when stopped
        onAmplitudeChanged(0f)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/UserIdManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.content.SharedPreferences
import java.util.UUID
import androidx.core.content.edit

/**
 * A manager class to handle the creation and retrieval of a persistent,
 * unique user ID for the application.
 *
 * It uses SharedPreferences to store the ID, ensuring the same user is
 * recognized across app sessions.
 *
 * @param context The application context, used to access SharedPreferences.
 */
class UserIdManager(context: Context) {

    companion object {
        // The name of our preferences file.
        private const val PREFS_NAME = "AppUserPrefs"
        // The key under which the user ID is stored.
        private const val KEY_USER_ID = "user_id"
    }

    // Initialize SharedPreferences instance.
    // MODE_PRIVATE means the file can only be accessed by the calling application.
    private val sharedPreferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    /**
     * Retrieves the existing unique user ID. If one does not exist (i.e., it's the
     * first time the user has opened the app), it creates a new unique ID, saves it
     * for future use, and then returns it.
     *
     * @return A unique String identifier for the user.
     */
    fun getOrCreateUserId(): String {
        // Try to retrieve the existing user ID. If it's not found, 'null' is returned.
        val existingId = sharedPreferences.getString(KEY_USER_ID, null)

        return if (existingId != null) {
            // If the ID exists, we're done. Return it.
            println("UserIdManager: Existing user ID found: $existingId")
            existingId
        } else {
            // If the ID is null, this is the first launch.
            // 1. Generate a new, random, and unique ID.
            val newId = UUID.randomUUID().toString()
            println("UserIdManager: No existing ID found. Creating new ID: $newId")

            // 2. Save the new ID to SharedPreferences for future launches.
            // We use .apply() which saves the data asynchronously in the background.
            sharedPreferences.edit { putString(KEY_USER_ID, newId) }

            // 3. Return the new ID.
            newId
        }
    }

    /**
     * A helper method to demonstrate retrieving the ID without creating one.
     * @return The stored user ID, or null if it has not been created yet.
     */
    fun retrieveUserId(): String? {
        return sharedPreferences.getString(KEY_USER_ID, null)
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/utilities/UserInputManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.speech.SpeechRecognizer
import android.util.Log
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import kotlinx.coroutines.withTimeoutOrNull
import kotlin.coroutines.resume

/**
 * Manages user input for agent questions
 * This class handles the communication between the agent and user for interactive tasks
 */
class UserInputManager(private val context: Context) {
    
    companion object {
        private const val TAG = "UserInputManager"
        private const val SPEECH_TIMEOUT_MS = 30000L // 30 seconds timeout for speech input
        private const val FALLBACK_TIMEOUT_MS = 5000L // 5 seconds for fallback response
        private const val MAX_SPEECH_ATTEMPTS = 3 // Maximum number of speech recognition attempts
        private var currentQuestion: String? = null
        private var currentResponse: String? = null
        private var responseCallback: ((String) -> Unit)? = null
    }

    private val speechCoordinator = SpeechCoordinator.getInstance(context)
    
    /**
     * Check if speech recognition is available on this device
     * @return true if speech recognition is available
     */
    fun isSpeechRecognitionAvailable(): Boolean {
        return SpeechRecognizer.isRecognitionAvailable(context)
    }
    
    /**
     * Ask a question to the user and wait for their response using speech-to-text
     * The system will attempt speech recognition up to 3 times if no speech is detected
     * @param question The question to ask the user
     * @return The user's response
     */
    suspend fun askQuestion(question: String): String {
        return suspendCancellableCoroutine { continuation ->
            try {
                currentQuestion = question
                responseCallback = { response ->
                    currentResponse = response
                    continuation.resume(response)
                }
                
                Log.d(TAG, "Agent asked: $question")
                
                // Check if speech recognition is available
                if (!isSpeechRecognitionAvailable()) {
                    Log.w(TAG, "Speech recognition not available, using fallback")
                    useFallbackResponse(question)
                    return@suspendCancellableCoroutine
                }
                
                Log.d(TAG, "Starting speech recognition for user response...")
                
                // Start speech recognition with multiple attempts
                CoroutineScope(Dispatchers.Main).launch {
                    try {
                        var response: String? = null
                        var attempt = 1
                        
                        while (attempt <= MAX_SPEECH_ATTEMPTS && (response == null || response.isEmpty())) {
                            Log.d(TAG, "Speech recognition attempt $attempt of $MAX_SPEECH_ATTEMPTS")
                            
                            if (attempt > 1) {
                                // Give user a moment to prepare for next attempt
                                delay(2000)
                                // Re-ask the question for subsequent attempts using SpeechCoordinator
                                speechCoordinator.speakToUser("Please try again. $question")
                                delay(1000) // Brief pause after re-asking
                            }
                            
                            response = suspendCancellableCoroutine<String> { speechContinuation ->
                                // Use a separate coroutine to call the suspend function
                                CoroutineScope(Dispatchers.Main).launch {
                                    try {
                                        withTimeoutOrNull(SPEECH_TIMEOUT_MS) {
                                            speechCoordinator.startListening(
                                                onResult = { recognizedText ->
                                                    Log.d(TAG, "Speech recognized on attempt $attempt: $recognizedText")
                                                    speechContinuation.resume(recognizedText)
                                                },
                                                onError = { errorMessage ->
                                                    Log.e(TAG, "Speech recognition error on attempt $attempt: $errorMessage")
                                                    // Don't throw exception, just return empty string for this attempt
                                                    speechContinuation.resume("")
                                                },
                                                onListeningStateChange = { isListening ->
                                                    Log.d(TAG, "Listening state changed on attempt $attempt: $isListening")
                                                },
                                                onPartialResult = { } // <-- FIX: Added the missing fourth argument

                                            )
                                        } ?: run {
                                            Log.w(TAG, "Speech recognition timed out on attempt $attempt")
                                            speechContinuation.resume("")
                                        }
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error in startListening", e)
                                        speechContinuation.resume("")
                                    }
                                }
                            }
                            
                            if (response != null && response.isNotEmpty()) {
                                Log.d(TAG, "User responded via speech on attempt $attempt: $response")
                                break
                            } else {
                                Log.w(TAG, "Speech recognition failed on attempt $attempt")
                                attempt++
                            }
                        }
                        
                        if (response != null && response.isNotEmpty()) {
                            responseCallback?.invoke(response)
                        } else {
                            Log.w(TAG, "All $MAX_SPEECH_ATTEMPTS speech recognition attempts failed, using fallback")
                            useFallbackResponse(question)
                        }
                        
                    } catch (e: Exception) {
                        Log.e(TAG, "Error during speech recognition", e)
                        useFallbackResponse(question)
                    } finally {
                        // Stop listening and clean up
                        speechCoordinator.stopListening()
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error asking question", e)
                continuation.resume("Error: Could not get user response")
            }
        }
    }
    
    /**
     * Use fallback response when STT is not available or fails after all attempts
     * @param question The original question
     */
    private fun useFallbackResponse(question: String) {
        CoroutineScope(Dispatchers.Main).launch {
            delay(FALLBACK_TIMEOUT_MS) // Give user time to read the question
            val fallbackResponse = "User provided fallback response after $MAX_SPEECH_ATTEMPTS failed speech recognition attempts for: $question"
            Log.d(TAG, "Using fallback response: $fallbackResponse")
            responseCallback?.invoke(fallbackResponse)
        }
    }
    
    /**
     * Provide a response to the current question
     * This method can be called from the UI or other parts of the app
     * @param response The user's response
     */
    fun provideResponse(response: String) {
        Log.d(TAG, "User responded: $response")
        currentResponse = response
        responseCallback?.invoke(response)
    }
    
    /**
     * Get the current question being asked
     * @return The current question or null if no question is active
     */
    fun getCurrentQuestion(): String? = currentQuestion
    
    /**
     * Check if there's an active question waiting for response
     * @return true if there's an active question
     */
    fun hasActiveQuestion(): Boolean = currentQuestion != null
    
    /**
     * Clear the current question and response
     */
    fun clearQuestion() {
        currentQuestion = null
        currentResponse = null
        responseCallback = null
        speechCoordinator.stopListening()
    }


    fun shutdown() {
        speechCoordinator.shutdown()
    }
} 


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/UserProfileManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.util.Patterns

class UserProfileManager(private val context: Context) {

    companion object {
        private const val PREFS_NAME = "user_profile_prefs"
        private const val KEY_NAME = "user_name"
        private const val KEY_EMAIL = "user_email"
    }

    private val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    fun isProfileComplete(): Boolean {
        val name = getName()
        val email = getEmail()
        return !name.isNullOrBlank() && !email.isNullOrBlank() && Patterns.EMAIL_ADDRESS.matcher(email).matches()
    }

    fun saveProfile(name: String, email: String) {
        prefs.edit().putString(KEY_NAME, name.trim()).putString(KEY_EMAIL, email.trim()).apply()
    }

    fun getName(): String? = prefs.getString(KEY_NAME, null)
    fun getEmail(): String? = prefs.getString(KEY_EMAIL, null)

    fun clearProfile() {
        prefs.edit().clear().apply()
    }

}





================================================
FILE: app/src/main/java/com/blurr/voice/utilities/VideoAssetManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.FileOutputStream

/**
 * Manages downloading and storing the wake word demo video from a remote URL.
 */
object VideoAssetManager {
    private const val TAG = "VideoAssetManager"
    private const val VIDEO_FILE_NAME = "wake_up_demo.mp4"

    /**
     * The public-facing function to get the video file.
     * It ensures the video is downloaded if not already present.
     */
    suspend fun getVideoFile(context: Context, url: String): File? {
        val videoFile = File(context.filesDir, VIDEO_FILE_NAME)
        if (!videoFile.exists()) {
            Log.d(TAG, "Video not found locally. Attempting to download.")
            val success = downloadVideo(context, url)
            if (!success) {
                return null // Return null if download fails
            }
        } else {
            Log.d(TAG, "Video already exists locally.")
        }
        return videoFile
    }

    /**
     * Handles the actual download logic.
     * This version is corrected to fix the "Unreachable code" error and uses a more robust
     * method for writing the file.
     */
    private suspend fun downloadVideo(context: Context, url: String): Boolean = withContext(Dispatchers.IO) {
        val videoFile = File(context.filesDir, VIDEO_FILE_NAME)
        val tempFile = File.createTempFile("video_download", ".tmp", context.cacheDir)

        val client = OkHttpClient()
        val request = Request.Builder().url(url).build()

        try {
            val response = client.newCall(request).execute()

            if (!response.isSuccessful) {
                Log.e(TAG, "Failed to download video. Code: ${response.code}")
                response.close() // Ensure response is closed on failure
                return@withContext false
            }

            // This is the main logic block. It correctly handles a potentially null response body.
            response.body?.let { body ->
                // The 'use' block automatically closes the streams, even if an error occurs.
                body.byteStream().use { inputStream ->
                    FileOutputStream(tempFile).use { outputStream ->
                        // A simple and robust way to copy the downloaded bytes to the temp file.
                        inputStream.copyTo(outputStream)
                    }
                }

                // IMPORTANT: This logic is now INSIDE the 'let' block.
                // It will only be reached if the body was not null and the copy was successful.
                tempFile.renameTo(videoFile)
                Log.d(TAG, "Successfully downloaded and saved video to ${videoFile.absolutePath}")
                return@withContext true // Success!

            } ?: run {
                // This block runs only if response.body was null.
                Log.e(TAG, "Response body was null.")
                return@withContext false
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error downloading video", e)
            // Clean up the temp file if it exists after an error.
            if (tempFile.exists()) {
                tempFile.delete()
            }
            return@withContext false
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/VisualFeedbackManager.kt
================================================
package com.blurr.voice.utilities

import android.annotation.SuppressLint
import android.content.Context
import android.graphics.PixelFormat
import android.graphics.Typeface
import android.graphics.drawable.GradientDrawable
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.view.Gravity
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputMethodManager
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.TextView
import androidx.core.graphics.toColorInt
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.blurr.voice.AudioWaveView
import com.blurr.voice.R
import com.blurr.voice.ui.SmallDeltaGlowView
import com.blurr.voice.utilities.PandaState
import com.blurr.voice.utilities.PandaStateManager
import com.blurr.voice.utilities.TTSManager
import com.blurr.voice.utilities.TtsVisualizer

class VisualFeedbackManager private constructor(private val context: Context) {

    private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    private val mainHandler = Handler(Looper.getMainLooper())

    // --- Components ---
    private var audioWaveView: AudioWaveView? = null
    private var ttsVisualizer: TtsVisualizer? = null
    private var transcriptionView: TextView? = null
    private var inputBoxView: View? = null
    private var thinkingIndicatorView: View? = null
    private var smallDeltaGlowView: SmallDeltaGlowView? = null
    private val pandaStateManager by lazy { PandaStateManager.getInstance(context) }
    private val stateChangeListener: (PandaState) -> Unit
    private var speakingOverlay: View? = null

    init {
        stateChangeListener = { newState ->
            updateSmallDeltaVisuals(newState)
        }
        pandaStateManager.addStateChangeListener(stateChangeListener)

    }

    companion object {
        private const val TAG = "VisualFeedbackManager"

        @Volatile private var INSTANCE: VisualFeedbackManager? = null

        fun getInstance(context: Context): VisualFeedbackManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: VisualFeedbackManager(context.applicationContext).also { INSTANCE = it }
            }
        }
    }

    /**
     * Check if the app has permission to draw overlays
     */
    private fun hasOverlayPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Settings.canDrawOverlays(context)
        } else {
            true
        }
    }

    // --- TTS Wave Methods ---

    fun showTtsWave() {
        mainHandler.post {
            if (audioWaveView != null) {
                Log.d(TAG, "Audio wave is already showing.")
                return@post
            }
            setupAudioWaveEffect()
        }
    }

    fun hideTtsWave() {
        mainHandler.post {
            audioWaveView?.let {
                if (it.isAttachedToWindow) {
                    windowManager.removeView(it)
                    Log.d(TAG, "Audio wave view removed.")
                }
            }
            audioWaveView = null

            ttsVisualizer?.stop()
            ttsVisualizer = null
            TTSManager.getInstance(context).utteranceListener = null
            hideSpeakingOverlay()

            Log.d(TAG, "Audio wave effect has been torn down.")
        }
    }

    private fun setupAudioWaveEffect() {
        // Check if we have overlay permission before attempting to add views
        if (!hasOverlayPermission()) {
            Log.e(TAG, "Cannot setup audio wave effect: SYSTEM_ALERT_WINDOW permission not granted")
            return
        }

        try {
            // Create and add the AudioWaveView
            audioWaveView = AudioWaveView(context)
            val heightInDp = 150
            val heightInPixels = (heightInDp * context.resources.displayMetrics.density).toInt()
            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT, heightInPixels,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
                PixelFormat.TRANSLUCENT,

            ).apply {
                gravity = Gravity.BOTTOM
                softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE
            }
            windowManager.addView(audioWaveView, params)
            Log.d(TAG, "Audio wave view added.")

            // Link to TTSManager
            val ttsManager = TTSManager.getInstance(context)
            val audioSessionId = ttsManager.getAudioSessionId()

            if (audioSessionId == 0) {
                Log.e(TAG, "Failed to get valid audio session ID. Visualizer not started.")
                return
            }

            ttsVisualizer = TtsVisualizer(audioSessionId) { normalizedAmplitude ->
                mainHandler.post {
                    audioWaveView?.setRealtimeAmplitude(normalizedAmplitude)
                }
            }

            ttsManager.utteranceListener = { isSpeaking ->
                mainHandler.post {
                    if (isSpeaking) {
                        audioWaveView?.setTargetAmplitude(0.2f)
                        ttsVisualizer?.start()
                    } else {
                        ttsVisualizer?.stop()
                        audioWaveView?.setTargetAmplitude(0.0f)
                    }
                }
            }
            Log.d(TAG, "Audio wave effect has been set up.")
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up audio wave effect", e)
            // Clean up if something went wrong
            audioWaveView = null
            ttsVisualizer = null
        }
    }

    fun showSpeakingOverlay() {
        mainHandler.post {
            if (speakingOverlay != null) return@post

            if (!hasOverlayPermission()) {
                Log.e(TAG, "Cannot show speaking overlay: SYSTEM_ALERT_WINDOW permission not granted")
                return@post
            }

            speakingOverlay = View(context).apply {
                // Reduced opacity from 80 (50%) to 40 (25%) for a more subtle overlay
                setBackgroundColor(0x40FFFFFF.toInt())
            }

            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT
            )

            try {
                windowManager.addView(speakingOverlay, params)
                Log.d(TAG, "Speaking overlay added.")
            } catch (e: Exception) {
                Log.e(TAG, "Error adding speaking overlay", e)
                speakingOverlay = null
            }
        }
    }


    fun showTranscription(initialText: String = "Listening...") {
        if (transcriptionView != null) {
            updateTranscription(initialText) // Update text if already shown
            return
        }

        mainHandler.post {
            if (!hasOverlayPermission()) {
                Log.e(TAG, "Cannot show transcription: SYSTEM_ALERT_WINDOW permission not granted")
                return@post
            }

            transcriptionView = TextView(context).apply {
                text = initialText
                val glassBackground = GradientDrawable(
                    GradientDrawable.Orientation.TL_BR,
                    intArrayOf(0xDD0D0D2E.toInt(), 0xDD2A0D45.toInt())
                ).apply {
                    cornerRadius = 28f
                    setStroke(1, 0x80FFFFFF.toInt())
                }
                background = glassBackground
                setTextColor(0xFFE0E0E0.toInt())
                textSize = 16f
                setPadding(40, 24, 40, 24)
                typeface = Typeface.MONOSPACE
            }

            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
                softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE
                y = 250 // Position it above the wave view
            }

            try {
                windowManager.addView(transcriptionView, params)
                Log.d(TAG, "Transcription view added.")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to add transcription view.", e)
                transcriptionView = null
            }
        }
    }

    fun updateTranscription(text: String) {
        mainHandler.post {
            transcriptionView?.text = text
        }
    }

    fun hideTranscription() {
        mainHandler.post {
            transcriptionView?.let {
                if (it.isAttachedToWindow) {
                    try {
                        windowManager.removeView(it)
                    } catch (e: Exception) {
                        Log.e(TAG, "Error removing transcription view.", e)
                    }
                }
            }
            transcriptionView = null
        }
    }


    @SuppressLint("ClickableViewAccessibility")
    fun showInputBox(
        onActivated: () -> Unit,
        onSubmit: (String) -> Unit,
        onOutsideTap: () -> Unit
    ) {
        // This method creates an overlay input box that appears over other apps
        // Key fix: Proper keyboard positioning using WindowInsetsCompat to prevent
        // the input box from being hidden behind the keyboard when it appears
        mainHandler.post {
            if (inputBoxView?.isAttachedToWindow == true) {
                // If already showing, just ensure focus
                inputBoxView?.findViewById<EditText>(R.id.overlayInputField)?.requestFocus()
                val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                imm.showSoftInput(inputBoxView?.findViewById(R.id.overlayInputField), InputMethodManager.SHOW_IMPLICIT)
                return@post
            }

            if (!hasOverlayPermission()) {
                Log.e(TAG, "Cannot show input box: SYSTEM_ALERT_WINDOW permission not granted")
                return@post
            }

            if (inputBoxView != null) {
                try { windowManager.removeView(inputBoxView) } catch (e: Exception) {}
            }

            val inflater = LayoutInflater.from(context)
            inputBoxView = inflater.inflate(R.layout.overlay_input_box, null)

            val inputField = inputBoxView?.findViewById<EditText>(R.id.overlayInputField)
            val rootLayout = inputBoxView?.findViewById<View>(R.id.overlayRootLayout)

            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or
                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or
                        WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.TOP
                // Top margin with sufficient space
                y = (80 * context.resources.displayMetrics.density).toInt() // 80dp top margin
            }

            inputField?.setOnEditorActionListener { v, actionId, _ ->
                if (actionId == EditorInfo.IME_ACTION_DONE) {
                    val inputText = v.text.toString().trim()
                    if (inputText.isNotEmpty()) {
                        onSubmit(inputText)
                        v.text = ""
                    } else {
                        // If empty, just hide the box
                        hideInputBox()
                    }
                    true
                } else {
                    false
                }
            }

            inputField?.setOnTouchListener { _, _ ->
                onActivated()
                false
            }

            rootLayout?.setOnTouchListener { _, event ->
                if (event.action == MotionEvent.ACTION_OUTSIDE) {
                    Log.d(TAG, "Outside touch detected.")
                    onOutsideTap() // Use the new callback
                    return@setOnTouchListener true
                }
                false
            }

            try {
                windowManager.addView(inputBoxView, params)
                Log.d(TAG, "Input box added with initial y position: ${params.y}")
                
                // **IMPROVEMENT**: Explicitly request focus and show the keyboard
                inputField?.requestFocus()
                val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                imm.showSoftInput(inputField, InputMethodManager.SHOW_IMPLICIT)

            } catch (e: Exception) {
                Log.e("VisualManager", "Error adding input box view", e)
            }
        }
    }
    // --- REPLACE the hideInputBox method with this simplified version ---
    fun hideInputBox() {
        mainHandler.post {
            inputBoxView?.let {
                if (it.isAttachedToWindow) {
                    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                    imm.hideSoftInputFromWindow(it.windowToken, 0)
                    windowManager.removeView(it)
                }
            }
            inputBoxView = null
        }
    }
    fun hideSpeakingOverlay() {
        mainHandler.post {
            speakingOverlay?.let {
                if (it.isAttachedToWindow) {
                    try {
                        windowManager.removeView(it)
                        Log.d(TAG, "Speaking overlay removed.")
                    } catch (e: Exception) {
                        Log.e(TAG, "Error removing speaking overlay", e)
                    }
                }
            }
            speakingOverlay = null
        }
    }
    // --- Thinking indicator (replace existing methods with these) ---
    fun showThinkingIndicator(initialText: String = "Thinking...") {
        if (thinkingIndicatorView != null) {
            updateThinking(initialText)
            return
        }

        mainHandler.post {
            if (!hasOverlayPermission()) {
                Log.e(TAG, "Cannot show thinking indicator: SYSTEM_ALERT_WINDOW permission not granted")
                return@post
            }

            // If a previous instance exists on window manager, try to remove it silently
            thinkingIndicatorView?.let {
                try { if (it.isAttachedToWindow) windowManager.removeView(it) } catch (_: Exception) {}
            }

            // Build a TextView similar to the transcription view so it looks consistent
            val textView = TextView(context).apply {
                text = initialText
                val glassBackground = GradientDrawable(
                    GradientDrawable.Orientation.TL_BR,
                    intArrayOf(0xDD0D0D2E.toInt(), 0xDD2A0D45.toInt())
                ).apply {
                    cornerRadius = 28f
                    setStroke(1, 0x80FFFFFF.toInt())
                }
                background = glassBackground
                setTextColor(0xFFE0E0E0.toInt())
                textSize = 16f
                setPadding(40, 24, 40, 24)
                typeface = Typeface.MONOSPACE
                // Optional: higher elevation on supported API levels
                ViewCompat.setElevation(this, 12f)
            }

            thinkingIndicatorView = textView

            val params = WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT
            ).apply {
                // Place it above the wave and near center (adjust y as needed)
                gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
                y = 320 // tweak dp offset by multiplying with density if you want to use dp
                // If you want the same y calculation in dp:
                // y = (320 * context.resources.displayMetrics.density).toInt()
            }

            try {
                windowManager.addView(textView, params)
                Log.d(TAG, "Thinking indicator added.")
            } catch (e: Exception) {
                Log.e(TAG, "Error adding thinking indicator", e)
                thinkingIndicatorView = null
            }
        }
    }

    fun updateThinking(text: String) {
        mainHandler.post {
            (thinkingIndicatorView as? TextView)?.text = text
        }
    }

    fun hideThinkingIndicator() {
        mainHandler.post {
            thinkingIndicatorView?.let { view ->
                if (view.isAttachedToWindow) {
                    try {
                        windowManager.removeView(view)
                        Log.d(TAG, "Thinking indicator removed.")
                    } catch (e: Exception) {
                        Log.e(TAG, "Error removing thinking indicator", e)
                    }
                }
            }
            thinkingIndicatorView = null
        }
    }

    fun showSmallDeltaGlow() {
        mainHandler.post {
            if (smallDeltaGlowView?.isAttachedToWindow == true) return@post

            if (!hasOverlayPermission()) {
                Log.e(TAG, "Cannot show small delta glow: SYSTEM_ALERT_WINDOW permission not granted")
                return@post
            }

            smallDeltaGlowView = SmallDeltaGlowView(context)
            val sizeInDp = 64
            val sizeInPixels = (sizeInDp * context.resources.displayMetrics.density).toInt()
            val marginBottomInDp = 48
            val marginBottomInPixels = (marginBottomInDp * context.resources.displayMetrics.density).toInt()

            val params = WindowManager.LayoutParams(
                sizeInPixels, sizeInPixels,
                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                PixelFormat.TRANSLUCENT
            ).apply {
                gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
                y = marginBottomInPixels
            }

            try {
                windowManager.addView(smallDeltaGlowView, params)
                // Set the initial color and glow based on the *current* state
                updateSmallDeltaVisuals(pandaStateManager.getCurrentState())
                Log.d(TAG, "Small delta glow view added.")
            } catch (e: Exception) {
                Log.e(TAG, "Error adding small delta glow view", e)
                smallDeltaGlowView = null
            }
        }
    }

    fun hideSmallDeltaGlow() {
        mainHandler.post {
            smallDeltaGlowView?.let {
                it.stopGlow()
                if (it.isAttachedToWindow) {
                    try {
                        windowManager.removeView(it)
                        Log.d(TAG, "Small delta glow view removed.")
                    } catch (e: Exception) {
                        Log.e(TAG, "Error removing small delta glow view", e)
                    }
                }
            }
            smallDeltaGlowView = null
        }
    }

    /**
     * A new private method to update the small delta's appearance based on the app state.
     */
    private fun updateSmallDeltaVisuals(state: PandaState) {
        // Run on the main thread and only if the view exists
        mainHandler.post {
            smallDeltaGlowView?.let { view ->
                // 1. Get the color for the new state
                val color = DeltaStateColorMapper.getColor(context, state)
                view.setColor(color)

                // 2. Start or stop the glow based on whether the state is "active"
                if (DeltaStateColorMapper.isActiveState(state)) {
                    view.startGlow()
                } else {
                    view.stopGlow()
                }
            }
        }
    }


}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/VoicePreferenceManager.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import com.blurr.voice.api.TTSVoice

object VoicePreferenceManager {
    // FIX: Changed PREFS_NAME to match SettingsActivity for consistency.
    // This ensures both read/write to the same preferences file.
    private const val PREFS_NAME = "BlurrSettings" // THIS LINE WAS CHANGED

    private const val KEY_SELECTED_VOICE = "selected_voice"

    fun getSelectedVoice(context: Context): TTSVoice {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        // Ensure this default also matches your intended default (CHIRP_PUCK)
        val selectedVoiceName = sharedPreferences.getString(KEY_SELECTED_VOICE, TTSVoice.CHIRP_LAOMEDEIA.name)

        return TTSVoice.valueOf(selectedVoiceName ?: TTSVoice.CHIRP_LAOMEDEIA.name)
    }

    fun saveSelectedVoice(context: Context, voice: TTSVoice) {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        sharedPreferences.edit()
            .putString(KEY_SELECTED_VOICE, voice.name)
            .apply()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/utilities/WakeWordManager.kt
================================================
package com.blurr.voice.utilities

import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.blurr.voice.R
import com.blurr.voice.services.EnhancedWakeWordService
import kotlinx.coroutines.launch

class WakeWordManager(
    private val context: Context,
    private val permissionLauncher: ActivityResultLauncher<String>
) {

    fun handleWakeWordButtonClick(wakeWordButton: TextView) {
        if (EnhancedWakeWordService.isRunning) {
            stopWakeWordService()
        } else {
            startWakeWordService()
        }
        updateButtonState(wakeWordButton)
    }

    private fun startWakeWordService() {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {
            val serviceIntent = Intent(context, EnhancedWakeWordService::class.java).apply {
                putExtra(EnhancedWakeWordService.EXTRA_USE_PORCUPINE, true)
            }
            ContextCompat.startForegroundService(context, serviceIntent)
            Toast.makeText(context, context.getString(R.string.wake_word_enabled, "Porcupine"), Toast.LENGTH_SHORT).show()
        } else {
            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
        }
    }

    private fun stopWakeWordService() {
        context.stopService(Intent(context, EnhancedWakeWordService::class.java))
        Toast.makeText(context, context.getString(R.string.wake_word_disabled), Toast.LENGTH_SHORT).show()
    }

    fun updateButtonState(wakeWordButton: TextView) {
        wakeWordButton.text = if (EnhancedWakeWordService.isRunning) {
            context.getString(R.string.wake_word_disabled)
        } else {
            context.getString(R.string.enable_wake_word)
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/Agent.kt
================================================
package com.blurr.voice.v2

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import com.blurr.voice.v2.actions.ActionExecutor
import com.blurr.voice.v2.fs.FileSystem
import com.blurr.voice.v2.llm.GeminiApi
import com.blurr.voice.v2.llm.GeminiMessage
import com.blurr.voice.v2.message_manager.MemoryManager
import com.blurr.voice.v2.perception.Perception
import com.blurr.voice.utilities.SpeechCoordinator
import kotlinx.coroutines.delay

/**
 * The main conductor of the agent.
 * This class owns all the necessary components and runs the primary SENSE -> THINK -> ACT loop.
 *
 * @param settings The agent's configuration.
 * @param memoryManager The agent's short-term memory and prompt builder.
 * @param perception The agent's "eyes," responsible for analyzing the screen.
 * @param llmApi The client for communicating with the Gemini LLM.
 * @param actionExecutor The agent's "hands," responsible for executing actions on the device.
 * @param fileSystem The agent's long-term file storage.
 * @param context The Android application context.
 */
@RequiresApi(Build.VERSION_CODES.R)
class Agent(
    private val settings: AgentSettings,
    private val memoryManager: MemoryManager,
    private val perception: Perception,
    private val llmApi: GeminiApi,
    private val actionExecutor: ActionExecutor,
    private val fileSystem: FileSystem,
    private val context: Context
) {
    // The agent's internal state, which is updated at each step.
    val state: AgentState = AgentState()
    private val TAG = "AgentV2"
    
    // Speech coordinator for voice notifications
    private val speechCoordinator = SpeechCoordinator.getInstance(context)

    // A complete, long-term record of the entire session.
    // We use <Unit> because we haven't defined a custom structured output for the 'done' action yet.
    val history: AgentHistoryList<Unit> = AgentHistoryList()

    /**
     * The main entry point to start the agent's execution loop.
     *
     * @param initialTask The high-level task requested by the user.
     * @param maxSteps The maximum number of steps the agent can take before stopping.
     */
    suspend fun run(initialTask: String, maxSteps: Int = 150) {
        memoryManager.addNewTask(initialTask)
        state.stopped = false
        Log.d(TAG, "--- Agent starting task: '$initialTask' ---")

        while (!state.stopped && state.nSteps <= maxSteps) {
            Log.d(TAG,"\n--- Step ${state.nSteps}/$maxSteps ---")

            // 1. SENSE: Observe the current state of the screen.
            Log.d(TAG,"👀 Sensing screen state...")
            val screenState = perception.analyze()

            // 2. THINK (Prepare Prompt): Update memory with the results of the LAST step
            // and create the new prompt using the CURRENT screen state.
            Log.d(TAG,"🧠 Preparing prompt...")
            memoryManager.createStateMessage(
                modelOutput = state.lastModelOutput,
                result = state.lastResult,
                stepInfo = AgentStepInfo(state.nSteps, maxSteps),
                screenState = screenState
            )

            // 3. THINK (Get Decision): Send the prepared messages to the LLM.
            Log.d(TAG,"🤔 Asking LLM for next action...")
            val messages = memoryManager.getMessages()
            val agentOutput = llmApi.generateAgentOutput(messages)

            // --- Handle LLM Failure ---
            if (agentOutput == null) {
                Log.d(TAG,"❌ LLM failed to return a valid action. Retrying...")
                state.consecutiveFailures++
                // Add a corrective message for the next attempt.
                memoryManager.addContextMessage(GeminiMessage(text = "System Note: Your previous output was not valid JSON. Please ensure your response is correctly formatted."))
                if (state.consecutiveFailures >= settings.maxFailures) {
                    Log.d(TAG,"❌ Agent failed too many times consecutively. Stopping.")
                    speechCoordinator.speakToUser("Agent failed after multiple attempts. Stopping execution.")
                    break
                }
                delay(1000) // Wait a moment before retrying
                continue // Skip to the next loop iteration
            }
            state.consecutiveFailures = 0
            state.lastModelOutput = agentOutput
            Log.d(TAG, agentOutput.toString())
            Log.d(TAG,"🤖 LLM decided: ${agentOutput.nextGoal}")

            // 4. ACT: Execute the LLM's planned actions.
            Log.d(TAG,"💪 Executing actions...")
            val actionResults = mutableListOf<ActionResult>()
            for (action in agentOutput.action) {
                val result = actionExecutor.execute(action, screenState, context, fileSystem)
                actionResults.add(result)
                Log.d(TAG,"  - Action '${action::class.simpleName}' executed. Result: ${result.longTermMemory ?: result.error ?: "OK"}")

                // If an action fails, stop executing further actions in this step.
                if (result.error != null) {
                    Log.d(TAG,"  - 🛑 Action failed. Stopping current step's execution.")
                    break
                }
            }
            state.lastResult = actionResults

            // 5. RECORD: Save the complete step to the long-term history.
            history.addItem(
                AgentHistory(
                    modelOutput = agentOutput,
                    result = actionResults,
                    state = screenState,
                    metadata = null // You can add timing/token metadata here later
                )
            )

            // --- Check for Task Completion ---
            if (actionResults.any { it.isDone == true }) {
                Log.d(TAG,"✅ Agent finished the task.")
                speechCoordinator.speakToUser("Task completed successfully.")
                state.stopped = true
            }

            state.nSteps++
            delay(1000) // A small, polite delay between steps.
        }

        // --- Loop Finished ---
        if (state.nSteps > maxSteps) {
            Log.d(TAG,"--- 🏁 Agent reached max steps. Stopping. ---")
            speechCoordinator.speakToUser("Agent reached maximum steps limit. Stopping execution.")
        } else {
            Log.d(TAG,"--- 🏁 Agent run finished. ---")
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/AgentModel.kt
================================================
package com.blurr.voice.v2

import com.blurr.voice.v2.actions.Action
import com.blurr.voice.v2.message_manager.MemoryState
import com.blurr.voice.v2.perception.ScreenAnalysis
import com.blurr.voice.v2.perception.XmlNode
import kotlinx.serialization.Serializable

// --- Type Aliases and Placeholders ---
// Using a typealias to link the concept of a historical screen state to our existing ScreenAnalysis class.

typealias ScreenState = ScreenAnalysis

// Placeholders for classes that we will define in other modules later.
@Serializable
data class FileSystemState(val files: Map<String, String>) // Simplified placeholder
@Serializable
data class UsageSummary(val totalTokens: Int) // Simplified placeholder

/**
 * Defines the method for tool/function calling.
 */
enum class ToolCallingMethod {
    FUNCTION_CALLING,
    JSON_MODE,
    RAW,
    AUTO,
    TOOLS
}

/**
 * Defines the level of detail for vision models.
 */
enum class VisionDetailLevel {
    AUTO, LOW, HIGH
}

/**
 * Complete configuration options for the Agent.
 */
@Serializable
data class AgentSettings(
    // General
    val saveConversationPath: String? = null,
    val saveConversationPathEncoding: String = "utf-8",
    val maxFailures: Int = 3,
    val retryDelay: Int = 10,
    val validateOutput: Boolean = false,
    val calculateCost: Boolean = false,

    // Timeouts
    val llmTimeout: Int = 60, // in seconds
    val stepTimeout: Int = 180, // in seconds

    // Prompt & Message Configuration
    val overrideSystemMessage: String? = null,
    val extendSystemMessage: String? = null,
    val maxHistoryItems: Int? = null,

    // Action & Behavior Configuration
    val maxActionsPerStep: Int = 10,
    val useThinking: Boolean = true,
    val flashMode: Boolean = false,
    val toolCallingMethod: ToolCallingMethod? = ToolCallingMethod.AUTO,
    val includeToolCallExamples: Boolean = false,

    // Extraction LLM
    val pageExtractionLlm: String? = null // Using String as a placeholder
)

/**
 * Holds all state information for an Agent session.
 */
@Serializable
data class AgentState(
    val agentId: String = java.util.UUID.randomUUID().toString(),
    var nSteps: Int = 1,
    var consecutiveFailures: Int = 0,
    var lastResult: List<ActionResult>? = null,
    var lastPlan: String? = null, //todo check if needed else remove this
    var lastModelOutput: AgentOutput? = null,
    var paused: Boolean = false,
    var stopped: Boolean = false,
    val memoryManagerState: MemoryState = MemoryState(),
    val fileSystemState: FileSystemState? = null
)

/**
 * Information about the current step.
 */
@Serializable
data class AgentStepInfo(
    val stepNumber: Int,
    val maxSteps: Int
) {
    fun isLastStep(): Boolean = stepNumber >= maxSteps - 1
}

/**
 * The result of executing a single action.
 */
@Serializable
data class ActionResult(
    val isDone: Boolean? = false,
    val success: Boolean? = null,
    val error: String? = null,
    val attachments: List<String>? = null,
    val longTermMemory: String? = null,
    val extractedContent: String? = null,
    val includeExtractedContentOnlyOnce: Boolean = false
) {
    init {
        if (success == true && isDone != true) {
            throw IllegalArgumentException(
                "success=true can only be set when isDone=true. For regular actions that succeed, leave success as null."
            )
        }
    }
}

/**
 * The "thought process" of the agent for a single step.
 * In Kotlin, we use nullable fields to handle modes like "flash_mode" where some fields are omitted.
 */
@Serializable
data class AgentBrain(
    val thinking: String?,
    val evaluationPreviousGoal: String?,
    val memory: String?,
    val nextGoal: String?
)

/**
 * The complete, structured output from the LLM for a single step.
 * Nullable fields are used to accommodate different modes (e.g., flash_mode, no_thinking).
 */
@Serializable
data class AgentOutput(
    val thinking: String? = null,
    val evaluationPreviousGoal: String? = null,
    val memory: String? = null,
    val nextGoal: String? = null,
    val action: List<Action>
) {
    val currentState: AgentBrain
        get() = AgentBrain(
            thinking = this.thinking,
            evaluationPreviousGoal = this.evaluationPreviousGoal,
            memory = this.memory,
            nextGoal = this.nextGoal
        )
}

/**
 * Metadata for a single step including timing and token information.
 */
@Serializable
data class StepMetadata(
    val stepStartTime: Double,
    val stepEndTime: Double,
    val stepNumber: Int,
    val inputTokens: Int
) {
    val durationSeconds: Double
        get() = stepEndTime - stepStartTime
}

/**
 * A complete record of a single step in the agent's execution history.
 */
@Serializable
data class AgentHistory(
    val modelOutput: AgentOutput?,
    val result: List<ActionResult>,
    val state: ScreenState,
    val metadata: StepMetadata? = null
) {
    companion object {
        /**
         * Finds the UI elements that were interacted with in this history step
         * by mapping action element IDs to the element map in the screen state.
         */
//        fun getInteractedElements(modelOutput: AgentOutput?, screenState: ScreenState): List<XmlNode?> {
//            if (modelOutput == null) return emptyList()
//
//            return modelOutput.action.map { action ->
//                // Determine the element ID based on the type of action
//                val elementId = when (action) {
//                    is Action.TapElement -> action.elementId
//                    is Action.InputText -> action.index
//                    // Add other element-targeting actions here if necessary
//                    else -> null
//                }
//                // Look up the ID in the screen state's element map
//                elementId?.let { screenState.elementMap[it] }
//            }
//        }
    }
}


/**
 * A list of all agent history steps for a session.
 * The generic type T represents a custom, structured output model for the `done` action.
 */
@Serializable
data class AgentHistoryList<T>(
    val history: MutableList<AgentHistory> = mutableListOf(),
    val usage: UsageSummary? = null // Using placeholder
) {
    /**
     * Calculates the total duration of all steps in seconds.
     */
    val totalDurationSeconds: Double
        get() = history.sumOf { it.metadata?.durationSeconds ?: 0.0 }

    /**
     * Calculates the total approximate input tokens used across all steps.
     */
    val totalInputTokens: Int
        get() = history.sumOf { it.metadata?.inputTokens ?: 0 }

    /**
     * Adds a new history item to the list.
     */
    fun addItem(item: AgentHistory) {
        history.add(item)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/AgentService.kt
================================================
package com.blurr.voice.v2

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import com.blurr.voice.R
import com.blurr.voice.utilities.ApiKeyManager
import com.blurr.voice.api.Eyes
import com.blurr.voice.api.Finger
import com.blurr.voice.utilities.VisualFeedbackManager
import com.blurr.voice.v2.actions.ActionExecutor
import com.blurr.voice.v2.fs.FileSystem
import com.blurr.voice.v2.llm.GeminiApi
import com.blurr.voice.v2.message_manager.MemoryManager
import com.blurr.voice.v2.perception.Perception
import com.blurr.voice.v2.perception.SemanticParser
import com.google.firebase.Firebase
import com.google.firebase.Timestamp
import com.google.firebase.auth.auth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.util.Queue
import java.util.concurrent.ConcurrentLinkedQueue

/**
 * A Foreground Service responsible for hosting and running the AI Agent.
 *
 * This service manages the entire lifecycle of the agent, from initializing its components
 * to running its main loop in a background coroutine. It starts as a foreground service
 * to ensure the OS does not kill it while it's performing a long-running task.
 */
class AgentService : Service() {

    private val TAG = "AgentService"

    // A dedicated coroutine scope tied to the service's lifecycle.
    // Using a SupervisorJob ensures that if one child coroutine fails, it doesn't cancel the whole scope.
    private val serviceScope = CoroutineScope(Dispatchers.Default + SupervisorJob())
    private val visualFeedbackManager by lazy { VisualFeedbackManager.getInstance(this) }

    // Declare agent and its dependencies. They will be initialized in onCreate.
    private val taskQueue: Queue<String> = ConcurrentLinkedQueue()
    private lateinit var agent: Agent
    private lateinit var settings: AgentSettings
    private lateinit var fileSystem: FileSystem
    private lateinit var memoryManager: MemoryManager
    private lateinit var perception: Perception
    private lateinit var llmApi: GeminiApi
    private lateinit var actionExecutor: ActionExecutor
    
    // Firebase instances for task tracking
    private val db = Firebase.firestore
    private val auth = Firebase.auth

//    companion object {
//        private const val NOTIFICATION_CHANNEL_ID = "AgentServiceChannel"
//        private const val NOTIFICATION_ID = 1
//        private const val EXTRA_TASK = "com.blurr.voice.v2.EXTRA_TASK"
//
//        /**
//         * A helper function to easily start the service from anywhere in the app (e.g., an Activity or ViewModel).
//         *
//         * @param context The application context.
//         * @param task The user's high-level task for the agent to perform.
//         */
//        fun start(context: Context, task: String) {
//            Log.d("AgentService", "Starting service with task: $task")
//            val intent = Intent(context, AgentService::class.java).apply {
//                putExtra(EXTRA_TASK, task)
//            }
//            context.startService(intent)
//        }
//    }
//
//
    companion object {
        private const val NOTIFICATION_CHANNEL_ID = "AgentServiceChannelV2"
        private const val NOTIFICATION_ID = 14
        private const val EXTRA_TASK = "com.blurr.voice.v2.EXTRA_TASK"
        private const val ACTION_STOP_SERVICE = "com.blurr.voice.v2.ACTION_STOP_SERVICE"

        @Volatile
        var isRunning: Boolean = false
            private set // Allow external read, but only internal write

        @Volatile
        var currentTask: String? = null
            private set // Allow external read, but only internal write

        /**
         * A public method to request the service to stop from outside.
         */
        fun stop(context: Context) {
            Log.d("AgentService", "External stop request received.")
            val intent = Intent(context, AgentService::class.java).apply {
                action = ACTION_STOP_SERVICE
            }
            context.startService(intent)
        }

        fun start(context: Context, task: String) {
            Log.d("AgentService", "Starting service with task: $task")
            val intent = Intent(context, AgentService::class.java).apply {
                putExtra(EXTRA_TASK, task)
            }
            // Decrement freemium task allowance fairly for every started task
            try {
                // Launch a lightweight coroutine to decrement without blocking the caller
                kotlinx.coroutines.GlobalScope.launch(kotlinx.coroutines.Dispatchers.IO) {
                    try {
                        com.blurr.voice.utilities.FreemiumManager().decrementTaskCount()
                    } catch (_: Exception) {
                        // Swallow to avoid crashing start; logging is done within FreemiumManager
                    }
                }
            } catch (_: Exception) {
                // Defensive: if coroutine infra is unavailable, still proceed to start service
            }
            context.startService(intent)
        }
    }
    @RequiresApi(Build.VERSION_CODES.R)
    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "onCreate: Service is being created.")
        visualFeedbackManager.showTtsWave()

        // Create the notification channel required for foreground services on Android 8.0+
        createNotificationChannel()

        // --- Initialize all the agent's components here ---
        // This is the logic from your example, now placed within the service's lifecycle.
        settings = AgentSettings() // Use default settings for now
        fileSystem = FileSystem(this)
        // Pass an empty initial task; it will be updated in onStartCommand
        memoryManager = MemoryManager(this, "", fileSystem, settings)
        // Assuming Eyes, Finger, and SemanticParser can be instantiated directly
        perception = Perception(Eyes(this), SemanticParser())
        llmApi = GeminiApi(
            "gemini-2.5-flash",
            apiKeyManager = ApiKeyManager,
            maxRetry = 10
        ) // Or your preferred model
        actionExecutor = ActionExecutor(Finger(this))

        // Finally, create the Agent instance with all its dependencies
        agent = Agent(
            settings,
            memoryManager,
            perception,
            llmApi,
            actionExecutor,
            fileSystem,
            this
        )
    }

    @RequiresApi(Build.VERSION_CODES.R)
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "onStartCommand received.")

        // Handle stop action
        if (intent?.action == ACTION_STOP_SERVICE) {
            Log.i(TAG, "Received stop action. Stopping service.")
            stopSelf() // onDestroy will handle cleanup
            return START_NOT_STICKY
        }

        // Add new task to the queue
        intent?.getStringExtra(EXTRA_TASK)?.let {
            if (it.isNotBlank()) {
                Log.d(TAG, "Adding task to queue: $it")
                taskQueue.add(it)
            }
        }

        // If the agent is not already processing tasks, start the loop.
        if (!isRunning && taskQueue.isNotEmpty()) {
            Log.i(TAG, "Agent not running, starting processing loop.")
            serviceScope.launch {
                processTaskQueue()
            }
        } else {
            if(isRunning) Log.d(TAG, "Task added to queue. Processor is already running.")
            else Log.d(TAG, "Service started with no task, waiting for tasks.")
        }

        // Use START_STICKY to ensure the service stays running in the background
        // until we explicitly stop it. This is crucial for a queue-based system.
        return START_STICKY
    }

    @RequiresApi(Build.VERSION_CODES.R)
    private suspend fun processTaskQueue() {
        if (isRunning) {
            Log.d(TAG, "processTaskQueue called but already running.")
            return
        }
        isRunning = true

        Log.i(TAG, "Starting task processing loop.")
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        startForeground(NOTIFICATION_ID, createNotification("Agent is starting..."))

        while (taskQueue.isNotEmpty()) {
            val task = taskQueue.poll() ?: continue // Dequeue task, continue if null
            currentTask = task

            // Update notification for the new task
            notificationManager.notify(NOTIFICATION_ID, createNotification("Agent is running task: $task"))

            try {
                Log.i(TAG, "Executing task: $task")
                trackTaskInFirebase(task)
                agent.run(task)
                trackTaskCompletion(task, true)
                Log.i(TAG, "Task completed successfully: $task")
            } catch (e: Exception) {
                Log.e(TAG, "Task failed with an exception: $task", e)
                trackTaskCompletion(task, false, e.message)
                // Optionally update notification to show error state
            }
        }

        Log.i(TAG, "Task queue is empty. Stopping service.")
        stopSelf() // Stop the service only when the queue is empty
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: Service is being destroyed.")
        // RESET STATUS
        isRunning = false
        currentTask = null
        taskQueue.clear() // Clear any pending tasks

        // Cancel the coroutine scope to clean up the agent's running job and prevent leaks.
        serviceScope.cancel()
        visualFeedbackManager.hideTtsWave()
        Log.i(TAG, "Service destroyed and all resources cleaned up.")
    }

    /**
     * This service does not provide binding, so we return null.
     */
    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    /**
     * Creates the NotificationChannel for the foreground service.
     * This is required for Android 8.0 (API level 26) and higher.
     */
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Agent Service Channel",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(serviceChannel)
        }
    }

    /**
     * Creates the persistent notification for the foreground service.
     */
    private fun createNotification(contentText: String): Notification {
        // Create PendingIntent for the stop action
        val stopIntent = Intent(this, AgentService::class.java).apply {
            action = ACTION_STOP_SERVICE
        }
        val stopPendingIntent = PendingIntent.getService(
            this,
            0,
            stopIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Panda Doing Task (Expand to stop Panda)")
            .setContentText(contentText)
            .addAction(
                android.R.drawable.ic_media_pause, // Using built-in pause icon as stop button
                "Stop Panda",
                stopPendingIntent
            )
            .setOngoing(true) // Makes notification persistent and harder to dismiss
             .setSmallIcon(R.drawable.ic_launcher_foreground)
            .build()
    }

    /**
     * Tracks the task start in Firebase by appending it to the user's task history array.
     * This method is inspired by FreemiumManager's Firebase operations.
     */
    private suspend fun trackTaskInFirebase(task: String) {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            Log.w(TAG, "Cannot track task, user is not logged in.")
            return
        }

        try {
            val taskEntry = hashMapOf(
                "task" to task,
                "status" to "started",
                "startedAt" to Timestamp.now(),
                "completedAt" to null,
                "success" to null,
                "errorMessage" to null
            )

            // Append the task to the user's taskHistory array
            db.collection("users").document(currentUser.uid)
                .update("taskHistory", FieldValue.arrayUnion(taskEntry))
                .await()

            Log.d(TAG, "Successfully tracked task start in Firebase for user ${currentUser.uid}: $task")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to track task in Firebase", e)
            // Don't fail the task execution if Firebase tracking fails
        }
    }

    /**
     * Updates the task completion status in Firebase.
     * Since Firestore doesn't support updating array elements directly,
     * we'll add a new completion entry to track the result.
     */
    private suspend fun trackTaskCompletion(task: String, success: Boolean, errorMessage: String? = null) {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            Log.w(TAG, "Cannot track task completion, user is not logged in.")
            return
        }

        try {
            val completionEntry = hashMapOf(
                "task" to task,
                "status" to if (success) "completed" else "failed",
//                "startedAt" to null, // This is a completion entry, not a start entry
                "completedAt" to Timestamp.now(),
                "success" to success,
                "errorMessage" to errorMessage
            )

            // Append the completion status to the user's taskHistory array
            db.collection("users").document(currentUser.uid)
                .update("taskHistory", FieldValue.arrayUnion(completionEntry))
                .await()

            Log.d(TAG, "Successfully tracked task completion in Firebase for user ${currentUser.uid}: $task (success: $success)")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to track task completion in Firebase", e)
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/v2/PromptBuilder.kt
================================================
package com.blurr.voice.v2

import android.content.Context
import android.util.Log
import com.blurr.voice.v2.actions.Action
import com.blurr.voice.v2.fs.FileSystem
import com.blurr.voice.v2.llm.GeminiMessage
import com.blurr.voice.v2.llm.MessageRole
import com.blurr.voice.v2.llm.TextPart
import java.io.IOException
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import com.blurr.voice.intents.IntentRegistry

private const val DEFAULT_PROMPT_TEMPLATE = "prompts/system_prompt.md"

/**
 * Loads and prepares the system prompt from the default template
 * stored in the app's assets.
 *
 * @param context The Android application context, needed to access the AssetManager.
 */
class SystemPromptLoader(private val context: Context) {

    /**
     * Constructs the final system message.
     *
     * @param settings The agent's configuration.
     * @return A GeminiMessage containing the fully formatted system prompt.
     */
    fun getSystemMessage(settings: AgentSettings): GeminiMessage {
        val actionsDescription = generateActionsDescription()
        val intentsCatalog = generateIntentsCatalog()

        var prompt = settings.overrideSystemMessage ?: loadDefaultTemplate()
            .replace("{max_actions}", settings.maxActionsPerStep.toString())
            .replace("{available_actions}", actionsDescription)

        // Append intents catalog and a usage hint for the launch_intent action
        if (intentsCatalog.isNotBlank()) {
            prompt += "\n\n<intents_catalog>\n$intentsCatalog\n</intents_catalog>\n\n" +
                "Usage: To launch any of the above intents, add an action like {\"launch_intent\": {\"intent_name\": \"Dial\", \"parameters\": {\"phone_number\": \"+123456789\"}}}."
        }

        if (!settings.extendSystemMessage.isNullOrBlank()) {
            prompt += "\n${settings.extendSystemMessage}"
        }
        Log.d("SYSTEM_PROMPT_BUILDER", prompt)
        return GeminiMessage(role = MessageRole.MODEL, parts = listOf(TextPart(prompt)))
    }
    /**
     * NEW: This function generates a structured, LLM-friendly description
     * of all available actions using the single source of truth in Action.kt.
     */
    private fun generateActionsDescription(): String {
        val allActionSpecs = Action.getAllSpecs()
        return buildString {
            allActionSpecs.forEach { spec ->
                append("<action>\n")
                append("  <name>${spec.name}</name>\n")
                append("  <description>${spec.description}</description>\n")
                if (spec.params.isNotEmpty()) {
                    append("  <parameters>\n")
                    spec.params.forEach { param ->
                        append("    <param>\n")
                        append("      <name>${param.name}</name>\n")
                        append("      <type>${param.type.simpleName}</type>\n")
                        append("      <description>${param.description}</description>\n")
                        append("    </param>\n")
                    }
                    append("  </parameters>\n")
                }
                append("</action>\n\n")
            }
        }.trim()
    }

    // New: Describe all registered AppIntents for the model
    private fun generateIntentsCatalog(): String {
        val intents = IntentRegistry.listIntents(context)
        if (intents.isEmpty()) return ""
        return buildString {
            intents.forEach { intent ->
                append("<intent>\n")
                append("  <name>${intent.name}</name>\n")
                append("  <description>${intent.description()}</description>\n")
                val params = intent.parametersSpec()
                if (params.isNotEmpty()) {
                    append("  <parameters>\n")
                    params.forEach { p ->
                        append("    <param>\n")
                        append("      <name>${p.name}</name>\n")
                        append("      <type>${p.type}</type>\n")
                        append("      <required>${p.required}</required>\n")
                        append("      <description>${p.description}</description>\n")
                        append("    </param>\n")
                    }
                    append("  </parameters>\n")
                }
                append("</intent>\n\n")
            }
        }.trim()
    }

    private fun loadDefaultTemplate(): String {
        return try {
            context.assets.open(DEFAULT_PROMPT_TEMPLATE).bufferedReader().use { it.readText() }
        } catch (e: IOException) {
            throw RuntimeException("Failed to load default system prompt template: $DEFAULT_PROMPT_TEMPLATE", e)
        }
    }
}

/**
 * A builder responsible for constructing the detailed user message for each step of the agent's loop.
 * It aggregates all state information into a single, structured prompt.
 */
object UserMessageBuilder {

    /**
     * A data class to hold the numerous arguments required to build the user message.
     */
    data class Args(
        val task: String,
        val screenState: ScreenState,
        val fileSystem: FileSystem,
        val agentHistoryDescription: String?,
        val readStateDescription: String?,
        val stepInfo: AgentStepInfo?,
        val sensitiveDataDescription: String?,
        val availableFilePaths: List<String>?,
        val maxUiRepresentationLength: Int = 40000
    )

    /**
     * The main entry point to build the user message.
     *
     * @param args All the necessary data for constructing the prompt.
     * @return A GeminiMessage ready to be sent to the LLM.
     */
    fun build(args: Args): GeminiMessage {
        val messageContent = buildString {
            append("<agent_history>\n")
            append(args.agentHistoryDescription?.trim() ?: "No history yet.")
            append("\n</agent_history>\n\n")

            append("<agent_state>\n")
            append(buildAgentStateBlock(args))
            append("\n</agent_state>\n\n")

            append("<android_state>\n")
            append(buildAndroidStateBlock(args.screenState, args.maxUiRepresentationLength))
            append("\n</android_state>\n\n")

            if (!args.readStateDescription.isNullOrBlank()) {
                append("<read_state>\n")
                append(args.readStateDescription.trim())
                append("\n</read_state>\n\n")
            }
        }

        return GeminiMessage(text = messageContent.trim())
    }

    private fun buildAndroidStateBlock(screenState: ScreenState, maxUiRepresentationLength: Int): String {
        val originalUiString = screenState.uiRepresentation
        val truncationMessage: String
        val finalUiString: String

        if (originalUiString.length > maxUiRepresentationLength) {
            finalUiString = originalUiString.substring(0, maxUiRepresentationLength)
            truncationMessage = " (truncated to $maxUiRepresentationLength characters)"
        } else {
            finalUiString = originalUiString
            truncationMessage = ""
        }

        return buildString {
            appendLine("Current Activity: ${screenState.activityName}")
            appendLine("Visible elements on the current screen:$truncationMessage")
            append(finalUiString)
        }.trim()
    }

    private fun buildAgentStateBlock(args: Args): String {
        val todoContents = args.fileSystem.getTodoContents().let {
            it.ifBlank { "[Current todo.md is empty, fill it with your plan when applicable]" }
        }

        val stepInfoDescription = args.stepInfo?.let {
            val timeStr = java.text.SimpleDateFormat("yyyy-MM-dd HH:mm", java.util.Locale.getDefault()).format(java.util.Date())
            "Step ${it.stepNumber + 1} of ${it.maxSteps} max possible steps\nCurrent date and time: $timeStr"
        } ?: "Step information not available."

        return buildString {
            appendLine("<user_request>")
            appendLine(args.task)
            appendLine("</user_request>")

            appendLine("<file_system>")
            appendLine(args.fileSystem.describe())
            appendLine("</file_system>")

            appendLine("<todo_contents>")
            appendLine(todoContents)
            appendLine("</todo_contents>")

            if (!args.sensitiveDataDescription.isNullOrBlank()) {
                appendLine("<sensitive_data>")
                appendLine(args.sensitiveDataDescription)
                appendLine("</sensitive_data>")
            }

            appendLine("<step_info>")
            appendLine(stepInfoDescription)
            appendLine("</step_info>")

            if (!args.availableFilePaths.isNullOrEmpty()) {
                appendLine("<available_file_paths>")
                appendLine(args.availableFilePaths.joinToString("\n"))
                appendLine("</available_file_paths>")
            }
        }.trim()
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/actions/Action.kt
================================================
package com.blurr.voice.v2.actions

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.*
import kotlin.reflect.KClass

// Data class to hold parameter metadata without reflection
data class ParamSpec(val name: String, val type: KClass<*>, val description: String)

/** 
 * A sealed class representing all possible type-safe commands the agent can execute.
 * It is annotated to use the custom, data-driven ActionSerializer.
 */
@Serializable(with = Action.ActionSerializer::class)
sealed class Action {
    // Each action is a data class (if it has args) or an object (if it doesn't).
    // Note: Property names here follow Kotlin's camelCase convention.
    data class LongPressElement(val elementId: Int) : Action()
    data class TapElement(val elementId: Int) : Action()
    data object SwitchApp : Action()
    data object Back : Action()
    data object Home : Action()
    data object Wait : Action()
    data class Speak(val message: String) : Action()
    data class Ask(val question: String) : Action()
    data class OpenApp(val appName: String) : Action()
    data class ScrollDown(val amount: Int) : Action()
    data class ScrollUp(val amount: Int) : Action()
    data class SearchGoogle(val query: String) : Action()
    data class TapElementInputTextPressEnter(val index: Int, val text: String) : Action()
    data class InputText(val text: String) : Action()
    data class WriteFile(val fileName: String, val content: String) : Action()
    data class AppendFile(val fileName: String, val content: String) : Action()
    data class ReadFile(val fileName: String) : Action()
    data class Done(val success: Boolean, val text: String, val filesToDisplay: List<String>? = null) : Action()
    // New: Launch an Android AppIntent by name with parameters
    data class LaunchIntent(val intentName: String, val parameters: Map<String, String>) : Action()

    // --- The Custom Serializer ---
    // This serializer is now data-driven, using the `allSpecs` map as its source of truth.
    object ActionSerializer : KSerializer<Action> {
        override val descriptor: SerialDescriptor = buildClassSerialDescriptor("Action")

        override fun serialize(encoder: Encoder, value: Action) {
            throw NotImplementedError("Serialization is not supported for this agent.")
        }

        override fun deserialize(decoder: Decoder): Action {
            val jsonInput = (decoder as JsonDecoder).decodeJsonElement().jsonObject
            val actionName = jsonInput.keys.first()
            val paramsJson = jsonInput[actionName]?.jsonObject

            // Look up the action's specification from our single source of truth.
            val spec = allSpecs[actionName]
                ?: throw IllegalArgumentException("Unknown action received from LLM: $actionName")

            val args = mutableMapOf<String, Any?>()

            // If the action has parameters, parse them according to the spec.
            paramsJson?.let {
                for (paramSpec in spec.params) {
                    val paramName = paramSpec.name
                    val jsonValue = it[paramName]
                        ?: continue // Allow optional parameters

                    // Convert JSON element to the correct Kotlin type.
                    val value = when (paramSpec.type) {
                        Int::class -> jsonValue.jsonPrimitive.int
                        String::class -> jsonValue.jsonPrimitive.content
                        Boolean::class -> jsonValue.jsonPrimitive.boolean
                        List::class -> jsonValue.jsonArray.map { el -> el.jsonPrimitive.content }
                        Map::class -> jsonValue.jsonObject.mapValues { entry ->
                            // We coerce all values to string for intent parameter passing
                            entry.value.jsonPrimitive.content
                        }
                        else -> throw IllegalStateException("Unsupported parameter type in Spec: ${paramSpec.type}")
                    }
                    args[paramName] = value
                }
            }
            // Use the 'build' lambda from the spec to construct the final, type-safe Action object.
            return spec.build(args)
        }
    }

    // --- Companion Object: The Registry and Single Source of Truth ---
    companion object {
        data class Spec(
            val name: String,
            val description: String,
            val params: List<ParamSpec>,
            val build: (args: Map<String, Any?>) -> Action
        )

        // The single source of truth for all actions.
        // Keys and names are now consistently in snake_case for the LLM.
        private val allSpecs: Map<String, Spec> = mapOf(
            "tap_element" to Spec(
                name = "tap_element",
                description = "Tap the element with the specified numeric ID.",
                params = listOf(ParamSpec("element_id", Int::class, "The numeric ID of the element.")),
                build = { args -> TapElement(args["element_id"] as Int) }
            ),
            "switch_app" to Spec("switch_app", "Show the App switcher.", emptyList()) { SwitchApp },
            "back" to Spec("back", "Go back to the previous screen.", emptyList()) { Back },
            "home" to Spec("home", "Go to the device's home screen.", emptyList()) { Home },
            "wait" to Spec("wait", "Wait for a few seconds for loading.", emptyList()) { Wait },
            "speak" to Spec(
                name = "speak",
                description = "Speak the 'message' to the user.",
                params = listOf(ParamSpec("message", String::class, "The message to speak.")),
                build = { args -> Speak(args["message"] as String) }
            ),
            "ask" to Spec(
                name = "ask",
                description = "Ask the 'question' to the user and await a response.",
                params = listOf(ParamSpec("question", String::class, "The question to ask.")),
                build = { args -> Ask(args["question"] as String) }
            ),
            "open_app" to Spec(
                name = "open_app",
                description = "Open the app named 'app_name'.",
                params = listOf(ParamSpec("app_name", String::class, "The name of the app.")),
                build = { args -> OpenApp(args["app_name"] as String) }
            ),
            "swipe_down" to Spec(
                name = "swipe_down",
                description = "swipe down by the specified amount of pixels.",
                params = listOf(ParamSpec("amount", Int::class, "Amount of pixels to swipe down.")),
                build = { args -> ScrollDown(args["amount"] as Int) }
            ),
            "long_press_element" to Spec(
                name = "long_press_element",
                description = "Press and hold the element with the specified numeric ID. Useful for context menus, selecting text, etc.",
                params = listOf(ParamSpec("element_id", Int::class, "The numeric ID of the element to long press.")),
                build = { args -> LongPressElement(args["element_id"] as Int) }
            ),
            "swipe_up" to Spec(
                name = "swipe_up",
                description = "swipe up by the specified amount of pixels.",
                params = listOf(ParamSpec("amount", Int::class, "Amount of pixels to swipe up.")),
                build = { args -> ScrollUp(args["amount"] as Int) }
            ),
            "search_google" to Spec(
                name = "search_google",
                description = "Search Google with the specified query.",
                params = listOf(ParamSpec("query", String::class, "The search query to perform on Google")),
                build = { args -> SearchGoogle(args["query"] as String) }
            ),
            "tap_element_input_text_and_enter" to Spec(
                name = "tap_element_input_text_and_enter",
                description = "Taps an element, inputs text, and presses enter. Useful for search bars.",
                params = listOf(
                    ParamSpec("index", Int::class, "The numerical index of the input element."),
                    ParamSpec("text", String::class, "The text to be typed into the element.")
                ),
                build = { args -> TapElementInputTextPressEnter(args["index"] as Int, args["text"] as String) }
            ),
            "done" to Spec(
                name = "done",
                description = "Completes the current task.",
                params = listOf(
                    ParamSpec("success", Boolean::class, "True if the task was completed successfully, False otherwise."),
                    ParamSpec("text", String::class, "A summary of the results or a final message for the user."),
                    ParamSpec("files_to_display", List::class, "A list of filenames (e.g., ['report.pdf']) to show the user.")
                ),
                build = { args ->
                    @Suppress("UNCHECKED_CAST")
                    Done(
                        args["success"] as Boolean,
                        args["text"] as String,
                        args["files_to_display"] as? List<String>
                    )
                }
            ),
            "write_file" to Spec(
                name = "write_file",
                description = "Write content to a file, overwriting existing content.",
                params = listOf(
                    ParamSpec("file_name", String::class, "The name of the file (e.g., 'notes.txt')."),
                    ParamSpec("content", String::class, "The content to write to the file.")
                ),
                build = { args -> WriteFile(args["file_name"] as String, args["content"] as String) }
            ),
            "append_file" to Spec(
                name = "append_file",
                description = "Append content to the end of a file.",
                params = listOf(
                    ParamSpec("file_name", String::class, "The name of the file to append to."),
                    ParamSpec("content", String::class, "The content to append.")
                ),
                build = { args -> AppendFile(args["file_name"] as String, args["content"] as String) }
            ),
            "read_file" to Spec(
                name = "read_file",
                description = "Read the entire content of a file.",
                params = listOf(ParamSpec("file_name", String::class, "The name of the file to read.")),
                build = { args -> ReadFile(args["file_name"] as String) }
            ),
            "type" to Spec(
                name = "type",
                description = "Type text into a focused input field.",
                params = listOf(ParamSpec("text", String::class, "The text to type.")),
                build = { args -> InputText(args["text"] as String) }
            ),
            // New action spec: launch_intent
            "launch_intent" to Spec(
                name = "launch_intent",
                description = "Launch an Android AppIntent by name with parameters. Use this for OS-level actions like Dial, Share, etc.",
                params = listOf(
                    ParamSpec("intent_name", String::class, "The name of the intent to launch (see intents catalog)."),
                    ParamSpec("parameters", Map::class, "A map of parameter names to their string values as required by the intent.")
                ),
                build = { args ->
                    @Suppress("UNCHECKED_CAST")
                    LaunchIntent(
                        intentName = args["intent_name"] as String,
                        parameters = args["parameters"] as? Map<String, String> ?: emptyMap()
                    )
                }
            ),
        )

//        /**
//         * Returns the specifications for all actions, respecting the agent's configuration.
//         */
//        fun getAvailableSpecs(config: AgentConfig, infoPool: InfoPool): List<Spec> {
//            return allSpecs.values.filter { spec ->
//                when (spec.name) {
//                    "open_app" -> config.enableDirectAppOpening
//                    "type" -> infoPool.keyboardPre
//                    else -> true
//                }
//            }
//        }

        // Add this function inside the companion object in v2/actions/Action.kt

        fun getAllSpecs(): Collection<Spec> {
            return allSpecs.values
        }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/actions/ActionExecutor.kt
================================================
package com.blurr.voice.v2.actions

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.annotation.RequiresApi
import com.blurr.voice.api.Finger
import com.blurr.voice.utilities.SpeechCoordinator
import com.blurr.voice.utilities.UserInputManager
import com.blurr.voice.v2.ActionResult
import com.blurr.voice.v2.fs.FileSystem
import com.blurr.voice.v2.perception.ScreenAnalysis
import com.blurr.voice.intents.IntentRegistry
import kotlinx.coroutines.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import kotlin.text.removePrefix

/**
 * Executes a pre-validated, type-safe Action command.
 * The 'when' block is exhaustive, ensuring every action is handled.
 */
class ActionExecutor(private val finger: Finger) {

    // Add this function inside ActionExecutor.kt, outside the class, or as a private fun.

    private fun findPackageNameFromAppName(appName: String, context: Context): String? {
        val pm = context.packageManager
        val packages = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            pm.getInstalledApplications(PackageManager.ApplicationInfoFlags.of(0L))
        } else {
            @Suppress("DEPRECATION")
            pm.getInstalledApplications(0)
        }

        // First, try for an exact match (case-insensitive)
        for (appInfo in packages) {
            val label = pm.getApplicationLabel(appInfo).toString()
            if (label.equals(appName, ignoreCase = true)) {
                return appInfo.packageName
            }
        }

        // If no exact match, try for a partial match (contains)
        for (appInfo in packages) {
            val label = pm.getApplicationLabel(appInfo).toString()
            if (label.contains(appName, ignoreCase = true)) {
                return appInfo.packageName
            }
        }

        return null // Not found
    }
    private fun getCenterFromBounds(bounds: String): Pair<Int, Int> {
        val regex = """\[(\d+),(\d+)\]\[(\d+),(\d+)\]""".toRegex()
        val match = regex.find(bounds)
        if (match != null) {
            val (l, t, r, b) = match.destructured.toList().map { it.toInt() }
            return Pair((l + r) / 2, (t + b) / 2)
        }
        return Pair(0, 0) // Should not happen if bounds are valid
    }

    /**
     * Executes a single action and returns the result.
     * @return An ActionResult detailing the outcome of the action.
     */
    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun execute(
        action: Action,
        screenAnalysis: ScreenAnalysis,
        context: Context,
        fileSystem: FileSystem
    ): ActionResult {
        // This 'when' block now returns an ActionResult for every case.
        return when (action) {
            is Action.TapElement -> {
                val elementNode = screenAnalysis.elementMap[action.elementId]
                if (elementNode != null) {
                    val bounds = elementNode.attributes["bounds"]
                    val text = elementNode.getVisibleText().replace("\n", " ")
                    val resourceId = elementNode.attributes["resource-id"] ?: ""
                    val extraInfo = elementNode.extraInfo
                    val className = (elementNode.attributes["class"] ?: "").removePrefix("android.")

                    if (bounds != null) {
                        val (centerX, centerY) = getCenterFromBounds(bounds)
                        finger.tap(centerX, centerY)
                        ActionResult(longTermMemory = "Tapped element text:$text <$resourceId> <$extraInfo> <$className>")
                    } else {
                        ActionResult(error = "Element with ID ${action.elementId} has no bounds information.")
                    }
                } else {
                    ActionResult(error = "Element with ID ${action.elementId} not found in the current screen state.")
                }
            }
            is Action.Speak -> {
                // The message is taken directly from the type-safe action class.
                val message = action.message
                runBlocking {
                    SpeechCoordinator.getInstance(context).speakToUser(message)
                }
                ActionResult(longTermMemory = "Spoke the message: \"${message.take(50)}...\"")
            }
            is Action.Ask -> {
                val question = action.question
                val userResponse = withContext(Dispatchers.IO) { // User input is blocking
                    val userInputManager = UserInputManager(context)
                    userInputManager.askQuestion(question) // This internally speaks and listens
                }

                val memory = "Asked user: '$question'. User responded: '$userResponse'."
                ActionResult(
                    longTermMemory = memory,
                    extractedContent = userResponse, // The user's answer is the result
                    includeExtractedContentOnlyOnce = true
                )
            }
            is Action.LongPressElement -> {
                val elementNode = screenAnalysis.elementMap[action.elementId]
                if (elementNode != null) {
                    val bounds = elementNode.attributes["bounds"]
                    val text = elementNode.getVisibleText().replace("\n", " ")
                    val resourceId = elementNode.attributes["resource-id"] ?: ""
                    val extraInfo = elementNode.extraInfo
                    val className = (elementNode.attributes["class"] ?: "").removePrefix("android.")

                    if (bounds != null) {
                        val (centerX, centerY) = getCenterFromBounds(bounds)
                        // Assuming finger has a longPress method. Adjust if necessary.
                        finger.longPress(centerX, centerY)
                        ActionResult(longTermMemory = "Long-pressed element text:$text <$resourceId> <$extraInfo> <$className>")
                    } else {
                        ActionResult(error = "Element with ID ${action.elementId} has no bounds information.")
                    }
                } else {
                    ActionResult(error = "Element with ID ${action.elementId} not found in the current screen state.")
                }
            }
            is Action.OpenApp -> {
                val packageName = findPackageNameFromAppName(action.appName, context)
                if (packageName != null) {
                    val success = finger.openApp(packageName)
                    if (success) {
                        ActionResult(longTermMemory = "Opened app '${action.appName}'.")
                    } else {
                        ActionResult(error = "Failed to open app '${action.appName}' (package: $packageName). Maybe try using different name or use app drawer by scrolling up.")
                    }
                } else {
                    ActionResult(error = "App '${action.appName}' not found. Maybe try using different name or use app drawer by scrolling up.")
                }
            }
            Action.Back -> {
                finger.back()
                ActionResult(longTermMemory = "Pressed the back button.")
            }
            Action.Home -> {
                finger.home()
                ActionResult(longTermMemory = "Pressed the home button.")
            }
            Action.SwitchApp -> {
                finger.switchApp()
                ActionResult(longTermMemory = "Opened the app switcher.")
            }
            Action.Wait -> {
                // Use delay in a coroutine instead of Thread.sleep
                delay(5_000)
                ActionResult(longTermMemory = "Waited for 5 seconds.")
            }
            is Action.ScrollDown -> {
                finger.scrollDown(action.amount)
                ActionResult(longTermMemory = "Scrolled down by ${action.amount} pixels.")
            }
            is Action.ScrollUp -> {
                finger.scrollUp(action.amount)
                ActionResult(longTermMemory = "Scrolled up by ${action.amount} pixels.")
            }
            is Action.SearchGoogle -> {
                // This is a multi-step conceptual action. The executor should handle the concrete steps.
                finger.openApp("com.android.chrome") // More reliable to use package name
                // The next steps (typing, pressing enter) should be decided by the agent in the next turn.
                ActionResult(longTermMemory = "Opened Chrome to search Google.")
            }
            is Action.Done -> {
                // This action doesn't *do* anything. It's a signal to the main loop.
                // We just construct the final ActionResult.
                ActionResult(
                    isDone = true,
                    success = action.success,
                    longTermMemory = "Task finished: ${action.text}",
                    attachments = action.filesToDisplay
                )
            }
//            is Action.ExtractStructuredData -> {
//                // This is a placeholder for a complex action.
//                // A full implementation would require another LLM call with the screen content.
//                // For now, we return an error indicating it's not yet implemented.
//                ActionResult(error = "Action 'ExtractStructuredData' is not yet implemented.")
//            }
            is Action.InputText -> {
                finger.type(action.text)
                ActionResult(longTermMemory = "Input text ${action.text}.")
            }
//            is Action.ScrollToText -> {
//                // As requested, skipping implementation.
//                ActionResult(error = "Action 'ScrollToText' is not implemented.")
//            }
            is Action.AppendFile -> {
                val success = fileSystem.appendFile(action.fileName, action.content)
                if (success) {
                    ActionResult(longTermMemory = "Appended content to '${action.fileName}'.")
                } else {
                    ActionResult(error = "Failed to append to file '${action.fileName}'.")
                }
            }
            is Action.ReadFile -> {
                val content = fileSystem.readFile(action.fileName)
                if (content.startsWith("Error:")) {
                    ActionResult(error = content)
                } else {
                    ActionResult(
                        longTermMemory = "Read content from '${action.fileName}'.",
                        extractedContent = content,
                        includeExtractedContentOnlyOnce = true
                    )
                }
            }
            is Action.WriteFile -> {
                val success = fileSystem.writeFile(action.fileName, action.content)
                if (success) {
                    ActionResult(longTermMemory = "Wrote content to '${action.fileName}'.")
                } else {
                    ActionResult(error = "Failed to write to file '${action.fileName}'.")
                }
            }

//            is Action.ScrollToText -> TODO()
            is Action.TapElementInputTextPressEnter -> {
                val elementNode = screenAnalysis.elementMap[action.index]
                if (elementNode != null) {
                    val bounds = elementNode.attributes["bounds"]
                    val text = elementNode.getVisibleText().replace("\n", " ")
                    val resourceId = elementNode.attributes["resource-id"] ?: ""
                    val extraInfo = elementNode.extraInfo
                    val className = (elementNode.attributes["class"] ?: "").removePrefix("android.")

                    if (bounds != null) {
                        val (centerX, centerY) = getCenterFromBounds(bounds)
                        finger.tap(centerX, centerY)
                        delay(200) // Small delay to ensure focus
                        finger.type(action.text)
                        ActionResult(longTermMemory = "Typed ${action.text} into element  text:$text <$resourceId> <$extraInfo> <$className>.")
                    } else {
                        ActionResult(error = "Element with ID ${action.index} has no bounds information.")
                    }
                } else {
                    ActionResult(error = "Element with ID ${action.index} for input not found.")
                }
            }
            is Action.LaunchIntent -> {
                val name = action.intentName
                val params = action.parameters
                val appIntent = IntentRegistry.findByName(context, name)
                if (appIntent == null) {
                    return ActionResult(error = "Intent '$name' not found. Check intents catalog for valid names.")
                }
                val intent = appIntent.buildIntent(context, params)
                return if (intent == null) {
                    ActionResult(error = "Intent '$name' missing or invalid parameters: ${params}")
                } else {
                    try {
                        val launchSuccess = finger.launchIntent(intent)
                        if (launchSuccess) {
                            ActionResult(longTermMemory = "Launched intent '$name' with params ${params}")
                        } else {
                            ActionResult(error = "Failed to launch intent '$name' with params ${params}")
                        }
                    } catch (t: Throwable) {
                        ActionResult(error = "Failed to launch intent '$name': ${t.message}")
                    }
                }
            }
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/v2/fs/FileSystem.kt
================================================
package com.blurr.voice.v2.fs

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException

/**
 * Manages a sandboxed file system for the agent to store and retrieve information.
 *
 * This class creates a dedicated, private directory for an agent session, preventing
 * interference with other app data or previous agent runs. It provides safe, asynchronous
 * methods for file manipulation.
 *
 * @param context The Android application context, used to access the app's private storage.
 * @param workspaceName The unique name for the agent's sandboxed directory. Defaults to "agent_workspace".
 */
class FileSystem(context: Context, workspaceName: String = "agent_workspace") {

    val workspaceDir: File

    // Pre-defined file handles for convenience
    private val todoFile: File
    private val resultsFile: File

    companion object {
        private const val TAG = "FileSystem"
    }

    init {
        val baseDir = context.filesDir
        workspaceDir = File(baseDir, workspaceName)

        // Ensure the directory exists
        if (!workspaceDir.exists()) {
            workspaceDir.mkdirs()
            Log.i(TAG, "Created new workspace directory at: ${workspaceDir.absolutePath}")
        } else {
            Log.w(TAG, "Workspace directory '$workspaceName' already exists. Reusing it.")
        }

        // --- Archiving and Initialization Logic ---
        archiveOldTodoFile()

        // Initialize file handles for the class properties
        this.todoFile = File(workspaceDir, "todo.md")
        this.resultsFile = File(workspaceDir, "results.md")

        try {
            // Always ensure a fresh, empty todo.md is present
            if (this.todoFile.exists()) this.todoFile.delete()
            this.todoFile.createNewFile()

            // Create results.md only if it doesn't already exist, preserving its content across sessions.
            if (!this.resultsFile.exists()) this.resultsFile.createNewFile()
        } catch (e: IOException) {
            Log.e(TAG, "Failed to create initial files in workspace.", e)
            throw e // Re-throw as this is a critical failure
        }
    }

    /**
     * Checks for an existing todo.md file and renames it with a timestamp to archive it.
     */
    private fun archiveOldTodoFile() {
        val oldTodoFile = File(workspaceDir, "todo.md")
        // Only archive if the file exists and is not empty
        if (oldTodoFile.exists() && oldTodoFile.length() > 0) {
            val timestamp = System.currentTimeMillis()
            val archiveFileName = "todo_ARCHIVED_$timestamp.md"
            val archiveFile = File(workspaceDir, archiveFileName)
            try {
                if (oldTodoFile.renameTo(archiveFile)) {
                    Log.i(TAG, "Successfully archived old todo.md to $archiveFileName")
                } else {
                    Log.w(TAG, "Failed to archive old todo.md.")
                }
            } catch (e: SecurityException) {
                Log.e(TAG, "Security error while trying to archive todo.md.", e)
            }
        }
    }

    /**
     * A private helper to validate that filenames are safe and have an allowed extension.
     * Allowed pattern: alphanumeric characters, underscores, and hyphens, ending in .md or .txt.
     */
    private fun isValidFilename(fileName: String): Boolean {
        // Regex to match safe filenames
        val pattern = Regex("^[a-zA-Z0-9_-]+\\.(md|txt)$")
        return fileName.matches(pattern)
    }

    /**
     * Asynchronously reads the content of a file from the agent's workspace.
     * This operation is performed on a background thread.
     *
     * @param fileName The name of the file to read (e.g., "results.md").
     * @return The content of the file as a String, or an error message if it fails.
     */
    suspend fun readFile(fileName: String): String = withContext(Dispatchers.IO) {
        if (!isValidFilename(fileName)) {
            return@withContext "Error: Invalid filename. Only alphanumeric .md or .txt files are allowed."
        }

        val file = File(workspaceDir, fileName)
        if (!file.exists()) {
            return@withContext "Error: File '$fileName' not found."
        }

        return@withContext try {
            file.readText(Charsets.UTF_8)
        } catch (e: IOException) {
            Log.e(TAG, "Error reading file: $fileName", e)
            "Error: Could not read file '$fileName'."
        }
    }

    /**
     * Asynchronously writes (or overwrites) content to a file in the agent's workspace.
     * This operation is performed on a background thread.
     *
     * @param fileName The name of the file to write to (e.g., "todo.md").
     * @param content The new content for the file.
     * @return True if the write was successful, false otherwise.
     */
    suspend fun writeFile(fileName: String, content: String): Boolean = withContext(Dispatchers.IO) {
        if (!isValidFilename(fileName)) {
            Log.e(TAG, "Invalid filename for write: $fileName")
            return@withContext false
        }

        return@withContext try {
            val file = File(workspaceDir, fileName)
            file.writeText(content, Charsets.UTF_8)
            true
        } catch (e: IOException) {
            Log.e(TAG, "Error writing to file: $fileName", e)
            false
        }
    }

    /**
     * Asynchronously appends content to an existing file in the agent's workspace.
     * This operation is performed on a background thread.
     *
     * @param fileName The name of the file to append to.
     * @param content The content to append.
     * @return True if the append was successful, false otherwise.
     */
    suspend fun appendFile(fileName: String, content: String): Boolean = withContext(Dispatchers.IO) {
        if (!isValidFilename(fileName)) {
            Log.e(TAG, "Invalid filename for append: $fileName")
            return@withContext false
        }

        val file = File(workspaceDir, fileName)
        if (!file.exists()) {
            Log.w(TAG, "File '$fileName' not found for append. A new file will be created.")
        }

        return@withContext try {
            file.appendText(content, Charsets.UTF_8)
            true
        } catch (e: IOException) {
            Log.e(TAG, "Error appending to file: $fileName", e)
            false
        }
    }

    /**
     * Provides a string summary of the files in the workspace, including their line counts.
     * This is intended for use in the agent's prompt. This is a blocking I/O call
     * but is expected to be fast as the number of files is small.
     *
     * @return A formatted string describing the file system state.
     */

    fun describe(): String {
        return try {
            val files = workspaceDir.listFiles { file ->
                file.isFile && !file.name.startsWith("todo_ARCHIVED_")
            }
            if (files.isNullOrEmpty()) {
                return "The file system is empty."
            }
            files.joinToString("\n") { file ->
                try {
                    val lineCount = file.readLines().size
                    "- ${file.name} — $lineCount lines"
                } catch (e: IOException) {
                    "- ${file.name} — [error reading file]"
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error describing file system", e)
            "Error: Could not describe file system."
        }
    }


    /**
     * A synchronous helper to quickly get the contents of the 'todo.md' file.
     *
     * @return The content of todo.md, or an empty string if it cannot be read.
     */
    fun getTodoContents(): String {
        return try {
            if (todoFile.exists()) {
                todoFile.readText(Charsets.UTF_8)
            } else {
                ""
            }
        } catch (e: IOException) {
            Log.e(TAG, "Could not read todo.md", e)
            ""
        }
    }
}



================================================
FILE: app/src/main/java/com/blurr/voice/v2/llm/GeminiAPI.kt
================================================
package com.blurr.voice.v2.llm

import android.util.Log
import com.blurr.voice.BuildConfig
import com.blurr.voice.utilities.ApiKeyManager
import com.blurr.voice.v2.AgentOutput
import com.google.ai.client.generativeai.GenerativeModel
import com.google.ai.client.generativeai.type.Content
import com.google.ai.client.generativeai.type.GenerationConfig
import com.google.ai.client.generativeai.type.RequestOptions
import com.google.ai.client.generativeai.type.content
import kotlinx.coroutines.delay
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap
import kotlin.time.Duration.Companion.seconds

/**
 * A modern, robust Gemini API client using the official Google AI SDK.
 *
 * This client features:
 * - Conversion of internal message formats to the SDK's `Content` format.
 * - API key management and rotation via an injectable [ApiKeyManager].
 * - An idiomatic, exponential backoff retry mechanism for API calls.
 * - Efficient caching of `GenerativeModel` instances to reduce overhead.
 * - Structured JSON output enforcement using `response_schema`.
 *
 * @property modelName The name of the Gemini model to use (e.g., "gemini-1.5-flash").
 * @property apiKeyManager An instance of [ApiKeyManager] to handle API key retrieval.
 * @property maxRetry The maximum number of times to retry a failed API call.
 */
class GeminiApi(
    private val modelName: String,
    private val apiKeyManager: ApiKeyManager, // Injected dependency
    private val maxRetry: Int = 3
) {

    companion object {
        private const val TAG = "GeminiV2Api"
        private val JSON_MEDIA_TYPE = "application/json; charset=utf-8".toMediaType()
    }

    private val proxyUrl: String = BuildConfig.GCLOUD_PROXY_URL
    private val proxyKey: String = BuildConfig.GCLOUD_PROXY_URL_KEY

    private val httpClient = OkHttpClient()

    private val jsonParser = Json {
        ignoreUnknownKeys = true
        isLenient = true
        coerceInputValues = true
    }

    // Cache for GenerativeModel instances to avoid repeated initializations.
    private val modelCache = ConcurrentHashMap<String, GenerativeModel>()



    private val jsonGenerationConfig = GenerationConfig.builder().apply {
        responseMimeType = "application/json"
//        responseSchema = agentOutputSchema
    }.build()

    private val requestOptions = RequestOptions(timeout = 60.seconds)


    /**
     * Generates a structured response from the Gemini model and parses it into an [AgentOutput] object.
     * This is the primary public method for this class.
     *
     * @param messages The list of [GeminiMessage] objects for the prompt.
     * @return An [AgentOutput] object on success, or null if the API call or parsing fails after all retries.
     */
    suspend fun generateAgentOutput(messages: List<GeminiMessage>): AgentOutput? {
        val jsonString = retryWithBackoff(times = maxRetry) {
            performApiCall(messages)
        } ?: return null

        return try {
            Log.d(TAG, "Parsing guaranteed JSON response. $jsonString")
            Log.d("GEMINIAPITEMP_OUTPUT", jsonString)
            jsonParser.decodeFromString<AgentOutput>(jsonString)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse JSON into AgentOutput. Error: ${e.message}", e)
            null
        }
    }

    /**
     * AUTOMATIC DISPATCHER: Checks internal config and decides whether to use
     * the secure proxy or a direct API call.
     */
    private suspend fun performApiCall(messages: List<GeminiMessage>): String {
        return if (!proxyUrl.isNullOrBlank() && !proxyKey.isNullOrBlank()) {
            Log.i(TAG, "Proxy config found. Using secure Cloud Function.")
            performProxyApiCall(messages)
        } else {
            Log.i(TAG, "Proxy config not found. Using direct Gemini SDK call (Fallback).")
            performDirectApiCall(messages)
        }
    }

    /**
     * PROXY MODE: Performs the API call through the secure Google Cloud Function.
     */
    private suspend fun performProxyApiCall(messages: List<GeminiMessage>): String {
        val proxyMessages = messages.map {
            ProxyRequestMessage(
                role = it.role.name.lowercase(),
                parts = it.parts.filterIsInstance<TextPart>().map { part -> ProxyRequestPart(part.text) }
            )
        }
        val requestPayload = ProxyRequestBody(modelName, proxyMessages)
        val jsonBody = jsonParser.encodeToString(ProxyRequestBody.serializer(), requestPayload)

        val request = Request.Builder()
            .url(proxyUrl)
            .post(jsonBody.toRequestBody(JSON_MEDIA_TYPE))
            .addHeader("Content-Type", "application/json")
            .addHeader("X-API-Key", proxyKey)
            .build()

        httpClient.newCall(request).execute().use { response ->
            val responseBodyString = response.body?.string()
            if (!response.isSuccessful || responseBodyString.isNullOrBlank()) {
                val errorMsg = "Proxy API call failed with code: ${response.code}, body: $responseBodyString"
                Log.e(TAG, errorMsg)
                throw IOException(errorMsg)
            }
            Log.d(TAG, "Successfully received response from proxy.")
            return responseBodyString
        }
    }

    /**
     * DIRECT MODE: Performs the API call using the embedded Google AI SDK.
     */
    private suspend fun performDirectApiCall(messages: List<GeminiMessage>): String {
        val apiKey = apiKeyManager.getNextKey()
        val generativeModel = modelCache.getOrPut(apiKey) {
            Log.d(TAG, "Creating new GenerativeModel instance for key ending in ...${apiKey.takeLast(4)}")
            GenerativeModel(
                modelName = modelName,
                apiKey = apiKey,
                generationConfig = jsonGenerationConfig,
                requestOptions = requestOptions
            )
        }
        val history = convertToSdkHistory(messages)
        val response = generativeModel.generateContent(*history.toTypedArray())
        response.text?.let {
            Log.d(TAG, "Successfully received response from model.")
            return it
        }
        val reason = response.promptFeedback?.blockReason?.name ?: "UNKNOWN"
        throw ContentBlockedException("Blocked or empty response from API. Reason: $reason")
    }

    /**
     * Converts the internal `List<GeminiMessage>` to the `List<Content>` required by the Google AI SDK.
     */
    private fun convertToSdkHistory(messages: List<GeminiMessage>): List<Content> {
        return messages.map { message ->
            val role = when (message.role) {
                MessageRole.USER -> "user"
                MessageRole.MODEL -> "model"
                MessageRole.TOOL -> "tool"
            }

            content(role) {
                message.parts.forEach { part ->
                    if (part is TextPart) {
                        text(part.text)
                        if(part.text.startsWith("<agent_history>") || part.text.startsWith("Memory:")) {
                            Log.d("GEMINIAPITEMP_INPUT", part.text)
                        }
                    }
                    // Handle other part types like images here if needed in the future.
                }
            }
        }
    }

    /**
     * WORKAROUND: Generates content using a direct REST API call to enable Google Search grounding.
     * This should be used for queries requiring real-time information until the Kotlin SDK
     * officially supports the search tool.
     *
     * @param prompt The user's text prompt.
     * @return The generated text content as a String, or null on failure.
     */
    suspend fun generateGroundedContent(prompt: String): String? {
        val apiKey = apiKeyManager.getNextKey() // Reuse your existing key manager

        val mediaType = "application/json; charset=utf-8".toMediaType()
        val url = "https://generativelanguage.googleapis.com/v1beta/models/$modelName:generateContent"

        // 1. Manually construct the JSON body to include the "google_search" tool
        val jsonBody = """
        {
          "contents": [
            {
              "parts": [
                {"text": "$prompt"}
              ]
            }
          ],
          "tools": [
            {
              "google_search": {}
            }
          ]
        }
    """.trimIndent()

        val requestBody = jsonBody.toRequestBody(mediaType)

        val request = Request.Builder()
            .url(url)
            .post(requestBody)
            .addHeader("x-goog-api-key", apiKey)
            .build()

        return try {
            val response = httpClient.newCall(request).execute()
            val responseBody = response.body?.string()

            if (!response.isSuccessful || responseBody == null) {
                Log.e(TAG, "Grounded API call failed with code: ${response.code}, body: $responseBody")
                return null
            }

            // 2. Parse the JSON response to extract the model's text output
            val text = JSONObject(responseBody)
                .getJSONArray("candidates")
                .getJSONObject(0)
                .getJSONObject("content")
                .getJSONArray("parts")
                .getJSONObject(0)
                .getString("text")

            Log.d(TAG, "Successfully received grounded response.")
            text

        } catch (e: Exception) {
            Log.e(TAG, "Exception during grounded API call", e)
            null
        }
    }

}

@Serializable
private data class ProxyRequestPart(val text: String)

@Serializable
private data class ProxyRequestMessage(val role: String, val parts: List<ProxyRequestPart>)

@Serializable
private data class ProxyRequestBody(val modelName: String, val messages: List<ProxyRequestMessage>)


/**
 * Custom exception to indicate that the response content was blocked by the API.
 */
class ContentBlockedException(message: String) : Exception(message)

/**
 * A higher-order function that provides a generic retry mechanism with exponential backoff.
 *
 * @param times The maximum number of retry attempts.
 * @param initialDelay The initial delay in milliseconds before the first retry.
 * @param maxDelay The maximum delay in milliseconds.
 * @param factor The multiplier for the delay on each subsequent retry.
 * @param block The suspend block of code to execute and retry on failure.
 * @return The result of the block if successful, or null if all retries fail.
 */
private suspend fun <T> retryWithBackoff(
    times: Int,
    initialDelay: Long = 1000L, // 1 second
    maxDelay: Long = 16000L,   // 16 seconds
    factor: Double = 2.0,
    block: suspend () -> T
): T? {
    var currentDelay = initialDelay
    repeat(times) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            Log.e("RetryUtil", "Attempt ${attempt + 1}/$times failed: ${e.message}", e)
            if (attempt == times - 1) {
                Log.e("RetryUtil", "All $times retry attempts failed.")
                return null // All retries failed
            }
            delay(currentDelay)
            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
        }
    }
    return null // Should not be reached
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/llm/models.kt
================================================
package com.blurr.voice.v2.llm

import kotlinx.serialization.Serializable

/**
 * Represents the role of the entity creating the message.
 * The 'tool' role is for responses from function calls.
 */
enum class MessageRole {
    USER,
    MODEL,
    TOOL
}

/**
 * A sealed interface representing a part of a message.
 * For now, we only support text parts.
 */
@Serializable
sealed interface ContentPart

@Serializable
data class TextPart(val text: String) : ContentPart

/**
 * Represents a single message in the conversation history.
 * A message consists of a role and one or more content parts.
 *
 * @param role The role of the message author (USER, MODEL, or TOOL).
 * @param parts A list of content parts that make up the message. For this version, it will contain one or more TextPart objects.
 * @param toolCode An optional identifier for the tool call, used for TOOL role messages.
 */
@Serializable
data class GeminiMessage(
    val role: MessageRole,
    val parts: List<ContentPart>,
    val toolCode: String? = null
) {
    // Convenience constructor for simple text messages from the USER
    constructor(text: String) : this(
        role = MessageRole.USER,
        parts = listOf(TextPart(text))
    )
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/message_manager/MessageManager.kt
================================================
package com.blurr.voice.v2.message_manager

import android.content.Context
import com.blurr.voice.v2.ActionResult
import com.blurr.voice.v2.AgentOutput
import com.blurr.voice.v2.AgentSettings
import com.blurr.voice.v2.AgentStepInfo
import com.blurr.voice.v2.ScreenState
import com.blurr.voice.v2.SystemPromptLoader
import com.blurr.voice.v2.UserMessageBuilder
import com.blurr.voice.v2.fs.FileSystem
import com.blurr.voice.v2.llm.GeminiMessage
import com.blurr.voice.v2.llm.TextPart

/**
 * Manages the agent's short-term memory, including conversation history and prompt construction.
 * This class is the central hub for managing the state that gets sent to the LLM.
 *
 * @param context The Android application context.
 * @param task The initial user request or task for the agent.
 * @param fileSystem An instance of the agent's file system.
 * @param settings The agent's configuration settings.
 * @param sensitiveData A map of placeholder keys to sensitive string values to be filtered from prompts.
 * @param initialState An optional initial state to resume from a previous session.
 */
class MemoryManager(
    context: Context,
    private var task: String,
    private val fileSystem: FileSystem,
    private val settings: AgentSettings,
    private val sensitiveData: Map<String, String>? = null,
    initialState: MemoryState = MemoryState()
) {
    val state: MemoryState = initialState

    init {
        // On initialization, create and set the system message if it doesn't already exist.
        if (state.history.systemMessage == null) {
            val systemPromptLoader = SystemPromptLoader(context)
            val systemMessage = systemPromptLoader.getSystemMessage(settings)
            state.history.systemMessage = filterSensitiveData(systemMessage)
        }
    }

    /**
     * The primary method to update the memory and generate the next prompt.
     * This should be called once per agent step.
     */
    fun createStateMessage(
        modelOutput: AgentOutput?,
        result: List<ActionResult>?,
        stepInfo: AgentStepInfo?,
        screenState: ScreenState
    ) {
        // 1. Update the structured history with the outcome of the last step.
        updateHistory(modelOutput, result, stepInfo)

        // 2. Build the arguments for the prompt builder.
        val builderArgs = UserMessageBuilder.Args(
            task = this.task,
            screenState = screenState,
            fileSystem = this.fileSystem,
            agentHistoryDescription = getAgentHistoryDescription(),
            readStateDescription = state.readStateDescription,
            stepInfo = stepInfo,
            sensitiveDataDescription = getSensitiveDataDescription(),
            availableFilePaths = null // Assuming we get this from fileSystem or elsewhere
        )

        // 3. Construct the new user message using the builder.
        var stateMessage = UserMessageBuilder.build(builderArgs)
        stateMessage = filterSensitiveData(stateMessage)

        // 4. Update the history with the new state message, clearing old context.
        state.history.stateMessage = stateMessage
        state.history.contextMessages.clear()
    }

    /**
     * Adds a new task, replacing the old one, and records this change in the history.
     */
    fun addNewTask(newTask: String) {
        this.task = newTask

        // A system notification item only needs the 'systemMessage' field.
        // The other fields are nullable and will default to null, which is correct.
        val taskUpdateItem = HistoryItem(
            stepNumber = 0,
            systemMessage = "<user_request> added: $newTask"
        )

        state.agentHistoryItems.add(taskUpdateItem)
    }

    fun addContextMessage(message: GeminiMessage){
        //TODO implement filtering here too
        state.history.contextMessages.add(message)
    }

    /**
     * Returns the complete list of messages ready to be sent to the LLM.
     */
    fun getMessages(): List<GeminiMessage> {
        return state.history.getMessages()
    }

    /**
     * Processes the results of the last step and adds a new `HistoryItem` to the state.
     */
    private fun updateHistory(
        modelOutput: AgentOutput?,
        result: List<ActionResult>?,
        stepInfo: AgentStepInfo?
    ) {
        // Clear the one-time read state from the previous turn.
        state.readStateDescription = ""

        val actionResultsText = result?.mapIndexedNotNull { index, actionResult ->
            // Populate the one-time read state if necessary
            if (actionResult.includeExtractedContentOnlyOnce && !actionResult.extractedContent.isNullOrBlank()) {
                state.readStateDescription += actionResult.extractedContent + "\n"
            }

            // Format the action result for long-term history
            when {
                !actionResult.longTermMemory.isNullOrBlank() -> "Action ${index + 1}: ${actionResult.longTermMemory}"
                !actionResult.extractedContent.isNullOrBlank() && !actionResult.includeExtractedContentOnlyOnce -> "Action ${index + 1}: ${actionResult.extractedContent}"
                !actionResult.error.isNullOrBlank() -> "Action ${index + 1}: ERROR - ${actionResult.error.take(200)}"
                else -> null
            }
        }?.joinToString("\n")

        val historyItem = if (modelOutput == null) {
            if(stepInfo?.stepNumber != 1){
                HistoryItem(stepNumber = stepInfo?.stepNumber, error = "Agent failed to produce a valid output.")
            }else{
                HistoryItem(stepNumber = stepInfo.stepNumber, error = "Agent not asked to create output yet")
            }
        } else {
            HistoryItem(
                stepNumber = stepInfo?.stepNumber,
                evaluation = modelOutput.evaluationPreviousGoal,
                memory = modelOutput.memory,
                nextGoal = modelOutput.nextGoal,
                actionResults = actionResultsText?.let { "Action Results:\n$it" }
            )
        }
        state.agentHistoryItems.add(historyItem)
    }

    /**
     * Generates the <agent_history> string, truncating it if it exceeds `maxHistoryItems`.
     */
    private fun getAgentHistoryDescription(): String {
        val items = state.agentHistoryItems
        val maxItems = settings.maxHistoryItems ?: items.size

        if (items.size <= maxItems) {
            return items.joinToString("\n") { it.toPromptString() }
        }

        val omittedCount = items.size - maxItems
        val recentItemsCount = maxItems - 1

        val result = mutableListOf<String>()
        result.add(items.first().toPromptString()) // Always include the first item
        result.add("<sys>[... $omittedCount previous steps omitted...]</sys>")
        result.addAll(items.takeLast(recentItemsCount).map { it.toPromptString() })

        return result.joinToString("\n")
    }

    /**
     * Creates a description of available sensitive data placeholders.
     * This is simplified as the URL-matching logic is not applicable.
     */
    private fun getSensitiveDataDescription(): String? {
        val placeholders = sensitiveData?.keys
        if (placeholders.isNullOrEmpty()) return null

        return "Here are placeholders for sensitive data:\n${placeholders.joinToString()}\nTo use them, write <secret>the placeholder name</secret>"
    }

    /**
     * Scrubs sensitive data from a message before sending it to the LLM.
     */
    private fun filterSensitiveData(message: GeminiMessage): GeminiMessage {
        if (sensitiveData.isNullOrEmpty()) return message

        val newParts = message.parts.map { part ->
            if (part is TextPart) {
                var newText = part.text
                sensitiveData.forEach { (key, value) ->
                    newText = newText.replace(value, "<secret>$key</secret>")
                }
                TextPart(newText)
            } else {
                part
            }
        }
        return message.copy(parts = newParts)
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/message_manager/models.kt
================================================
package com.blurr.voice.v2.message_manager

import com.blurr.voice.v2.llm.GeminiMessage
import kotlinx.serialization.Serializable


/**
 * Represents a single item in the agent's high-level history summary.
 * This is used to build the <agent_history> section of the prompt.
 */
@Serializable
data class HistoryItem(
    val stepNumber: Int? = null,
    val evaluation: String? = null,
    val memory: String? = null,
    val nextGoal: String? = null,
    val actionResults: String? = null,
    val error: String? = null,
    val systemMessage: String? = null // For special messages like "Task updated"
) {
    /**
     * Formats this item into a string for the LLM prompt.
     */
    fun toPromptString(): String {
        val stepStr = stepNumber?.let { "step_$it" } ?: "step_unknown"
        val content = when {
            error != null -> error
            systemMessage != null -> systemMessage
            else -> listOfNotNull(
                evaluation?.let { "Evaluation of Previous Step: $it" },
                memory?.let { "Memory: $it" },
                nextGoal?.let { "Next Goal: $it" },
                actionResults
            ).joinToString("\n")
        }
        return "<$stepStr>\n$content\n</$stepStr>"
    }
}


/**
 * Holds the current, structured message history to be sent to the LLM.
 * It separates the static system prompt from the dynamic state message.
 */
@Serializable
data class MessageHistory(
    var systemMessage: GeminiMessage?,
    var stateMessage: GeminiMessage?,
    val contextMessages: MutableList<GeminiMessage> = mutableListOf() // For temporary, one-off messages
) {
    /**
     * Assembles all messages in the correct order for the LLM API call.
     */
    fun getMessages(): List<GeminiMessage> {
        return listOfNotNull(systemMessage, stateMessage) + contextMessages
    }
}


/**
 * The complete, self-contained state of the MemoryManager.
 * This can be saved and loaded to resume an agent's session.
 */
@Serializable
data class MemoryState(
    val history: MessageHistory = MessageHistory(null, null),
    val toolId: Int = 1,
    val agentHistoryItems: MutableList<HistoryItem> = mutableListOf(
        HistoryItem(stepNumber = 0, systemMessage = "Agent initialized")
    ),
    var readStateDescription: String = ""
)


================================================
FILE: app/src/main/java/com/blurr/voice/v2/perception/Perception.kt
================================================
package com.blurr.voice.v2.perception

import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import com.blurr.voice.RawScreenData
import com.blurr.voice.api.Eyes
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.async

/**
 * The Perception module is responsible for observing the device screen and
 * creating a structured analysis of the current state.
 *
 * @param eyes An instance of the Eyes class to see the screen (XML, screenshot).
 * @param semanticParser An instance of the SemanticParser to make sense of the XML.
 */
@RequiresApi(Build.VERSION_CODES.R)
class Perception(
    private val eyes: Eyes,
    private val semanticParser: SemanticParser
) {

    /**
     * Analyzes the current screen to produce a comprehensive ScreenAnalysis object.
     * This is the main entry point for this module.
     *
     * It performs multiple observation actions concurrently for efficiency.
     *
     * @param previousState An optional set of node identifiers from the previous state,
     * used to detect new UI elements.
     * @return A ScreenAnalysis object containing the complete state of the screen.
     */
    suspend fun analyze(previousState: Set<String>? = null): ScreenAnalysis {
        return coroutineScope {
//        val screenshotDeferred = async { eyes.openEyes() }
        val rawDataDeferred = async { eyes.getRawScreenData() }
        val keyboardStatusDeferred = async { eyes.getKeyBoardStatus() }
        val currentActivity = async { eyes.getCurrentActivityName() }
//        val screenshot = screenshotDeferred.await()
        val rawData = rawDataDeferred.await() ?: RawScreenData(
            "<hierarchy error=\"service not available\"/>", 0, 0, 0,0
        )
        val isKeyboardOpen = keyboardStatusDeferred.await()

        // Assume you have a way to get this
        val activityName = currentActivity.await()

        // Parse the XML from the raw data
        Log.d("ScreenAnal", rawData.xml)
        val parseResult = semanticParser.toHierarchicalString(rawData.xml, previousState, rawData.screenWidth, rawData.screenHeight)
        var uiRepresentation = parseResult.first
        val elementMap = parseResult.second

        val hasContentAbove = rawData.pixelsAbove > 0
        val hasContentBelow = rawData.pixelsBelow > 0

        if (uiRepresentation.isNotBlank()) {
            if (hasContentAbove) {
                uiRepresentation = "... ${rawData.pixelsAbove} pixels above - scroll up to see more ...\n$uiRepresentation"
            } else {
                uiRepresentation = "[Start of page]\n$uiRepresentation"
            }
            if (hasContentBelow) {
                uiRepresentation = "$uiRepresentation\n... ${rawData.pixelsBelow} pixels below - scroll down to see more ..."
            } else {
                uiRepresentation = "$uiRepresentation\n[End of page]"
            }
        } else {
            uiRepresentation = "The screen is empty or contains no interactive elements."
        }

        ScreenAnalysis(
            uiRepresentation = uiRepresentation, // The newly formatted string
            isKeyboardOpen = isKeyboardOpen,
            activityName = activityName,
            elementMap = elementMap,
            scrollUp = rawData.pixelsAbove, // Store the raw numbers
            scrollDown = rawData.pixelsBelow  // Store the raw numbers
        )
    }
    }
}


================================================
FILE: app/src/main/java/com/blurr/voice/v2/perception/ScreenAnalysis.kt
================================================
package com.blurr.voice.v2.perception

import android.graphics.Bitmap
import kotlinx.serialization.Serializable

/**
 * A data class that holds a complete analysis of the screen at a single point in time.
 * This is the primary output of the Perception module.
 *
 * @param uiRepresentation A clean, LLM-friendly string describing the UI elements.
 * @param screenshot A bitmap of the current screen, used for vision models.
 * @param isKeyboardOpen True if the software keyboard is likely visible.
 * @param activityName The name of the current foreground activity for context.
 * @param elementMap A map from the integer ID `[1]` in the uiRepresentation to the
 * actual XmlNode object, allowing the ActionExecutor to find center coordinates.
 */
@Serializable
data class ScreenAnalysis(
    val uiRepresentation: String,
    val isKeyboardOpen: Boolean,
    val activityName: String,
    val elementMap: Map<Int, XmlNode>,
    val scrollUp: Int?,
    val scrollDown: Int?
)



================================================
FILE: app/src/main/java/com/blurr/voice/v2/perception/SemanticParser.kt
================================================
package com.blurr.voice.v2.perception

import android.util.Log
import kotlinx.serialization.Serializable
import org.xmlpull.v1.XmlPullParser
import org.xmlpull.v1.XmlPullParserFactory
import java.io.StringReader

/**
 * Represents a node in the XML view hierarchy.
 *
 * This data class holds the attributes of the XML node, its children, and a reference to its parent.
 * It also includes several helper properties and functions for convenience.
 *
 * @property attributes A map of the node's XML attributes (e.g., "text", "resource-id").
 * @property children A list of child [XmlNode]s.
 * @property parent A nullable reference to the parent [XmlNode].
 */
@Serializable
data class XmlNode(
    val attributes: MutableMap<String, String> = mutableMapOf(),
    val children: MutableList<XmlNode> = mutableListOf(),
    var parent: XmlNode? = null
) {

    override fun toString(): String {
        val text = getVisibleText().let { if (it.isNotBlank()) "text='$it'" else "" }
        val resId = attributes["resource-id"]?.let { "id='$it'" } ?: ""
        return "XmlNode($text $resId, children=${children.size})"
    }

    /**
     * A descriptive string of the node's boolean properties that are true.
     * Example: "This element is enabled, clickable, focused."
     */
    val extraInfo: String
        get() {
            val infoParts = mutableListOf<String>()
            val propertiesToCheck = listOf(
                "checkable", "checked", "clickable", "enabled", "focusable",
                "focused", "scrollable", "long-clickable", "selected"
            )

            propertiesToCheck.forEach { prop ->
                if (attributes[prop] == "true") {
                    // e.g., "long-clickable" becomes "long clickable"
                    infoParts.add(prop.replace("-", " "))
                }
            }

            return if (infoParts.isNotEmpty()) {
                "This element is ${infoParts.joinToString(", ")}."
            } else {
                ""
            }
        }

    /**
     * Determines if a node is semantically important based on its attributes.
     * An element is important if it has a non-empty `resource-id`, `text`, or `content-desc`.
     */
    fun isSemanticallyImportant(): Boolean {
        return attributes["resource-id"]?.isNotBlank() == true ||
                attributes["text"]?.isNotBlank() == true ||
                attributes["content-desc"]?.isNotBlank() == true
    }

    /**
     * Determines if a node is interactive (clickable or long-clickable).
     */
    fun isInteractive(): Boolean {
        if (attributes["enabled"] == "false") {
            return false
        }
        if (attributes["clickable"] == "true" ||
            attributes["long-clickable"] == "true" ||
            attributes["checkable"] == "true" ||
            attributes["scrollable"] == "true" ||
            attributes["class"] == "android.widget.EditText" ||
            attributes["password"] == "true" ||
            attributes["focusable"] == "true") {
            return true
        }

        return false
    }

    /**
     * Returns the visible text of the node, preferring `text` over `content-desc`.
     * Returns an empty string if neither is present.
     */
    fun getVisibleText(): String {
        return attributes["text"]?.takeIf { it.isNotBlank() }
            ?: attributes["content-desc"]?.takeIf { it.isNotBlank() }
            ?: ""
    }

    /**
     * Checks if the node's bounds are physically within the screen dimensions.
     * An element is considered visible if it has at least one pixel on the screen.
     */
    fun isVisibleOnScreen(screenWidth: Int, screenHeight: Int): Boolean {
        val boundsStr = attributes["bounds"] ?: return false

        val regex = """\[(\d+),(\d+)\]\[(\d+),(\d+)\]""".toRegex()
        val matchResult = regex.find(boundsStr) ?: return false

        return try {
            val (left, top, right, bottom) = matchResult.destructured.toList().map { it.toInt() }

            // Element is invisible if it's entirely off-screen
            if (right <= 0 || left >= screenWidth || bottom <= 0 || top >= screenHeight) {
                return false
            }

            // If it's not entirely off-screen, it's visible
            true
        } catch (e: NumberFormatException) {
            false
        }
    }
}

/**
 * Parses an Android View Hierarchy XML dump.
 *
 * This class can filter the XML to keep only semantically important nodes and can also
 * generate a custom string representation of the hierarchy that focuses on interactive elements.
 * It allows for retrieving the coordinates of these interactive elements by their generated index.
 */
class SemanticParser {

    // Stores a map of Integer index -> XmlNode for interactive elements from the last parse.
    private val interactiveNodeMap = mutableMapOf<Int, XmlNode>()
    private var interactiveElementCounter = 0
    private var screenWidth: Int = 0
    private var screenHeight: Int = 0
    // --- New Public API ---

    /**
     * Parses the XML tree into a custom string format highlighting interactive elements.
     *
     * Rules:
     * - Only interactive elements get a numeric index like `[1]`.
     * - Child elements are indented with tabs (`\t`).
     * - Elements marked with `*` are new compared to the `previousNodes` set.
     * - Non-interactive elements with text are shown as plain text.
     *
     * @param xmlString The raw XML dump of the screen hierarchy.
     * @param previousNodes A set of unique identifiers for nodes from a previous screen state,
     * used to detect new elements. A good identifier is "text|resource-id|class".
     * @return A formatted string representing the UI hierarchy.
     */
    fun toHierarchicalString(xmlString: String, previousNodes: Set<String>? = null, screenWidth: Int, screenHeight: Int): Pair<String,  Map<Int, XmlNode>> {
        val rootNode = buildTreeFromXml(xmlString) ?: return Pair("", emptyMap())
        this.screenWidth = screenWidth
        this.screenHeight = screenHeight

        // Prune the tree to remove noise before generating the string.
        val prunedChildren = rootNode.children.flatMap { prune(it) }
        rootNode.children.clear()
        rootNode.children.addAll(prunedChildren)

        // Reset state for the new parse.
        interactiveNodeMap.clear()
        interactiveElementCounter = 0
        val stringBuilder = StringBuilder()

        // Recursively build the string starting from the children of the root.
        rootNode.children.forEach { child ->
            buildHierarchicalStringRecursive(child, 0, stringBuilder, previousNodes ?: emptySet())
        }

        return Pair(stringBuilder.toString(), interactiveNodeMap)
    }

    /**
     * Returns the center coordinates of an interactive element given its index.
     * This function should be called after `toHierarchicalString` has been run.
     *
     * @param index The numeric index of the element (e.g., `1` from `[1] ...`).
     * @return A `Pair(x, y)` representing the center coordinates, or `null` if the index
     * is invalid or the element has no bounds.
     */
    fun getCenterOfElement(index: Int): Pair<Int, Int>? {
        val node = interactiveNodeMap[index] ?: return null
        val bounds = node.attributes["bounds"] ?: return null // e.g., "[981,1304][1036,1359]"

        // Regex to extract the four coordinate numbers.
        val regex = """\[(\d+),(\d+)\]\[(\d+),(\d+)\]""".toRegex()
        val matchResult = regex.find(bounds) ?: return null

        return try {
            val (left, top, right, bottom) = matchResult.destructured.toList().map { it.toInt() }
            val centerX = (left + right) / 2
            val centerY = (top + bottom) / 2
            Pair(centerX, centerY)
        } catch (e: NumberFormatException) {
            null // Return null if coordinates are not valid integers.
        }
    }


    // --- Original Public API (Maintained) ---

    /**
     * The main public method to parse and filter the XML string, returning a filtered XML.
     *
     * @param xmlString The raw XML dump of the screen hierarchy.
     * @return A filtered XML string containing only the essential nodes.
     */
    fun parseAndFilter(xmlString: String): String {
        val rootNode = buildTreeFromXml(xmlString) ?: return "<hierarchy/>"

        val newChildren = rootNode.children.flatMap { prune(it) }
        rootNode.children.clear()
        rootNode.children.addAll(newChildren)

        return toXmlString(rootNode)
    }

    // --- Private Helper Functions ---

    /**
     * Recursively builds the hierarchical string for the new format.
     */
    private fun buildHierarchicalStringRecursive(
        node: XmlNode,
        indentLevel: Int,
        builder: StringBuilder,
        previousNodes: Set<String>
    ) {
        val indent = "\t".repeat(indentLevel)

        // A unique key to identify a node across different hierarchy snapshots.
        val nodeKey = "${node.getVisibleText()}|${node.attributes["resource-id"]}|${node.attributes["class"]}"
        val isNew = !previousNodes.contains(nodeKey) && node.isSemanticallyImportant()

        if (node.isInteractive()) {
            interactiveElementCounter++
            interactiveNodeMap[interactiveElementCounter] = node

            val newMarker = if (isNew) "* " else ""
            val text = node.getVisibleText().replace("\n", " ")
            val resourceId = node.attributes["resource-id"] ?: ""
            val extraInfo = node.extraInfo
            val className = (node.attributes["class"] ?: "").removePrefix("android.")

            // Format: [1] text:"<text>" <resource-id> <ExtraInfo> <class_name>
            builder.append("$indent$newMarker[$interactiveElementCounter] ")
                .append("text:\"$text\" ")
                .append("<$resourceId> ")
                .append("<$extraInfo> ")
                .append("<$className>\n")

        } else {
            // Only print non-interactive elements if they contain text.
            val text = node.getVisibleText()
            if (text.isNotBlank()) {
                val newMarker = if (isNew) "* " else ""
                builder.append("$indent$newMarker${text.replace("\n", " ")}\n")
            }
        }

        // Recurse for children
        node.children.forEach { child ->
            buildHierarchicalStringRecursive(child, indentLevel + 1, builder, previousNodes)
        }
    }

    /**
     * Recursively prunes the tree. It removes nodes that are not semantically important
     * and promotes their children to maintain the hierarchy.
     *
     * @param node The current node to process.
     * @return A list of nodes to be kept. If the current node is kept, it's a single-element
     * list. If it's removed, it's the list of its promoted children.
     */
    private fun prune(node: XmlNode): List<XmlNode> {
        // 1. Recursively process children and collect the promoted results.
        val newChildren = node.children.flatMap { prune(it) }
        node.children.clear()
        node.children.addAll(newChildren)
        newChildren.forEach { it.parent = node }
        if (!node.isVisibleOnScreen(screenWidth, screenHeight)) {
            return node.children
        }
        // 2. Decide what to do with the current node.
        return if (node.isSemanticallyImportant() || node.isInteractive() || node.children.isNotEmpty()) {
            // Keep this node. Its (potentially promoted) children are already attached.
            listOf(node)
        } else {
            // This node is not important and has no important descendants.
            // Discard it and promote its children up to its parent.
            node.children
        }
    }

    /**
     * Traverses the raw XML string and builds a tree of [XmlNode] objects.
     */
    private fun buildTreeFromXml(xmlString: String): XmlNode? {
        // Replace non-breaking spaces with regular spaces to prevent parsing issues.
        val cleanedXml = xmlString.replace('\u00A0', ' ')

        val factory = XmlPullParserFactory.newInstance()
        val parser = factory.newPullParser()
        parser.setInput(StringReader(cleanedXml))

        var root: XmlNode? = null
        val nodeStack = ArrayDeque<XmlNode>()

        var eventType = parser.eventType
        while (eventType != XmlPullParser.END_DOCUMENT) {
            when (eventType) {
                XmlPullParser.START_TAG -> {
                    // We only care about tags named "node"
                    if (parser.name == "node") {
                        val newNode = XmlNode()
                        for (i in 0 until parser.attributeCount) {
                            newNode.attributes[parser.getAttributeName(i)] = parser.getAttributeValue(i)
                        }

                        if (root == null) {
                            root = newNode
                        } else {
                            val parent = nodeStack.lastOrNull()
                            parent?.children?.add(newNode)
                            newNode.parent = parent
                        }
                        nodeStack.addLast(newNode)
                    }
                }
                XmlPullParser.END_TAG -> {
                    if (parser.name == "node") {
                        nodeStack.removeLastOrNull()
                    }
                }
            }
            eventType = parser.next()
        }
        return root
    }

    /**
     * Converts the final tree back to a formatted XML string.
     */
    private fun toXmlString(root: XmlNode): String {
        val stringBuilder = StringBuilder()
        // The root itself is usually <hierarchy>, let's start with its attributes
        stringBuilder.append("<hierarchy")
        root.attributes.forEach { (key, value) ->
            stringBuilder.append(" ").append(key).append("=\"").append(escapeXml(value)).append("\"")
        }
        stringBuilder.appendLine(">")

        // Recursively build string for all children of the root.
        root.children.forEach { child ->
            buildXmlStringRecursive(child, stringBuilder, 1)
        }

        stringBuilder.appendLine("</hierarchy>")
        return stringBuilder.toString()
    }

    private fun buildXmlStringRecursive(node: XmlNode, builder: StringBuilder, indentLevel: Int) {
        val indent = "  ".repeat(indentLevel)
        builder.append(indent).append("<node")

        // Append attributes
        node.attributes.forEach { (key, value) ->
            builder.append(" ").append(key).append("=\"").append(escapeXml(value)).append("\"")
        }

        if (node.children.isEmpty()) {
            builder.appendLine("/>")
        } else {
            builder.appendLine(">")
            for (child in node.children) {
                buildXmlStringRecursive(child, builder, indentLevel + 1)
            }
            builder.append(indent).appendLine("</node>")
        }
    }

    private fun escapeXml(text: String): String {
        return text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&apos;")
    }
}


================================================
FILE: app/src/main/res/anim/glow_animation.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_decelerate_interpolator">

    <alpha
        android:fromAlpha="0.7"
        android:toAlpha="1.0"
        android:duration="1200"
        android:repeatMode="reverse"
        android:repeatCount="infinite" />

    <scale
        android:fromXScale="1.0"
        android:toXScale="1.05"
        android:fromYScale="1.0"
        android:toYScale="1.05"
        android:pivotX="50%"
        android:pivotY="50%"
        android:duration="1200"
        android:repeatMode="reverse"
        android:repeatCount="infinite" />
</set>


================================================
FILE: app/src/main/res/anim/pulse_animation.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_decelerate_interpolator">
    
    <scale
        android:duration="1000"
        android:fromXScale="1.0"
        android:fromYScale="1.0"
        android:pivotX="50%"
        android:pivotY="50%"
        android:repeatCount="infinite"
        android:repeatMode="reverse"
        android:toXScale="1.1"
        android:toYScale="1.1" />
    
    <alpha
        android:duration="1000"
        android:fromAlpha="0.3"
        android:repeatCount="infinite"
        android:repeatMode="reverse"
        android:toAlpha="0.7" />
        
</set> 


================================================
FILE: app/src/main/res/drawable/bg_solid.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
<solid android:color="@color/panel_background"/>
<corners android:radius="16dp"/>
</shape>



================================================
FILE: app/src/main/res/drawable/btn_with_border.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Create a new file named button_with_border.xml in your res/drawable/ folder -->
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <!-- This sets the background color of the button -->
    <!-- Make sure you have a color named 'panel_background' in your colors.xml -->
    <solid android:color="@color/panel_background" />

    <!-- This creates the border -->
    <stroke
        android:width="0.5dp"
        android:color="#CCCCCC" /> <!-- Whitish-grey border color -->

    <!-- This keeps the corners rounded -->
    <corners android:radius="8dp" />
</shape>



================================================
FILE: app/src/main/res/drawable/edit_text_border.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="@color/background" />

    <stroke
        android:width="1dp"
        android:color="#888888" /> <corners android:radius="12dp" />

</shape>


================================================
FILE: app/src/main/res/drawable/feature_check_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="@color/white" />
</shape>


================================================
FILE: app/src/main/res/drawable/floating_button_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#BE63F3" />
    <corners android:radius="24dp" />
    <stroke
        android:width="2dp"
        android:color="#FFFFFF" />
</shape> 


================================================
FILE: app/src/main/res/drawable/floating_panda_text_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="#B2A4D4" />

    <corners android:radius="100dp" />

</shape>


================================================
FILE: app/src/main/res/drawable/glass_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <!-- Defines the gradient background for the glass effect. -->
    <!-- The colors are taken from your original programmatic implementation. -->
    <gradient
        android:startColor="#DD0D0D2E"
        android:endColor="#DD2A0D45"
        android:angle="135"
        android:type="linear" />

    <!-- Defines the rounded corners for the view. -->
    <corners
        android:radius="28dp" />

    <!-- Defines the subtle white border around the view. -->
    <stroke
        android:width="1dp"
        android:color="#80FFFFFF" />

</shape>



================================================
FILE: app/src/main/res/drawable/ic_accessibility.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M20.5,6c-2.61,0.7 -5.67,1 -8.5,1s-5.89,-0.3 -8.5,-1L3,8c1.86,0.5 4,0.83 6,1v13h2v-6h2v6h2V9c2,-0.17 4.14,-0.5 6,-1l-0.5,-2zM12,6c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/ic_add.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
</vector> 


================================================
FILE: app/src/main/res/drawable/ic_arrow_back.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@color/white"
        android:pathData="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_check_circle.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#4CAF50"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM10,17l-5,-5 1.41,-1.41L10,14.17l7.59,-7.59L19,8l-9,9z"/>
</vector>



================================================
FILE: app/src/main/res/drawable/ic_delta_large.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="200dp"
    android:height="200dp"
    android:viewportWidth="50"
    android:viewportHeight="50">
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M25,7.06 L0.5,49.5"/>
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M0.5,49.5 L49.5,49.5"/>
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.6"
        android:strokeLineCap="butt"
        android:strokeLineJoin="round"
        android:pathData="M49.5,49.5 L25,7.06"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_delta_small.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="32dp"
    android:height="32dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <!-- Black circle background -->
    <path
        android:fillColor="#FF000000"
        android:pathData="M12,12m-10,0a10,10 0,1 1,20 0a10,10 0,1 1,-20 0"/>
    <!-- Delta symbol -->
    <!-- Left side (thinner) -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M12,7 L8,16"/>
    <!-- Bottom side -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M8,16 L16,16"/>
    <!-- Right side (thicker) -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.6"
        android:strokeLineCap="butt"
        android:strokeLineJoin="round"
        android:pathData="M16,16 L12,7"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_delta_symbol.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="500dp"
    android:height="500dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <!-- Left side of triangle (thinner) -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M12,3 L3,19"/>
    <!-- Bottom side of triangle -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.3"
        android:strokeLineCap="round"
        android:strokeLineJoin="round"
        android:pathData="M3,19 L21,19"/>
    <!-- Right side of triangle (thicker) -->
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="0.6"
        android:strokeLineCap="butt"
        android:strokeLineJoin="round"
        android:pathData="M21,19 L12,3"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_home_triangle.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="32dp"
    android:height="32dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/transparent"
        android:strokeColor="#FFFFFF"
        android:strokeWidth="2.5"
        android:pathData="M12,3 L21,19 L3,19 Z"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_launcher_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>



================================================
FILE: app/src/main/res/drawable/ic_launcher_foreground.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>


================================================
FILE: app/src/main/res/drawable/ic_login.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#000000" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
      
    <path android:fillColor="@android:color/black" android:pathData="M480,840L480,760L760,760Q760,760 760,760Q760,760 760,760L760,200Q760,200 760,200Q760,200 760,200L480,200L480,120L760,120Q793,120 816.5,143.5Q840,167 840,200L840,760Q840,793 816.5,816.5Q793,840 760,840L480,840ZM400,680L345,622L447,520L120,520L120,440L447,440L345,338L400,280L600,480L400,680Z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/ic_mic.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="#FFFFFF">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,14c1.66,0 3,-1.34 3,-3V5c0,-1.66 -1.34,-3 -3,-3S9,3.34 9,5v6C9,12.66 10.34,14 12,14z"/>
  <path
      android:fillColor="@android:color/white"
      android:pathData="M17,11c0,2.76 -2.24,5 -5,5s-5,-2.24 -5,-5H5c0,3.53 2.61,6.43 6,6.92V21h2v-3.08c3.39,-0.49 6,-3.39 6,-6.92H17z"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_microphone.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M711,480L711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480Q711,480 711,480ZM920,560L737,560Q734,539 727.5,519Q721,499 711,480L837,480Q833,473 828,468Q823,463 816,459Q790,444 756.5,437Q723,430 680,430Q679,430 678.5,430Q678,430 677,430Q657,407 633.5,390Q610,373 582,361Q605,356 629.5,353Q654,350 680,350Q733,350 779,361Q825,372 865,393Q891,407 905.5,434.5Q920,462 920,497L920,560ZM680,320Q630,320 595,285Q560,250 560,200Q560,150 595,115Q630,80 680,80Q730,80 765,115Q800,150 800,200Q800,250 765,285Q730,320 680,320ZM680,240Q697,240 708.5,228.5Q720,217 720,200Q720,183 708.5,171.5Q697,160 680,160Q663,160 651.5,171.5Q640,183 640,200Q640,217 651.5,228.5Q663,240 680,240ZM680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200Q680,200 680,200ZM249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480Q249,480 249,480ZM40,560L40,497Q40,462 54.5,434.5Q69,407 95,393Q135,372 181,361Q227,350 280,350Q306,350 330.5,353Q355,356 378,361Q350,373 326.5,390Q303,407 283,430Q282,430 281.5,430Q281,430 280,430Q237,430 203.5,437Q170,444 144,459Q137,463 132,468Q127,473 123,480L249,480Q239,499 232.5,519Q226,539 223,560L40,560ZM280,320Q230,320 195,285Q160,250 160,200Q160,150 195,115Q230,80 280,80Q330,80 365,115Q400,150 400,200Q400,250 365,285Q330,320 280,320ZM280,240Q297,240 308.5,228.5Q320,217 320,200Q320,183 308.5,171.5Q297,160 280,160Q263,160 251.5,171.5Q240,183 240,200Q240,217 251.5,228.5Q263,240 280,240ZM280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200Q280,200 280,200ZM480,680Q447,680 423.5,656.5Q400,633 400,600L400,480Q400,447 423.5,423.5Q447,400 480,400Q513,400 536.5,423.5Q560,447 560,480L560,600Q560,633 536.5,656.5Q513,680 480,680ZM450,880L450,798Q378,787 329,731Q280,675 280,600L340,600Q340,658 381,699Q422,740 480,740Q538,740 579,699Q620,658 620,600L680,600Q680,675 631,731Q582,787 510,798L510,880L450,880Z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/ic_moments.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M12,2l3.09,6.26L22,9.27l-5,4.87 1.18,6.88L12,17.77l-6.18,3.25L7,14.14 2,9.27l6.91,-1.01L12,2z"/>
</vector>


================================================
FILE: app/src/main/res/drawable/ic_overlay.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M320,640L800,640Q800,640 800,640Q800,640 800,640L800,240L320,240L320,640Q320,640 320,640Q320,640 320,640ZM320,720Q287,720 263.5,696.5Q240,673 240,640L240,160Q240,127 263.5,103.5Q287,80 320,80L800,80Q833,80 856.5,103.5Q880,127 880,160L880,640Q880,673 856.5,696.5Q833,720 800,720L320,720ZM160,880Q127,880 103.5,856.5Q80,833 80,800L80,240L160,240L160,800Q160,800 160,800Q160,800 160,800L720,800L720,880L160,880ZM320,160Q320,160 320,160Q320,160 320,160L320,640Q320,640 320,640Q320,640 320,640L320,640Q320,640 320,640Q320,640 320,640L320,160Q320,160 320,160Q320,160 320,160Z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/ic_upgrade.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#5880F7"
        android:pathData="M12,2 L22,20 L2,20 Z"/>
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M12,8 L16,14 L8,14 Z"/>
</vector>


================================================
FILE: app/src/main/res/drawable/input_box_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <solid android:color="@color/input_box_background" />
            <corners android:radius="12dp" />
            <stroke android:width="2dp" android:color="@color/orange" />
        </shape>
    </item>
    <item>
        <shape android:shape="rectangle">
            <solid android:color="@color/input_box_background" />
            <corners android:radius="12dp" />
            <stroke android:width="1dp" android:color="#44FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: app/src/main/res/drawable/outline_hourglass_bottom_24.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M480,440Q546,440 593,393Q640,346 640,280L640,160L320,160L320,280Q320,346 367,393Q414,440 480,440ZM160,880L160,800L240,800L240,680Q240,619 268.5,565.5Q297,512 348,480Q297,448 268.5,394.5Q240,341 240,280L240,160L160,160L160,80L800,80L800,160L720,160L720,280Q720,341 691.5,394.5Q663,448 612,480Q663,512 691.5,565.5Q720,619 720,680L720,800L800,800L800,880L160,880Z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/outline_settings_24.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M370,880L354,752Q341,747 329.5,740Q318,733 307,725L188,775L78,585L181,507Q180,500 180,493.5Q180,487 180,480Q180,473 180,466.5Q180,460 181,453L78,375L188,185L307,235Q318,227 330,220Q342,213 354,208L370,80L590,80L606,208Q619,213 630.5,220Q642,227 653,235L772,185L882,375L779,453Q780,460 780,466.5Q780,473 780,480Q780,487 780,493.5Q780,500 778,507L881,585L771,775L653,725Q642,733 630,740Q618,747 606,752L590,880L370,880ZM440,800L519,800L533,694Q564,686 590.5,670.5Q617,655 639,633L738,674L777,606L691,541Q696,527 698,511.5Q700,496 700,480Q700,464 698,448.5Q696,433 691,419L777,354L738,286L639,328Q617,305 590.5,289.5Q564,274 533,266L520,160L441,160L427,266Q396,274 369.5,289.5Q343,305 321,327L222,286L183,354L269,418Q264,433 262,448Q260,463 260,480Q260,496 262,511Q264,526 269,541L183,606L222,674L321,632Q343,655 369.5,670.5Q396,686 427,694L440,800ZM482,620Q540,620 581,579Q622,538 622,480Q622,422 581,381Q540,340 482,340Q423,340 382.5,381Q342,422 342,480Q342,538 382.5,579Q423,620 482,620ZM480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480Q480,480 480,480L480,480L480,480L480,480Q480,480 480,480Q480,480 480,480L480,480Z"/>
    
</vector>



================================================
FILE: app/src/main/res/drawable/picker_divider_transparent.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@android:color/transparent" />
</shape>


================================================
FILE: app/src/main/res/drawable/pricing_card_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@color/background" />
    <corners android:radius="12dp" />
    <stroke
        android:width="1dp"
        android:color="#333333" />
</shape>


================================================
FILE: app/src/main/res/drawable/pro_badge_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@color/white" />
    <corners android:radius="20dp" />
</shape>


================================================
FILE: app/src/main/res/drawable/purchase_button_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true">
        <shape android:shape="rectangle">
            <solid android:color="#E0E0E0" />
            <corners android:radius="8dp" />
        </shape>
    </item>
    <item>
        <shape android:shape="rectangle">
            <solid android:color="@color/white" />
            <corners android:radius="8dp" />
        </shape>
    </item>
</selector>


================================================
FILE: app/src/main/res/drawable/rounded_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/background"/> <!-- Background color -->
    <corners android:radius="16dp"/> <!-- Rounded corners -->
</shape>



================================================
FILE: app/src/main/res/drawable/rounded_button.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/orange"/>
    <corners android:radius="12dp"/>
</shape>



================================================
FILE: app/src/main/res/drawable/rounded_button_bg.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@color/orange" />
    <corners android:radius="16dp" />
</shape>


================================================
FILE: app/src/main/res/drawable/rounded_button_secondary.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#808080"/>
    <corners android:radius="16dp"/>
</shape>



================================================
FILE: app/src/main/res/drawable/selection_window_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="#1AFFFFFF" />

    <corners android:radius="12dp" />
</shape>


================================================
FILE: app/src/main/res/drawable/status_background_denied.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#1AFFFFFF" /> <corners android:radius="16dp" />
    <stroke android:width="1dp" android:color="#F44336" /> </shape>


================================================
FILE: app/src/main/res/drawable/status_background_granted.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#1AFFFFFF" /> <corners android:radius="16dp" />
    <stroke android:width="1dp" android:color="#4CAF50" /> </shape>


================================================
FILE: app/src/main/res/drawable/status_tag_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#2E2E2E" />
    <corners android:radius="12dp" />
</shape>



================================================
FILE: app/src/main/res/drawable/voice_input_button_bg.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Pressed state (listening) -->
    <item android:state_pressed="true">
        <shape android:shape="oval">
            <solid android:color="#FF4444" />
            <stroke android:width="2dp" android:color="#FFFFFF" />
            <size android:width="80dp" android:height="80dp" />
        </shape>
    </item>
    
    <!-- Normal state -->
    <item>
        <shape android:shape="oval">
            <solid android:color="#5880F7" />
            <stroke android:width="2dp" android:color="#FFFFFF" />
            <size android:width="80dp" android:height="80dp" />
        </shape>
    </item>
</selector> 


================================================
FILE: app/src/main/res/drawable/warning_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#4DFF0000" /> <!-- Red with 30% opacity -->
    <corners android:radius="8dp" />
    <stroke android:width="1dp" android:color="#FF0000" />
</shape>


================================================
FILE: app/src/main/res/font/megrim.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:app="http://schemas.android.com/apk/res-auto"
        app:fontProviderAuthority="com.google.android.gms.fonts"
        app:fontProviderPackage="com.google.android.gms"
        app:fontProviderQuery="Megrim"
        app:fontProviderCerts="@array/com_google_android_gms_fonts_certs">
</font-family>



================================================
FILE: app/src/main/res/font/oxanium.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:app="http://schemas.android.com/apk/res-auto"
        app:fontProviderAuthority="com.google.android.gms.fonts"
        app:fontProviderPackage="com.google.android.gms"
        app:fontProviderQuery="Oxanium"
        app:fontProviderCerts="@array/com_google_android_gms_fonts_certs">
</font-family>



================================================
FILE: app/src/main/res/font/oxanium_extralight.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:app="http://schemas.android.com/apk/res-auto"
        app:fontProviderAuthority="com.google.android.gms.fonts"
        app:fontProviderPackage="com.google.android.gms"
        app:fontProviderQuery="Oxanium:wght200"
        app:fontProviderCerts="@array/com_google_android_gms_fonts_certs">
</font-family>



================================================
FILE: app/src/main/res/font/playfair_display.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:app="http://schemas.android.com/apk/res-auto"
        app:fontProviderAuthority="com.google.android.gms.fonts"
        app:fontProviderPackage="com.google.android.gms"
        app:fontProviderQuery="Playfair Display"
        app:fontProviderCerts="@array/com_google_android_gms_fonts_certs">
</font-family>



================================================
FILE: app/src/main/res/font/roboto.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:app="http://schemas.android.com/apk/res-auto"
        app:fontProviderAuthority="com.google.android.gms.fonts"
        app:fontProviderPackage="com.google.android.gms"
        app:fontProviderQuery="Roboto"
        app:fontProviderCerts="@array/com_google_android_gms_fonts_certs">
</font-family>



================================================
FILE: app/src/main/res/layout/activity_base_navigation.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true">

    <!-- Content container for child activities -->
    <LinearLayout
        android:id="@+id/content_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@+id/bottom_navigation"
        android:orientation="vertical" />

    <!-- Bottom Navigation -->
    <LinearLayout
        android:id="@+id/bottom_navigation"
        android:layout_width="match_parent"
        android:layout_height="80dp"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:paddingTop="8dp"
        android:paddingBottom="8dp">

        <!-- Triggers -->
        <LinearLayout
            android:id="@+id/nav_triggers"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground"
            android:gravity="center"
            android:orientation="vertical">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/trigger"
                android:tint="#FFFFFF" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Triggers"
                android:textColor="#FFFFFF"
                android:textSize="12sp" />
        </LinearLayout>

        <!-- Moments -->
        <LinearLayout
            android:id="@+id/nav_moments"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground"
            android:gravity="center"
            android:orientation="vertical">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/moments"
                android:tint="#FFFFFF" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Moments"
                android:textColor="#FFFFFF"
                android:textSize="12sp" />
        </LinearLayout>

        <!-- Home (Delta) -->
        <LinearLayout
            android:id="@+id/nav_home"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground"
            android:gravity="center"
            android:orientation="vertical">

            <ImageView
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:src="@drawable/ic_delta_small" />

        </LinearLayout>

        <!-- Upgrade -->
        <LinearLayout
            android:id="@+id/nav_upgrade"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground"
            android:gravity="center"
            android:orientation="vertical">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/pro" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Buy Pro"
                android:textColor="#FFFFFF"
                android:textSize="12sp" />
        </LinearLayout>

        <!-- Settings -->
        <LinearLayout
            android:id="@+id/nav_settings"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackground"
            android:gravity="center"
            android:orientation="vertical">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/setting"
                android:tint="#FFFFFF" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="Settings"
                android:textColor="#FFFFFF"
                android:textSize="12sp" />
        </LinearLayout>

    </LinearLayout>

</RelativeLayout>


================================================
FILE: app/src/main/res/layout/activity_chat.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:padding="16dp" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <EditText
            android:id="@+id/editText"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Type a message"
            android:inputType="text" />

        <Button
            android:id="@+id/sendButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Send" />
    </LinearLayout>

</LinearLayout>



================================================
FILE: app/src/main/res/layout/activity_choose_trigger_type.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:fitsSystemWindows="true"
    tools:context=".triggers.ui.ChooseTriggerTypeActivity">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary"
        app:title="Choose Trigger Type"
        app:titleTextColor="@color/white" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/toolbar"
        android:orientation="vertical"
        android:padding="16dp">

        <androidx.cardview.widget.CardView
            android:id="@+id/scheduledTimeCard"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:cardBackgroundColor="@color/panel_background"
            app:cardCornerRadius="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:padding="24dp"
                android:gravity="center_vertical">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="🕒"
                    android:textSize="32sp"/>

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginStart="16dp"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Scheduled Time"
                        android:textColor="@color/white"
                        android:textSize="20sp"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Run a task at a specific time."
                        android:textColor="#CECECE"
                        android:textSize="16sp"/>
                </LinearLayout>
            </LinearLayout>
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/notificationCard"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:cardBackgroundColor="@color/panel_background"
            app:cardCornerRadius="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:padding="24dp"
                android:gravity="center_vertical">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="📲"
                    android:textSize="32sp"/>

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginStart="16dp"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Notification"
                        android:textColor="@color/white"
                        android:textSize="20sp"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Run a task when a notification arrives."
                        android:textColor="#CECECE"
                        android:textSize="16sp" />
                </LinearLayout>
            </LinearLayout>
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/chargingStateCard"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            app:cardBackgroundColor="@color/panel_background"
            app:cardCornerRadius="16dp">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:padding="24dp"
                android:gravity="center_vertical">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="🔋"
                    android:textSize="32sp"/>

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:layout_marginStart="16dp"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Charging State"
                        android:textColor="@color/white"
                        android:textSize="20sp"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Run a task when charging starts or stops."
                        android:textColor="#CECECE"
                        android:textSize="16sp" />
                </LinearLayout>
            </LinearLayout>
        </androidx.cardview.widget.CardView>

    </LinearLayout>

</RelativeLayout>



================================================
FILE: app/src/main/res/layout/activity_create_trigger.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    tools:context=".triggers.ui.CreateTriggerActivity">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary"
        app:title="Create Trigger"
        app:titleTextColor="@color/white" />

    <ScrollView
        android:id="@+id/scrollView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/toolbar"
        android:fillViewport="true">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">
            <TextView
                style="@style/PermissionHeading"
                android:text="Task Instruction" />

            <EditText
                android:id="@+id/instructionEditText"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="@drawable/edit_text_border"
                android:hint="e.g., 'Read the notification'"
                android:inputType="textMultiLine"
                android:minLines="2"
                android:maxLines="5"
                android:scrollbars="vertical"
                android:gravity="top"
                android:padding="12dp"
                android:textColor="@color/white"
                android:textColorHint="#8A8A8E" />
            <LinearLayout
                android:id="@+id/scheduledTimeOptions"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical">

                <LinearLayout
                    android:id="@+id/alarmPermissionWarning"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:visibility="gone"
                    android:background="@drawable/warning_background"
                    android:padding="8dp"
                    android:layout_marginBottom="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Permission Required"
                        android:textColor="@color/white"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="To schedule tasks at precise times, Panda needs the 'Alarms &amp; Reminders' permission."
                        android:textColor="@color/white"/>

                    <Button
                        android:id="@+id/grantAlarmPermissionButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Grant Permission"
                        android:layout_marginTop="8dp"
                        android:background="@drawable/rounded_button_secondary"/>
                </LinearLayout>

                <TextView
                    style="@style/PermissionHeading"
                    android:text="Set Trigger Time" />

                <TimePicker
                    android:id="@+id/timePicker"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:theme="@style/AppTheme.NumberPicker"
                    android:timePickerMode="spinner" />


                <TextView
                    style="@style/PermissionHeading"
                    android:layout_marginTop="8dp"
                    android:text="Repeat on" />

                <com.google.android.material.chip.ChipGroup
                    android:id="@+id/dayOfWeekChipGroup"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    app:singleSelection="false">

                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="S"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="M"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="T"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="W"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="T"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="F"/>
                    <com.google.android.material.chip.Chip style="@style/Widget.MaterialComponents.Chip.Filter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="S"/>
                </com.google.android.material.chip.ChipGroup>
            </LinearLayout>

            <LinearLayout
                android:id="@+id/notificationOptions"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="gone">

                <LinearLayout
                    android:id="@+id/notificationPermissionWarning"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:visibility="gone"
                    android:background="@drawable/warning_background"
                    android:padding="8dp"
                    android:layout_marginBottom="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Permission Required"
                        android:textColor="@color/white"
                        android:textStyle="bold"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="To read notifications, Panda needs permission to access them."
                        android:textColor="@color/white"/>

                    <Button
                        android:id="@+id/grantNotificationPermissionButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Grant Permission"
                        android:layout_marginTop="8dp"
                        android:background="@drawable/rounded_button_secondary"/>
                </LinearLayout>

                <CheckBox
                    android:id="@+id/selectAllAppsCheckbox"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="All Applications"
                    android:textColor="@color/white"/>

                <TextView
                    style="@style/PermissionHeading"
                    android:text="Select App" />

                <EditText
                    android:id="@+id/searchEditText"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@drawable/edit_text_border"
                    android:hint="Search Apps"
                    android:inputType="text"
                    android:padding="12dp"
                    android:layout_marginTop="8dp"
                    android:textColor="@color/white"
                    android:textColorHint="#8A8A8E" />

                <androidx.recyclerview.widget.RecyclerView
                    android:id="@+id/appsRecyclerView"
                    android:layout_width="match_parent"
                    android:layout_height="200dp"
                    android:layout_marginTop="8dp"
                    tools:listitem="@layout/item_app" />
            </LinearLayout>

            <LinearLayout
                android:id="@+id/chargingStateOptions"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="gone">

                <TextView
                    style="@style/PermissionHeading"
                    android:text="Trigger When" />

                <RadioGroup
                    android:id="@+id/chargingStatusRadioGroup"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical">

                    <RadioButton
                        android:id="@+id/radioConnected"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Power Connected"
                        android:textColor="@color/white"
                        android:checked="true"/>

                    <RadioButton
                        android:id="@+id/radioDisconnected"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Power Disconnected"
                        android:textColor="@color/white"/>
                </RadioGroup>
            </LinearLayout>


            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_horizontal"
                android:layout_marginTop="24dp">

                <Button
                    android:id="@+id/testTriggerButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:background="@drawable/rounded_button_secondary"
                    android:paddingStart="24dp"
                    android:paddingEnd="24dp"
                    android:text="Test Trigger"
                    android:textColor="@color/white"
                    android:layout_marginEnd="8dp"/>

                <Button
                    android:id="@+id/saveTriggerButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:background="@drawable/rounded_button"
                    android:paddingStart="32dp"
                    android:paddingEnd="32dp"
                    android:text="Save Trigger"
                    android:textColor="@color/white" />
            </LinearLayout>

        </LinearLayout>
    </ScrollView>
</RelativeLayout>



================================================
FILE: app/src/main/res/layout/activity_dialogue.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:padding="24dp">

    <!-- Progress Indicator -->
    <TextView
        android:id="@+id/progressText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="32dp"
        android:text="1 of 3"
        android:textColor="#888888"
        android:textSize="14sp" />

    <!-- Cancel Button -->
    <Button
        android:id="@+id/cancelButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_marginTop="16dp"
        android:background="@drawable/rounded_button"
        android:text="@string/cancel"
        android:textColor="@android:color/white"
        android:textSize="14sp" />

    <!-- Main Content Container -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:orientation="vertical"
        android:gravity="center">

        <!-- Question Text -->
        <TextView
            android:id="@+id/questionText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="32dp"
            android:gravity="center"
            android:text="What is the name of your brother saved in the phone?"
            android:textColor="#FFFFFF"
            android:textSize="20sp"
            android:textStyle="bold" />

        <!-- Answer Input Section -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:gravity="center">

            <!-- Text Input -->
            <EditText
                android:id="@+id/answerInput"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:background="@drawable/rounded_background"
                android:hint="@string/type_answer_here"
                android:inputType="text"
                android:padding="16dp"
                android:textColor="#CECECE"
                android:textColorHint="#888888"
                android:textSize="16sp" />

            <!-- Voice Input Section -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:orientation="vertical">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="8dp"
                    android:text="@string/or_use_voice_input"
                    android:textColor="#888888"
                    android:textSize="14sp" />

                <LinearLayout
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:gravity="center"
                    android:orientation="horizontal">

                    <ImageButton
                        android:id="@+id/voiceInputButton"
                        android:layout_width="60dp"
                        android:layout_height="60dp"
                        android:layout_marginEnd="12dp"
                        android:background="@drawable/voice_input_button_bg"
                        android:contentDescription="@string/hold_to_speak"
                        android:src="@drawable/ic_mic"
                        android:scaleType="centerInside"
                        android:padding="12dp" />

                    <TextView
                        android:id="@+id/voiceStatusText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/hold_to_speak"
                        android:textColor="#888888"
                        android:textSize="12sp" />

                </LinearLayout>
            </LinearLayout>

            <!-- Submit Button -->
            <Button
                android:id="@+id/submitButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="24dp"
                android:background="@drawable/rounded_button"
                android:text="@string/submit_answer"
                android:textColor="@android:color/white"
                android:textSize="16sp" />

        </LinearLayout>
    </LinearLayout>
</RelativeLayout> 


================================================
FILE: app/src/main/res/layout/activity_main_content.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Loading overlay -->
    <LinearLayout
        android:id="@+id/loading_overlay"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#80000000"
        android:gravity="center"
        android:orientation="vertical"
        android:visibility="gone">

        <ProgressBar
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:indeterminateTint="#FFFFFF" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:text="Checking subscription status..."
            android:textColor="#FFFFFF"
            android:textSize="16sp" />
    </LinearLayout>

    <!-- Pro Upgrade Banner -->
    <include
        android:id="@+id/pro_upgrade_banner"
        layout="@layout/pro_upgrade_banner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true" />

    <!-- Main content area -->
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@+id/pro_upgrade_banner"
        android:layout_above="@+id/permission_section"
        android:fillViewport="true">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="16dp">



            <!-- Central delta symbol container -->
            <LinearLayout
                android:id="@+id/center_content"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:gravity="center"
                android:orientation="vertical">

                <com.blurr.voice.views.DeltaSymbolView
                    android:id="@+id/delta_symbol"
                    android:layout_width="250dp"
                    android:layout_height="250dp"
                    android:layout_gravity="center"
                    android:layout_marginBottom="16dp"/>

                <TextView
                    android:id="@+id/status_text"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center"
                    android:layout_marginTop="24dp"
                    android:text="Ready"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp" />
            </LinearLayout>

            <!-- Spacer to push remaining content to bottom -->
            <View
                android:layout_width="match_parent"
                android:layout_height="0dp"
                android:layout_weight="1" />

            <TextView
                android:id="@+id/btn_set_default_assistant"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="@drawable/rounded_button"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:padding="12dp"
                android:text="Set as Default Assistant"
                android:textColor="@android:color/black"
                android:textSize="16sp" />

            <!-- Action Tabs Section -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:layout_marginBottom="24dp"
                android:orientation="vertical"
                android:gravity="center">

                <!-- First Row of Action Tabs -->
                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center"
                    android:layout_marginBottom="8dp">

                    <TextView
                        android:id="@+id/wakeWordHelpLink"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:layout_marginEnd="4dp"
                        android:background="@drawable/rounded_button"
                        android:textColor="@color/black"                        android:clickable="true"
                        android:focusable="true"
                        android:gravity="center"
                        android:padding="12dp"
                        android:text="How to wake up Panda"
                        android:textSize="12sp" />

                    <TextView
                        android:id="@+id/increase_limits_link"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:layout_marginStart="4dp"
                        android:background="@drawable/rounded_button"
                        android:textColor="@color/black"                        android:clickable="true"
                        android:focusable="true"
                        android:gravity="center"
                        android:padding="12dp"
                        android:text="Email Developer"
                        android:textSize="12sp" />

                </LinearLayout>

                <!-- Second Row of Action Tabs -->
                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center">

                    <TextView
                        android:id="@+id/disclaimer_link"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:layout_marginEnd="4dp"
                        android:background="@drawable/rounded_button"
                        android:textColor="@color/black"
                        android:clickable="true"
                        android:focusable="true"
                        android:gravity="center"
                        android:padding="12dp"
                        android:text="Disclaimer"
                        android:textSize="12sp" />

                    <TextView
                        android:id="@+id/examples_link"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:layout_marginStart="4dp"
                        android:background="@drawable/rounded_button"
                        android:textColor="@color/black"                        android:clickable="true"
                        android:focusable="true"
                        android:gravity="center"
                        android:padding="12dp"
                        android:text="Make panda do something"
                        android:textSize="12sp" />

                </LinearLayout>

            </LinearLayout>

            <!-- Status Tags Section -->
            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginTop="8dp"
                android:layout_marginBottom="16dp"
                android:orientation="horizontal"
                android:gravity="center">

                <!-- Pro Subscription Tag -->
                <LinearLayout
                    android:id="@+id/pro_subscription_tag"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginEnd="8dp"
                    android:background="@drawable/status_tag_background"
                    android:orientation="horizontal"
                    android:gravity="center_vertical"
                    android:paddingStart="8dp"
                    android:paddingEnd="8dp"
                    android:paddingTop="4dp"
                    android:paddingBottom="4dp"
                    android:visibility="gone">

                    <ImageView
                        android:layout_width="12dp"
                        android:layout_height="12dp"
                        android:layout_marginEnd="4dp"
                        android:src="@drawable/ic_check_circle"
                        android:tint="#4CAF50" />

                    <TextView
                        android:id="@+id/billing_status_textview"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Pro Active"
                        android:textColor="#BDBDBD"
                        android:textSize="10sp"
                        tools:text="Pro Active"
                        tools:visibility="visible" />

                </LinearLayout>

                <!-- Permissions Tag -->
                <LinearLayout
                    android:id="@+id/permissions_tag"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="8dp"
                    android:background="@drawable/status_tag_background"
                    android:orientation="horizontal"
                    android:gravity="center_vertical"
                    android:paddingStart="8dp"
                    android:paddingEnd="8dp"
                    android:paddingTop="4dp"
                    android:paddingBottom="4dp"
                    android:visibility="gone">

                    <ImageView
                        android:layout_width="12dp"
                        android:layout_height="12dp"
                        android:layout_marginEnd="4dp"
                        android:src="@drawable/ic_check_circle"
                        android:tint="#4CAF50" />

                    <TextView
                        android:id="@+id/permissions_status_tag"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="All Permissions"
                        android:textColor="#BDBDBD"
                        android:textSize="10sp"
                        tools:text="All Permissions"
                        tools:visibility="visible" />

                </LinearLayout>


                <LinearLayout
                    android:id="@+id/tasks_left_tag"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginStart="8dp"
                    android:background="@drawable/status_tag_background"
                    android:gravity="center_vertical"
                    android:orientation="horizontal"
                    android:paddingStart="8dp"
                    android:paddingEnd="8dp"
                    android:paddingTop="4dp"
                    android:paddingBottom="4dp"
                    tools:visibility="visible">

                    <ImageView
                        android:layout_width="12dp"
                        android:layout_height="12dp"
                        android:layout_marginEnd="4dp"
                        android:src="@drawable/outline_hourglass_bottom_24"
                        android:tint="#4CAF50"  />

                    <TextView
                        android:id="@+id/tasks_left_tag_text"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textColor="#BDBDBD"
                        android:textSize="10sp"
                        tools:text="15 Tasks Left" />

                </LinearLayout>


            </LinearLayout>

            <!-- Essential element: "Free tasks left" text - preserved with existing styling -->
            <TextView
                android:id="@+id/tasks_remaining_textview"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginBottom="24dp"
                android:padding="20dp"
                android:textColor="#BDBDBD"
                android:textSize="16sp"
                android:visibility="gone"
                tools:text="15 Free Tasks Remaining"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/developer_message_textview"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginBottom="16dp"
                android:padding="8dp"
                android:textColor="#BDBDBD"
                android:textSize="12sp"
                android:visibility="gone" />

        </LinearLayout>

    </ScrollView>

    <!-- Essential element: Permission section - preserved with current visibility logic -->
    <LinearLayout
        android:id="@+id/permission_section"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:paddingStart="16dp"
        android:paddingEnd="16dp"
        android:paddingBottom="16dp">

        <TextView
            android:id="@+id/tv_permission_status"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/permission_not_granted"
            android:textColor="@android:color/holo_red_dark" />

        <TextView
            android:id="@+id/btn_manage_permissions"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:background="@drawable/rounded_button"
            android:clickable="true"
            android:focusable="true"
            android:fontFamily="@font/playfair_display"
            android:gravity="center"
            android:padding="12dp"
            android:text="Manage Permissions"
            android:textColor="@android:color/black"
            android:textSize="16sp" />
    </LinearLayout>

</RelativeLayout>


================================================
FILE: app/src/main/res/layout/activity_memories.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:fitsSystemWindows="true">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/primary">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:title="Panda Memories"
            app:titleTextColor="@android:color/white" />

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fillViewport="true"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <!-- Privacy Information Card -->
            <com.google.android.material.card.MaterialCardView
                android:id="@+id/privacyCard"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp"
                app:cardBackgroundColor="@color/surface">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:padding="16dp"
                    android:gravity="center_vertical">

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:text="See how we handle your personal data"
                        android:textColor="@color/text_primary"
                        android:textSize="16sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="→"
                        android:textColor="@color/accent"
                        android:textSize="18sp"
                        android:textStyle="bold" />

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <!-- Memory Disabled Notice Card -->
            <com.google.android.material.card.MaterialCardView
                android:id="@+id/memoryDisabledCard"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp"
                app:cardBackgroundColor="#FFF3E0">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="⚠️ Memory Temporarily Disabled"
                        android:textColor="#E65100"
                        android:textSize="16sp"
                        android:textStyle="bold"
                        android:gravity="center" />

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="8dp"
                        android:text="Panda memory is turned off as of yet. Memory functionality will be restored in a future update."
                        android:textColor="#BF360C"
                        android:textSize="14sp"
                        android:gravity="center" />

                </LinearLayout>

            </com.google.android.material.card.MaterialCardView>

            <!-- Memories RecyclerView -->
            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/memoriesRecyclerView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clipToPadding="false" />

            <!-- Empty State Text -->
            <TextView
                android:id="@+id/emptyStateText"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:layout_marginTop="32dp"
                android:text="No memories yet.\nTap the + button to add your first memory!"
                android:textAlignment="center"
                android:textSize="16sp"
                android:textColor="@color/text_secondary"
                android:visibility="gone" />

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/addMemoryFab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|end"
        android:layout_margin="16dp"
        android:src="@drawable/ic_add"
        app:backgroundTint="@color/accent"
        app:tint="@android:color/white" />

</androidx.coordinatorlayout.widget.CoordinatorLayout> 


================================================
FILE: app/src/main/res/layout/activity_moments.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:orientation="vertical"
    android:padding="16dp">

    <!-- Header -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:orientation="horizontal"
        android:layout_marginBottom="24dp">

        <TextView
            android:id="@+id/back_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:padding="8dp"
            android:text="← Back"
            android:textColor="#FFFFFF"
            android:textSize="16sp" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:gravity="center"
            android:text="Moments"
            android:textColor="#FFFFFF"
            android:textSize="24sp"
            android:textStyle="bold" />

        <View
            android:layout_width="48dp"
            android:layout_height="48dp" />

    </LinearLayout>

    <!-- Content -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:gravity="center"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:text="🌟"
            android:textSize="64sp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="8dp"
            android:text="Moments Coming Soon"
            android:fontFamily="@font/oxanium"
            android:textColor="#FFFFFF"
            android:textSize="24sp"
            android:textStyle="bold" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="This feature will help you track and review your conversation history with Panda."
            android:textColor="#BDBDBD"
            android:textSize="16sp" />

    </LinearLayout>

</LinearLayout>


================================================
FILE: app/src/main/res/layout/activity_moments_content.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <!-- Header -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:orientation="horizontal"
        android:layout_marginBottom="24dp">

        <TextView
            android:id="@+id/back_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:padding="8dp"
            android:text="← Back"
            android:textColor="#FFFFFF"
            android:textSize="16sp" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:gravity="center"
            android:text="Moments"
            android:textColor="#FFFFFF"
            android:fontFamily="@font/oxanium"
            android:textSize="24sp"
            android:textStyle="bold" />

        <View
            android:layout_width="48dp"
            android:layout_height="48dp" />

    </LinearLayout>

    <!-- Content -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="vertical">



        <!-- Task History RecyclerView -->
        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/task_history_recycler_view"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:clipToPadding="false"
            android:paddingBottom="16dp" />

        <!-- Empty State -->
        <LinearLayout
            android:id="@+id/empty_state"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:gravity="center"
            android:orientation="vertical"
            android:visibility="gone">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:text="📝"
                android:textSize="48sp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="No Moments Yet"
                android:textColor="#FFFFFF"
                android:textSize="18sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:text="Start using Panda to create your first moments!"
                android:textColor="#BDBDBD"
                android:textSize="14sp" />

        </LinearLayout>

    </LinearLayout>

</LinearLayout>


================================================
FILE: app/src/main/res/layout/activity_onboarding.xml
================================================
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:padding="24dp"
    tools:context=".LoginActivity">

    <ImageView
        android:id="@+id/logoImage"
        android:layout_width="140dp"
        android:layout_height="96dp"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="10dp"
        android:contentDescription="Panda logo"
        android:src="@drawable/panda_logo" />

    <TextView
        android:id="@+id/inviteMessage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/logoImage"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="16dp"
        android:fontFamily="@font/oxanium_extralight"
        android:text="Voice Assistant capable of using your phone"
        android:textAlignment="center"
        android:textColor="#FFBD86"
        android:textSize="20sp" />

    <EditText
        android:id="@+id/emailInput"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        android:layout_below="@id/dividerContainer"
        android:layout_marginTop="12dp"
        android:background="@drawable/input_box_background"
        android:fontFamily="@font/oxanium"
        android:hint="Enter your email [WIP]"
        android:inputType="textEmailAddress"
        android:padding="12dp"
        android:textColor="@android:color/white"
        android:textColorHint="#80FFFFFF" />

    <com.google.android.material.button.MaterialButton
        android:id="@+id/emailSendLinkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/emailInput"
        android:layout_marginTop="12dp"
        android:fontFamily="@font/oxanium"
        android:text="Send magic link"
        android:textAllCaps="false"
        android:textColor="@color/black"
        app:backgroundTint="#FFBD86"
        app:cornerRadius="12dp" />

    <com.google.android.gms.common.SignInButton
        android:id="@+id/googleSignInButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/inviteMessage"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="50dp" />

    <LinearLayout
        android:id="@+id/dividerContainer"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/googleSignInButton"
        android:layout_marginTop="24dp"
        android:layout_marginBottom="12dp"
        android:orientation="horizontal"
        android:gravity="center_vertical">

        <View
            android:layout_width="0dp"
            android:layout_height="1dp"
            android:layout_weight="1"
            android:background="#323232" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="12dp"
            android:layout_marginEnd="12dp"
            android:fontFamily="@font/oxanium"
            android:text="OR"
            android:textColor="#C7C7C7"
            android:textStyle="normal" />

        <View
            android:layout_width="0dp"
            android:layout_height="1dp"
            android:layout_weight="1"
            android:background="#323232" />
    </LinearLayout>

    <ProgressBar
        android:id="@+id/progressBar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:visibility="gone"/>

    <TextView
        android:id="@+id/loadingText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/progressBar"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="16dp"
        android:fontFamily="@font/oxanium"
        android:text="Signing you in..."
        android:textColor="@android:color/white"
        android:textSize="14sp"
        android:visibility="gone" />

</RelativeLayout>


================================================
FILE: app/src/main/res/layout/activity_onboarding_stepper.xml
================================================
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    tools:context=".OnboardingPermissionsActivity">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="24dp"
        android:background="@drawable/rounded_background"
        android:gravity="center_horizontal"
        android:orientation="vertical"
        android:padding="32dp">

        <ImageView
            android:id="@+id/permissionIcon"
            android:layout_width="300dp"
            android:layout_height="200dp"
            android:layout_gravity="center_horizontal"
            android:layout_marginBottom="16dp"
            tools:ignore="ContentDescription"
            />

        <TextView
            android:id="@+id/permissionTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="12dp"
            android:text="@string/accessibility_permission_title"
            android:textColor="@color/white"
            android:textSize="22sp"
            android:fontFamily="@font/oxanium"
            android:textStyle="bold" />

        <TextView
            android:id="@+id/permissionDescription"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:fontFamily="@font/roboto"
            android:lineSpacingExtra="4dp"
            android:text="@string/accessibility_permission_desc"
            android:textAlignment="center"
            android:textColor="#B3FFFFFF"
            android:textSize="15sp" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/buttonLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:gravity="center_horizontal"
        android:orientation="vertical"
        android:padding="24dp">

        <TextView
            android:id="@+id/stepperIndicator"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:text="Step 1 of 5"
            android:textColor="#B3FFFFFF"
            android:textSize="14sp" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/grantButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="14dp"
            android:text="@string/grant_permission_button"
            android:textAllCaps="false"
            android:textColor="@color/black"
            android:fontFamily="@font/oxanium"
            android:textSize="16sp"
            app:backgroundTint="@color/orange"
            app:cornerRadius="12dp" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/nextButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="14dp"
            android:text="Next"
            android:textAllCaps="false"
            android:textColor="@color/black"
            android:textSize="16sp"
            android:visibility="gone"
            app:backgroundTint="@color/orange"
            app:cornerRadius="12dp" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/skipButton"
            style="@style/Widget.MaterialComponents.Button.TextButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:text="Skip for now"
            android:textColor="#B3FFFFFF" />
    </LinearLayout>

</RelativeLayout>


================================================
FILE: app/src/main/res/layout/activity_permissions.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:clipToPadding="false"
    android:padding="16dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:id="@+id/permissionsTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginBottom="24dp"
            android:text="@string/permissions_explained_title"
            android:textColor="@android:color/white"
            android:textSize="28sp"
            android:textStyle="bold" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageView
                    android:id="@+id/accessibility_icon"
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_centerVertical="true"
                    android:layout_marginEnd="12dp"
                    android:src="@drawable/ic_accessibility"
                    app:tint="@color/white" />

                <TextView
                    android:id="@+id/accessibilityStatus"
                    style="@style/PermissionStatus"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true" />

                <TextView
                    android:id="@+id/accessibilityHeading"
                    style="@style/PermissionHeading"
                    android:layout_centerVertical="true"
                    android:layout_toStartOf="@id/accessibilityStatus"
                    android:layout_toEndOf="@id/accessibility_icon"
                    android:text="@string/accessibility_permission_title" />
            </RelativeLayout>

            <TextView
                style="@style/PermissionDescription"
                android:text="@string/accessibility_permission_desc" />

            <TextView
                style="@style/PermissionDescription"
                android:layout_marginTop="12dp"
                android:text="@string/accessibility_permission_details" />

        <TextView
            android:id="@+id/grantAccessibilityButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:background="@drawable/rounded_button"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center"
            android:padding="12dp"
            android:textColor="@android:color/black"
            android:textSize="16sp"
            android:visibility="gone"
            android:text="@string/grant_accessibility_permission"
            />
        </LinearLayout>
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageView
                    android:id="@+id/assistant_icon"
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_centerVertical="true"
                    android:layout_marginEnd="12dp"
                    android:src="@drawable/ic_mic"
                    app:tint="@color/white" />

                <TextView
                    android:id="@+id/assistantStatus"
                    style="@style/PermissionStatus"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true"/>

                <TextView
                    android:id="@+id/assistantHeading"
                    style="@style/PermissionHeading"
                    android:layout_centerVertical="true"
                    android:layout_toStartOf="@id/assistantStatus"
                    android:layout_toEndOf="@id/assistant_icon"
                    android:text="@string/default_assistant_permission_title" />
            </RelativeLayout>

            <TextView
                style="@style/PermissionDescription"
                android:text="@string/default_assistant_role_desc" />

            <TextView
                android:id="@+id/grantAssistantButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="@drawable/rounded_button"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:padding="12dp"
                android:textColor="@android:color/black"
                android:textSize="16sp"
                android:visibility="gone"
                android:text="@string/grant_default_assistant_permission_button"
             />
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageView
                    android:id="@+id/microphone_icon"
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_centerVertical="true"
                    android:layout_marginEnd="12dp"
                    android:src="@drawable/ic_microphone"
                    app:tint="@color/white" />

                <TextView
                    android:id="@+id/microphoneStatus"
                    style="@style/PermissionStatus"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true" />

                <TextView
                    android:id="@+id/microphoneHeading"
                    style="@style/PermissionHeading"
                    android:layout_centerVertical="true"
                    android:layout_toStartOf="@id/microphoneStatus"
                    android:layout_toEndOf="@id/microphone_icon"
                    android:text="@string/microphone_permission_title" />
            </RelativeLayout>

            <TextView
                style="@style/PermissionDescription"
                android:text="@string/microphone_permission_desc" />

            <TextView
                android:id="@+id/grantMicrophoneButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="@drawable/rounded_button"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:padding="12dp"
                android:textColor="@android:color/black"
                android:textSize="16sp"
                android:visibility="gone"

                android:text="Grant Microphone Permission"
/>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageView
                    android:id="@+id/overlay_icon"
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_centerVertical="true"
                    android:layout_marginEnd="12dp"
                    android:src="@drawable/ic_overlay"
                    app:tint="@color/white" />

                <TextView
                    android:id="@+id/overlayStatus"
                    style="@style/PermissionStatus"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true"/>

                <TextView
                    android:id="@+id/overlayHeading"
                    style="@style/PermissionHeading"
                    android:layout_centerVertical="true"
                    android:layout_toStartOf="@id/overlayStatus"
                    android:layout_toEndOf="@id/overlay_icon"
                    android:text="@string/overlay_permission_title" />
            </RelativeLayout>

            <TextView
                style="@style/PermissionDescription"
                android:text="@string/overlay_permission_desc" />

            <TextView
                android:id="@+id/grantOverlayButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="@drawable/rounded_button"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:padding="12dp"
                android:textSize="16sp"
                android:text="Grant Overlay Permission"
                android:textColor="@android:color/black"
                android:visibility="gone" />
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageView
                    android:id="@+id/appListIcon"
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_centerVertical="true"
                    android:layout_marginEnd="12dp"
                    android:src="@drawable/ic_accessibility"
                    app:tint="@color/white"
                    tools:ignore="ContentDescription" />

                <TextView
                    android:id="@+id/appListStatus"
                    style="@style/PermissionStatus"
                    android:layout_alignParentEnd="true"
                    android:layout_centerVertical="true"/>

                <TextView
                    android:id="@+id/appListHeading"
                    style="@style/PermissionHeading"
                    android:layout_centerVertical="true"
                    android:layout_toStartOf="@id/appListStatus"
                    android:layout_toEndOf="@id/appListIcon"
                    android:text="@string/app_list_permission_title" />
            </RelativeLayout>

            <TextView
                style="@style/PermissionDescription"
                android:text="@string/app_list_permission_desc" />

        </LinearLayout>
        <Button
            android:id="@+id/backButtonPermissions"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginTop="32dp"
            android:background="@drawable/rounded_button"
            android:paddingStart="32dp"
            android:paddingEnd="32dp"
            android:text="@string/back"
            android:textColor="@android:color/white" />

    </LinearLayout>
</ScrollView>


================================================
FILE: app/src/main/res/layout/activity_privacy.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:fitsSystemWindows="true">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/primary">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
            app:title="How Panda Remembers"
            app:titleTextColor="@android:color/white" />

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fillViewport="true"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <!-- Introduction Section -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="24dp"
                android:text="Panda is designed to be your personal assistant. Just like a human assistant, it becomes more helpful when it remembers key facts about you and your preferences. This screen explains exactly how that process works and how your data is protected."
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:lineSpacingExtra="4dp" />

            <!-- Section 1: How Are Memories Created? -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="1. How Are Memories Created?"
                android:textColor="@android:color/white"
                android:textSize="20sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:text="Your privacy is the starting point. Memories are never created without your interaction."
                android:textColor="@android:color/white"
                android:textSize="16sp" />

            <!-- Automatic Extraction -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Automatic Extraction:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:layout_marginStart="16dp"
                android:text="@string/at_the_end_of_a_conversation_panda_s_ai_powered_by_google_s_gemini_model_analyzes_the_dialogue_to_identify_lasting_facts_it_s_trained_to_ignore_fleeting_or_unimportant_details_for_example_if_you_say_remind_me_to_call_my_brother_ankit_tomorrow_the_ai_might_create_a_memory_like_the_user_s_brother_is_named_ankit"
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Manual Creation -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Manual Creation:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="24dp"
                android:layout_marginStart="16dp"
                android:text="You have full control. You can visit the || My Memories || screen at any time to add new facts manually, ensuring Panda knows exactly what you want it to."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Section 2: Where Is Your Data Stored? -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="2. Where Is Your Data Stored?"
                android:textColor="@android:color/white"
                android:textSize="20sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:text="We use a hybrid approach that prioritizes on-device security."
                android:textColor="@android:color/white"
                android:textSize="16sp" />

            <!-- On-Device Storage -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Securely On Your Phone:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:layout_marginStart="16dp"
                android:text="@string/once_a_memory_is_created_e_g_the_user_lives_in_ghaziabad_it_is_stored_in_a_secure_private_database_directly_on_your_phone_this_database_is_part_of_the_panda_app_s_internal_storage_and_is_not_accessible_by_other_apps"
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Privacy-Preserving Search -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Privacy-Preserving Search:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="24dp"
                android:layout_marginStart="16dp"
                android:text="To find relevant information without constantly re-reading your memories, each memory is converted into a numerical representation called an embedding. This allows Panda to find the most relevant facts for a new request by comparing numbers, not by reading the raw text of every memory you have stored."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Section 3: Who Has Access to Your Data? -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="3. Who Has Access to Your Data?"
                android:textColor="@android:color/white"
                android:textSize="20sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:text="Your trust is our priority. Access to your data is strictly limited."
                android:textColor="@android:color/white"
                android:textSize="16sp" />

            <!-- Only You -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Only You:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:layout_marginStart="16dp"
                android:text="You have complete control. You can view, add, and permanently delete any or all of your memories at any time from the My Memories screen in the app."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Only Panda -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Only Panda (On Your Device):"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:layout_marginStart="16dp"
                android:text="The Panda agent running on your phone accesses this local database to personalize your conversations and carry out tasks more effectively. This access is confined to your device."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Cloud Processing -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Cloud Processing (For Intelligence):"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:layout_marginStart="16dp"
                android:text="To provide intelligent features, some data is processed by Google's AI models:"
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="4dp"
                android:layout_marginStart="32dp"
                android:text="1. Conversation Analysis: The text of your conversation is sent to Google's Gemini API to extract key facts for new memories."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:layout_marginStart="32dp"
                android:text="2. Embedding Creation: The text of a new memory (or a search query) is sent to Google's Gemini Embedding API to create its numerical representation."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="24dp"
                android:layout_marginStart="16dp"
                android:text="This processing is governed by Google's standard privacy policies. The raw data is used to generate a response and is not permanently stored or linked to your personal identity by us."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Never Third-Party -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:text="• Never Third-Party Advertisers:"
                android:textColor="@android:color/white"
                android:textSize="16sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="24dp"
                android:layout_marginStart="16dp"
                android:text="We will never share or sell your memory data to third-party advertisers or data brokers."
                android:textColor="@android:color/white"
                android:textSize="14sp"
                android:lineSpacingExtra="2dp" />

            <!-- Summary Section -->
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:text="Your Memories, Your Control: A Summary"
                android:textColor="@android:color/white"
                android:textSize="20sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="4dp"
                android:text="✅ On-Device Storage: Your memories are stored locally and securely on your phone."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="4dp"
                android:text="✅ Full Control: You can view, add, and delete your memories whenever you want."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="4dp"
                android:text="✅ Secure Processing: Conversations are sent to Google's AI for analysis but the resulting memories are stored only on your device."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="32dp"
                android:text="✅ No Sharing: Your personal memory data is not shared with advertisers."
                android:textColor="@android:color/white"
                android:textSize="14sp" />

        </LinearLayout>

    </androidx.core.widget.NestedScrollView>

</androidx.coordinatorlayout.widget.CoordinatorLayout> 


================================================
FILE: app/src/main/res/layout/activity_pro_purchase.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/black"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

        <!-- Header with back button -->
        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="32dp">

            <ImageView
                android:id="@+id/back_button"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:layout_alignParentStart="true"
                android:layout_centerVertical="true"
                android:src="@drawable/ic_arrow_back"
                android:contentDescription="Back"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:padding="4dp"
                app:tint="@color/white" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_centerInParent="true"
                android:text="Upgrade to Pro"
                android:textColor="@color/white"
                android:textSize="20sp"
                android:textStyle="bold" />

        </RelativeLayout>

        <!-- Pro Badge -->
        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginBottom="24dp"
            android:background="@drawable/pro_badge_background"
            android:orientation="horizontal"
            android:paddingHorizontal="16dp"
            android:paddingVertical="8dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="✨ PRO"
                android:textColor="@color/black"
                android:textSize="16sp"
                android:textStyle="bold" />

        </LinearLayout>

        <!-- Main Title -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:gravity="center"
            android:text="Unlock Unlimited Power"
            android:textColor="@color/white"
            android:textSize="28sp"
            android:textStyle="bold" />

        <!-- Subtitle -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="32dp"
            android:gravity="center"
            android:text="Get unlimited tasks and premium features"
            android:textColor="#CCCCCC"
            android:textSize="16sp" />

        <!-- Features List -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="32dp"
            android:orientation="vertical">

            <!-- Feature 1 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:orientation="horizontal">

                <TextView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_marginEnd="16dp"
                    android:background="@drawable/feature_check_background"
                    android:gravity="center"
                    android:text="✓"
                    android:textColor="@color/black"
                    android:textSize="14sp"
                    android:textStyle="bold" />

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Unlimited Daily Tasks"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="No more daily limits - use Panda as much as you want"
                        android:textColor="#CCCCCC"
                        android:textSize="14sp" />

                </LinearLayout>

            </LinearLayout>

            <!-- Feature 2 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:orientation="horizontal">

                <TextView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_marginEnd="16dp"
                    android:background="@drawable/feature_check_background"
                    android:gravity="center"
                    android:text="✓"
                    android:textColor="@color/black"
                    android:textSize="14sp"
                    android:textStyle="bold" />

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Priority Support"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Get faster response times and dedicated support"
                        android:textColor="#CCCCCC"
                        android:textSize="14sp" />

                </LinearLayout>

            </LinearLayout>

            <!-- Feature 3 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:orientation="horizontal">

                <TextView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_marginEnd="16dp"
                    android:background="@drawable/feature_check_background"
                    android:gravity="center"
                    android:text="✓"
                    android:textColor="@color/black"
                    android:textSize="14sp"
                    android:textStyle="bold" />

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Advanced Features"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Access to beta features and premium capabilities"
                        android:textColor="#CCCCCC"
                        android:textSize="14sp" />

                </LinearLayout>

            </LinearLayout>

            <!-- Feature 4 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">

                <TextView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_marginEnd="16dp"
                    android:background="@drawable/feature_check_background"
                    android:gravity="center"
                    android:text="✓"
                    android:textColor="@color/black"
                    android:textSize="14sp"
                    android:textStyle="bold" />

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="No Ads"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:textStyle="bold" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Enjoy an uninterrupted, ad-free experience"
                        android:textColor="#CCCCCC"
                        android:textSize="14sp" />

                </LinearLayout>

            </LinearLayout>

        </LinearLayout>

        <!-- Pricing Section -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="24dp"
            android:background="@drawable/pricing_card_background"
            android:orientation="vertical"
            android:padding="24dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginBottom="8dp"
                android:text="Special Launch Price"
                android:textColor="#CCCCCC"
                android:textSize="14sp" />

            <ProgressBar
                android:id="@+id/loading_progress"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginVertical="16dp"
                android:indeterminateTint="@color/white"
                android:visibility="visible" />

            <TextView
                android:id="@+id/price_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginBottom="8dp"
                android:text="Loading..."
                android:textColor="@color/white"
                android:textSize="32sp"
                android:textStyle="bold" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:text="Cancel anytime"
                android:textColor="#CCCCCC"
                android:textSize="12sp" />

        </LinearLayout>

        <!-- Purchase Button -->
        <Button
            android:id="@+id/purchase_button"
            android:layout_width="match_parent"
            android:layout_height="56dp"
            android:layout_marginBottom="16dp"
            android:background="@drawable/purchase_button_background"
            android:text="Start Pro Subscription"
            android:textColor="@color/black"
            android:textSize="16sp"
            android:textStyle="bold"
            android:visibility="gone" />

        <!-- Terms -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="By subscribing, you agree to our Terms of Service and Privacy Policy. Subscription automatically renews unless cancelled."
            android:textColor="#999999"
            android:textSize="12sp"
            android:lineSpacingMultiplier="1.2" />

    </LinearLayout>

</ScrollView>


================================================
FILE: app/src/main/res/layout/activity_settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:clipToPadding="false"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp"

        tools:context=".SettingsActivity">

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_centerInParent="true"
                android:text="@string/settings"
                android:paddingTop="50dp"
                android:textColor="@color/white"
                android:textSize="20sp"
                android:fontFamily="@font/oxanium"
                android:textStyle="bold" />
        </RelativeLayout>
        <TextView
            android:id="@+id/batteryOptimizationHelpButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginTop="12dp"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:padding="8dp"
            android:fontFamily="@font/playfair_display"
            android:text="@string/panda_not_working"
            android:textColor="@color/accent"
            android:textSize="16sp"
            android:textStyle="bold" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Voice &amp; Speech"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:fontFamily="@font/playfair_display"
                android:textStyle="bold" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:layout_marginBottom="12dp"
                android:text="@string/select_default_tts_voice"
                android:textColor="#888888"
                android:textSize="14sp" />

            <FrameLayout
                android:layout_width="match_parent"
                android:layout_height="180dp"
                android:layout_marginTop="8dp">

                <View
                    android:layout_width="match_parent"
                    android:layout_height="50dp"
                    android:layout_gravity="center"
                    android:background="@drawable/selection_window_background" />

                <NumberPicker
                    android:id="@+id/ttsVoicePicker"
                    android:layout_width="match_parent"
                    android:fontFamily="@font/oxanium"
                    android:layout_height="match_parent"
                    android:theme="@style/AppTheme.NumberPicker" />

            </FrameLayout>


        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Enable 'Hey Panda!'"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:fontFamily="@font/playfair_display"

                android:textStyle="bold" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:text="@string/get_your_free_picovoice_api_key_you_can_paste_it_here"
                android:textColor="#888888"
                android:textSize="12sp" />

            <TextView
                android:id="@+id/textGetPicovoiceKeyLink"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="?attr/selectableItemBackground"
                android:clickable="true"
                android:focusable="true"
                android:fontFamily="@font/oxanium"
                android:text="@string/get_your_free_accesskey_from_the_picovoice_console"
                android:textColor="@color/accent"
                android:textSize="12sp" />
            <EditText
                android:id="@+id/editWakeWordKey"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:fontFamily="@font/oxanium"

                android:layout_marginTop="12dp"
                android:background="@drawable/edit_text_border"
                android:hint="Paste your key here"

                android:inputType="text"
                android:padding="12dp"
                android:textColor="#CECECE"
                android:textColorHint="#888888" />



            <TextView
                android:id="@+id/wakeWordButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:background="@drawable/rounded_button"
                android:clickable="true"
                android:focusable="true"
                android:gravity="center"
                android:padding="12dp"
                android:text="@string/enable_wake_word"
                android:textColor="@android:color/black"
                android:textSize="16sp" />

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:background="@drawable/rounded_background"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Profile"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:fontFamily="@font/playfair_display"
                android:textStyle="bold" />

            <EditText
                android:id="@+id/editUserName"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="12dp"
                android:fontFamily="@font/oxanium"

                android:background="@drawable/rounded_background"
                android:hint="Your name"
                android:inputType="textPersonName"
                android:padding="12dp"
                android:textColor="#CECECE"
                android:textColorHint="#888888" />

            <EditText
                android:id="@+id/editUserEmail"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="12dp"
                android:background="@drawable/rounded_background"
                android:hint="Your email"
                android:inputType="textEmailAddress"
                android:padding="12dp"
                android:textColor="#CECECE"
                android:textColorHint="#888888" />

            <TextView
                android:id="@+id/textProfileDisclaimer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="This email will not be verified or stored by us. Please enter an accurate email so we don’t have to spend money to onboard you. We treat different emails as different users."
                android:textColor="#888888"
                android:textSize="12sp" />

<!--            <Button-->
<!--                android:id="@+id/buttonSaveProfile"-->
<!--                android:layout_width="match_parent"-->
<!--                android:layout_height="wrap_content"-->
<!--                android:layout_marginTop="12dp"-->
<!--                android:background="@drawable/btn_with_border"-->
<!--                android:text="Save Profile"-->
<!--                android:textColor="@android:color/white" />-->

        </LinearLayout>

        <TextView
            android:id="@+id/permissionsInfoButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginTop="24dp"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:fontFamily="@font/playfair_display"
            android:padding="8dp"
            android:text="@string/why_permissions_needed"
            android:textColor="@color/accent"
            android:textSize="16sp"
            android:textStyle="bold" />

            <TextView
              android:id="@+id/appVersionText"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_horizontal"
              android:layout_marginTop="8dp"
              android:textColor="#888888"
              android:textSize="12sp"
              tools:text="Version 1.2.3" />
            <Button
                android:id="@+id/buttonSignOut"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_horizontal"
                android:layout_marginTop="24dp"
                android:background="@drawable/btn_with_border"
                android:text="@string/sign_out"
                android:textColor="@android:color/white" />
            <TextView
              android:id="@+id/appVersionText"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_horizontal"
              android:layout_marginTop="8dp"
              android:textColor="#888888"
              android:textSize="12sp"
              tools:text="Version 1.2.3" />

    </LinearLayout>

</ScrollView>


================================================
FILE: app/src/main/res/layout/activity_triggers.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/bg_solid"
    android:fitsSystemWindows="true"
    tools:context=".triggers.ui.TriggersActivity">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary"
        app:title="Your Triggers"
        android:fontFamily="@font/playfair_display"
        app:titleTextColor="@color/white" />

    <LinearLayout
        android:id="@+id/trigger_options_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/toolbar"
        android:orientation="vertical"
        android:padding="16dp">

        <CheckBox
            android:id="@+id/enable_triggers_checkbox"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Enable Triggers"
            android:textColor="@color/white" />

        <TextView
            android:id="@+id/triggers_not_working_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/triggers_not_working_for_you"
            android:textColor="@color/accent"
            android:layout_marginTop="8dp"
            android:clickable="true"
            android:focusable="true" />
    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/triggersRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/trigger_options_container"
        android:padding="8dp"
        android:clipToPadding="false"
        tools:listitem="@layout/item_trigger" />

    <com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
        android:id="@+id/addTriggerFab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true"
        android:layout_margin="16dp"
        android:text="Add Trigger"
        app:icon="@drawable/ic_add"
        android:fontFamily="@font/oxanium"
        app:iconTint="@color/white"
        android:textColor="@color/white"
        app:backgroundTint="@color/button_blue"
        android:contentDescription="Add new trigger" />

</RelativeLayout>



================================================
FILE: app/src/main/res/layout/assistant_session_view.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/assistant_root_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#99000000"
    android:clickable="true"
    android:focusable="true">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/clarification_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top|center_horizontal"
        android:layout_marginTop="80dp"
        android:layout_marginStart="16dp"
        android:layout_marginEnd="16dp"
        android:visibility="gone" />

    <TextView
        android:id="@+id/transcription_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|center_horizontal"
        android:layout_marginBottom="180dp"
        android:background="@drawable/glass_background"
        android:paddingStart="24dp"
        android:paddingTop="12dp"
        android:paddingEnd="24dp"
        android:paddingBottom="12dp"
        android:text="Listening..."
        android:textColor="#E0E0E0"
        android:textSize="16sp"
        android:typeface="monospace"
        android:visibility="gone" />

    <include
        android:id="@+id/input_box_container"
        layout="@layout/overlay_input_box"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        android:visibility="gone" />

    <com.blurr.voice.AudioWaveView
        android:id="@+id/audio_wave_view"
        android:layout_width="match_parent"
        android:layout_height="150dp"
        android:layout_gravity="bottom"
        android:visibility="visible" />

</FrameLayout>


================================================
FILE: app/src/main/res/layout/dialog_add_memory.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Add New Memory"
        android:textSize="20sp"
        android:textStyle="bold"
        android:textColor="@color/text_primary"
        android:layout_marginBottom="16dp" />

    <com.google.android.material.textfield.TextInputLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="Enter your memory"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/memoryEditText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textMultiLine"
            android:minLines="3"
            android:maxLines="5"
            android:textColor="@color/text_primary" />

    </com.google.android.material.textfield.TextInputLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="24dp">

        <com.google.android.material.button.MaterialButton
            android:id="@+id/cancelButton"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="8dp"
            android:text="Cancel"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/saveButton"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginStart="8dp"
            android:text="Save"
            android:enabled="false" />

    </LinearLayout>

</LinearLayout> 


================================================
FILE: app/src/main/res/layout/dialog_wake_word_failure.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

        <TextView
            android:id="@+id/dialog_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_marginBottom="16dp"
            android:text="How to Wake Up Panda"
            android:textAppearance="@style/TextAppearance.AppCompat.Large"
            android:textStyle="bold" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="1. Long Press Power Button"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textStyle="bold"
            android:layout_marginTop="8dp"/>
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            android:text="If you've set Panda as your default assistant, you can long-press the power button (or home button on some devices) to activate it."
            android:textAppearance="@style/TextAppearance.AppCompat.Body1"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="2. Home Screen Widget"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textStyle="bold" />
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="8dp"
            android:text="Add the Panda widget to your home screen for one-tap access. Here's how:"
            android:textAppearance="@style/TextAppearance.AppCompat.Body1"/>
        <androidx.cardview.widget.CardView
            android:id="@+id/video_container_card"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:cardCornerRadius="8dp"
            app:cardElevation="4dp">
            <VideoView
                android:id="@+id/video_demo"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:layout_gravity="center"/>
        </androidx.cardview.widget.CardView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="3. Enable 'Hey Panda' Wake Word"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textStyle="bold" />
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="To use the 'Hey Panda' voice command, you need to set it up manually with a Picovoice API key:\n\n1. Go to Settings in this app.\n2. Go to the Picovoice console.\n3. Copy your API access key from the console.\n4. Paste the key back into the app's settings.\n5. Press the 'Save' button.\n6. Return to the home screen and press 'Enable Wake Word'."
            android:textAppearance="@style/TextAppearance.AppCompat.Body1"
            android:lineSpacingExtra="4dp"/>

    </LinearLayout>
</ScrollView>


================================================
FILE: app/src/main/res/layout/floating_panda_button.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<Button xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/floatingPandaButton"
    android:layout_width="120dp"
    android:layout_height="48dp"
    android:text="Hey Panda!"
    android:textSize="12sp"
    android:textColor="@android:color/white"
    android:background="@drawable/floating_button_background"
    android:padding="8dp"
    android:gravity="center"
    android:clickable="true"
    android:focusable="true" /> 


================================================
FILE: app/src/main/res/layout/item_app.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical"
    android:background="?android:attr/selectableItemBackground">

    <ImageView
        android:id="@+id/appIconImageView"
        android:layout_width="40dp"
        android:layout_height="40dp"
        tools:src="@android:mipmap/sym_def_app_icon" />

    <TextView
        android:id="@+id/appNameTextView"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:layout_marginStart="16dp"
        android:textAppearance="@style/TextAppearance.AppCompat.Medium"
        android:textColor="@color/white"
        tools:text="Application Name" />

    <CheckBox
        android:id="@+id/appCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:clickable="false"/>

</LinearLayout>



================================================
FILE: app/src/main/res/layout/item_memory.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardCornerRadius="12dp"
    app:cardElevation="4dp"
    app:cardBackgroundColor="@color/surface">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <TextView
            android:id="@+id/memoryText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textColor="@color/text_primary"
            android:lineSpacingExtra="4dp" />

        <TextView
            android:id="@+id/memoryDate"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:textSize="12sp"
            android:textColor="@color/text_secondary"
            android:fontFamily="monospace" />

    </LinearLayout>

</com.google.android.material.card.MaterialCardView> 


================================================
FILE: app/src/main/res/layout/item_message.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="8dp">

    <TextView
        android:id="@+id/messageText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:text="Hello, welcome!"
        android:background="#e0e0e0"
        android:layout_gravity="start"
        android:textSize="16sp"
        android:textColor="@color/black"
        android:layout_marginBottom="10dp"/>
</LinearLayout>



================================================
FILE: app/src/main/res/layout/item_task_history.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp"
    android:background="@drawable/rounded_background"
    android:layout_marginBottom="8dp"
    android:gravity="center_vertical">

    <!-- Status Emoji -->
    <TextView
        android:id="@+id/status_emoji"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="24sp"
        android:layout_marginEnd="16dp" />

    <!-- Task Details -->
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">

        <!-- Task Text -->
        <TextView
            android:id="@+id/task_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:fontFamily="@font/oxanium_extralight"

            android:textColor="#FFFFFF"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginBottom="4dp" />

        <!-- Status Text -->
        <TextView
            android:id="@+id/status_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="#BDBDBD"
            android:textSize="14sp"
            android:layout_marginBottom="2dp" />

        <!-- Time Text -->
        <TextView
            android:id="@+id/time_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="#888888"
            android:textSize="12sp" />

    </LinearLayout>

</LinearLayout>



================================================
FILE: app/src/main/res/layout/item_trigger.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginStart="8dp"
    android:layout_marginEnd="8dp"
    android:layout_marginBottom="12dp"
    app:cardBackgroundColor="@color/panel_background"
    app:cardCornerRadius="16dp">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="16dp">

        <TextView
            android:id="@+id/triggerInstructionTextView"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginEnd="16dp"
            android:textAppearance="@style/TextAppearance.AppCompat.Large"
            android:textColor="#CECECE"
            android:textSize="18sp"
            android:fontFamily="@font/oxanium"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/triggerEnabledSwitch"
            tools:text="Send a good morning text to Mom" />

        <TextView
            android:id="@+id/triggerTimeTextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textColor="#5880F7"
            android:textSize="16sp"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/triggerInstructionTextView"
            tools:text="At 10:00 AM" />

        <androidx.appcompat.widget.SwitchCompat
            android:id="@+id/triggerEnabledSwitch"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintEnd_toStartOf="@+id/editTriggerButton"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent" />

        <ImageButton
            android:id="@+id/editTriggerButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="Edit trigger"
            android:src="@android:drawable/ic_menu_edit"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/deleteTriggerButton"
            app:layout_constraintTop_toTopOf="parent"
            app:tint="@color/white" />

        <ImageButton
            android:id="@+id/deleteTriggerButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@android:drawable/ic_menu_delete"
            android:background="?attr/selectableItemBackgroundBorderless"
            app:tint="@color/white"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:contentDescription="Delete trigger" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.cardview.widget.CardView>



================================================
FILE: app/src/main/res/layout/overlay_input_box.xml
================================================
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/overlayRootLayout"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="8dp">

    <EditText
        android:id="@+id/overlayInputField"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/input_box_background" android:hint="@string/input_box_hint"
        android:imeOptions="actionDone"
        android:inputType="text"
        android:padding="16dp"
        android:textColor="@android:color/white"
        android:textColorHint="#A0A0A0" />

</FrameLayout>


================================================
FILE: app/src/main/res/layout/overlay_input_container.xml
================================================
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/containerRoot"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#00000000"
    android:clickable="true"
    android:focusable="true">

    <include
        layout="@layout/overlay_input_box"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom" />

</FrameLayout>


================================================
FILE: app/src/main/res/layout/panda_widget_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/widget_root"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:gravity="center"
    android:padding="16dp"
    android:background="@drawable/rounded_background">

    <ImageView
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@drawable/ic_mic"
        android:contentDescription="@string/shortcut_wake_up_short"
        android:layout_marginBottom="8dp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/shortcut_wake_up_short"
        android:textColor="@android:color/white"
        android:textSize="12sp"
        android:textAlignment="center"/>

</LinearLayout>


================================================
FILE: app/src/main/res/layout/pro_upgrade_banner.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/pro_banner"
    android:layout_width="match_parent"
    android:layout_height="56dp"
    android:layout_marginStart="16dp"
    android:layout_marginTop="8dp"
    android:layout_marginEnd="16dp"
    android:layout_marginBottom="8dp"
    android:background="@color/panel_background"
    android:gravity="center_vertical"
    android:orientation="horizontal"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:visibility="gone">

    <TextView
        android:id="@+id/banner_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Get more with Panda Pro"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:textStyle="normal" />

    <TextView
        android:id="@+id/upgrade_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="@drawable/rounded_button"
        android:clickable="true"
        android:focusable="true"
        android:paddingStart="16dp"
        android:paddingTop="8dp"
        android:paddingEnd="16dp"
        android:paddingBottom="8dp"
        android:text="Upgrade"
        android:textColor="@color/panel_background"
        android:textSize="14sp" />

</LinearLayout>


================================================
FILE: app/src/main/res/layout/spinner_closed_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/text1"
    style="?android:attr/spinnerItemStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:ellipsize="end"
    android:singleLine="true"
    android:padding="16dp"
    android:textColor="@color/white"
    android:textSize="16sp"
    android:background="?android:attr/selectableItemBackground" />


================================================
FILE: app/src/main/res/layout/spinner_dropdown_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/text1"
    style="?android:attr/spinnerDropDownItemStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:ellipsize="end"
    android:singleLine="true"
    android:padding="16dp"
    android:textColor="@color/black"
    android:textSize="16sp" />


================================================
FILE: app/src/main/res/menu/menu_memories.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    
    <item
        android:id="@+id/action_privacy"
        android:title="How we handle your data"
        android:icon="@android:drawable/ic_menu_info_details"
        app:showAsAction="never" />
        
</menu> 


================================================
FILE: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
FILE: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
FILE: app/src/main/res/mipmap-hdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-hdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-mdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-mdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xxhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: app/src/main/res/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="wave_color">#00BCD4</color>
    <color name="background_color">#101010</color> <!-- Dark background -->
    <color name="dark_background">#101010</color>
    <color name="button_blue">#FF3663FF</color>
    <color name="text_gray">#FF8A8A8E</color>
    <color name="gradient_start">#FFC882FF</color>
    <color name="gradient_end">#FFA182FF</color>
    <color name="input_box_background">#2E2F33</color>
    <color name="panel_background">#FF1C1C1E</color>
    
    <!-- Memory management colors -->
    <color name="background">#101010</color>
    <color name="primary">#101010</color>
    <color name="accent">#03DAC5</color>
    <color name="surface">#FFFFFF</color>
    <color name="text_primary">#000000</color>
    <color name="text_secondary">#666666</color>
    <color name="orange">#FFBC87</color>

    <!-- Delta symbol state colors -->
    <color name="delta_idle">#FFFFFF</color>        <!-- White - ready state -->
    <color name="delta_listening">#FF9800</color>   <!-- Orange/Amber - listening -->
    <color name="delta_processing">#2196F3</color>  <!-- Blue - thinking/processing -->
    <color name="delta_speaking">#4CAF50</color>    <!-- Green - speaking -->
    <color name="delta_error">#F44336</color>       <!-- Red - error state -->
</resources>


================================================
FILE: app/src/main/res/values/dimens.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Delta symbol dimensions -->
    <dimen name="delta_symbol_size">500dp</dimen>
    <dimen name="status_text_margin_top">24dp</dimen>
    
    <!-- Navigation delta dimensions -->
    <dimen name="delta_nav_size">32dp</dimen>
</resources>


================================================
FILE: app/src/main/res/values/font_certs.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="com_google_android_gms_fonts_certs">
        <item>@array/com_google_android_gms_fonts_certs_dev</item>
        <item>@array/com_google_android_gms_fonts_certs_prod</item>
    </array>
    <string-array name="com_google_android_gms_fonts_certs_dev">
        <item>
            MIIEqDCCA5CgAwIBAgIJANWFuGx90071MA0GCSqGSIb3DQEBBAUAMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAeFw0wODA0MTUyMzM2NTZaFw0zNTA5MDEyMzM2NTZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBANbOLggKv+IxTdGNs8/TGFy0PTP6DHThvbbR24kT9ixcOd9W+EaBPWW+wPPKQmsHxajtWjmQwWfna8mZuSeJS48LIgAZlKkpFeVyxW0qMBujb8X8ETrWy550NaFtI6t9+u7hZeTfHwqNvacKhp1RbE6dBRGWynwMVX8XW8N1+UjFaq6GCJukT4qmpN2afb8sCjUigq0GuMwYXrFVee74bQgLHWGJwPmvmLHC69EH6kWr22ijx4OKXlSIx2xT1AsSHee70w5iDBiK4aph27yH3TxkXy9V89TDdexAcKk/cVHYNnDBapcavl7y0RiQ4biu8ymM8Ga/nmzhRKya6G0cGw8CAQOjgfwwgfkwHQYDVR0OBBYEFI0cxb6VTEM8YYY6FbBMvAPyT+CyMIHJBgNVHSMEgcEwgb6AFI0cxb6VTEM8YYY6FbBMvAPyT+CyoYGapIGXMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbYIJANWFuGx90071MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEEBQADggEBABnTDPEF+3iSP0wNfdIjIz1AlnrPzgAIHVvXxunW7SBrDhEglQZBbKJEk5kT0mtKoOD1JMrSu1xuTKEBahWRbqHsXclaXjoBADb0kkjVEJu/Lh5hgYZnOjvlba8Ld7HCKePCVePoTJBdI4fvugnL8TsgK05aIskyY0hKI9L8KfqfGTl1lzOv2KoWD0KWwtAWPoGChZxmQ+nBli+gwYMzM1vAkP+aayLe0a1EQimlOalO762r0GXO0ks+UeXde2Z4e+8S/pf7pITEI/tP+MxJTALw9QUWEv9lKTk+jkbqxbsh8nfBUapfKqYn0eidpwq2AzVp3juYl7//fKnaPhJD9gs=
        </item>
    </string-array>
    <string-array name="com_google_android_gms_fonts_certs_prod">
        <item>
            MIIEQzCCAyugAwIBAgIJAMLgh0ZkSjCNMA0GCSqGSIb3DQEBBAUAMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDAeFw0wODA4MjEyMzEzMzRaFw0zNjAxMDcyMzEzMzRaMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAKtWLgDYO6IIrgqWbxJOKdoR8qtW0I9Y4sypEwPpt1TTcvZApxsdyxMJZ2JORland2qSGT2y5b+3JKkedxiLDmpHpDsz2WCbdxgxRczfey5YZnTJ4VZbH0xqWVW/8lGmPav5xVwnIiJS6HXk+BVKZF+JcWjAsb/GEuq/eFdpuzSqeYTcfi6idkyugwfYwXFU1+5fZKUaRKYCwkkFQVfcAs1fXA5V+++FGfvjJ/CxURaSxaBvGdGDhfXE28LWuT9ozCl5xw4Yq5OGazvV24mZVSoOO0yZ31j7kYvtwYK6NeADwbSxDdJEqO4k//0zOHKrUiGYXtqw/A0LFFtqoZKFjnkCAQOjgdkwgdYwHQYDVR0OBBYEFMd9jMIhF1Ylmn/Tgt9r45jk14alMIGmBgNVHSMEgZ4wgZuAFMd9jMIhF1Ylmn/Tgt9r45jk14aloXikdjB0MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLR29vZ2xlIEluYy4xEDAOBgNVBAsTB0FuZHJvaWQxEDAOBgNVBAMTB0FuZHJvaWSCCQDC4IdGZEowjTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBAUAA4IBAQBt0lLO74UwLDYKqs6Tm8/yzKkEu116FmH4rkaymUIE0P9KaMftGlMexFlaYjzmB2OxZyl6euNXEsQH8gjwyxCUKRJNexBiGcCEyj6z+a1fuHHvkiaai+KL8W1EyNmgjmyy8AW7P+LLlkR+ho5zEHatRbM/YAnqGcFh5iZBqpknHf1SKMXFh4dd239FJ1jWYfbMDMy3NS5CTMQ2XFI1MvcyUTdZPErjQfTbQe3aDQsQcafEQPD+nqActifKZ0Np0IS9L9kR/wbNvyz6ENwPiTrjV2KRkEjH78ZMcUQXg0L3BYHJ3lc69Vs5Ddf9uUGGMYldX3WfMBEmh/9iFBDAaTCK
        </item>
    </string-array>
</resources>



================================================
FILE: app/src/main/res/values/preloaded_fonts.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="preloaded_fonts" translatable="false">
        <item>@font/megrim</item>
        <item>@font/oxanium</item>
        <item>@font/oxanium_extralight</item>
        <item>@font/playfair_display</item>
        <item>@font/roboto</item>
    </array>
</resources>



================================================
FILE: app/src/main/res/values/strings.xml
================================================
<resources>
    <string name="app_name">panda</string>
    <string name="input_the_task">Input the Task</string>
    <string name="perform_task">Perform Task</string>
    <string name="content_filtering">Content Filtering</string>
    <string name="write_things_you_want_to_avoid">Write Things you want to avoid</string>
    <string name="accessibility_service_label">Panda Accessibility Service</string>
    <string name="accessibility_service_description">Panda AI Assistant uses accessibility services to provide voice-controlled device automation. This allows hands-free operation of your phone through AI-powered commands, making technology more accessible. The service reads screen content and performs actions only when actively requested by you.</string>
    <string name="view_source_code_on_github">⭐ See the code on Github</string>
    <string name="hello_sir">Hey, Panda Here</string>
    <string name="assistant_at_nyour_command">Assistant at\nYour Command</string>
    <string name="grant_accessibility_permission">Grant Accessibility Permission</string>
    <string name="permission_not_granted">Permission: Not Granted</string>
    <string name="service_status_stopped">Service Status: Stopped</string>
    <string name="wake_word_help_link"><u>Wake word not initializing? Open me!</u></string>
    <string name="notifications_permission_title">Notifications</string>
    <string name="notifications_permission_desc">Allow Panda to send you notifications for important updates or messages.</string>
    <string name="default_assistant_role_title">Set as Default Assistant</string>
    <string name="default_assistant_role_desc">This lets you activate Panda by holding the home button or using a voice command, even when the app is closed.</string>
    <string name="grant_permission_button">Grant Permission</string>
    <string name="finish_onboarding_button">Finish Onboarding</string>
    <string name="vision_mode">Vision Mode:</string>
    <string name="xml_mode">XML Mode</string>
    <string name="screenshot_mode">Screenshot Mode</string>
    <string name="xml_mode_description">Uses UI structure data (faster, less resource intensive)</string>
    <string name="screenshot_mode_description">Uses actual screenshots (more accurate, higher resource usage)</string>
    <string name="voice_input">Voice Command</string>
    <string name="hold_to_speak">Hold to Speak Command</string>
    <string name="shortcut_wake_up_short">Wake up Panda</string>
    <string name="shortcut_wake_up_long">Start a new conversation with Panda</string>
    <string name="listening">Listening…</string>
    <string name="speech_error">Speech recognition error</string>
    <string name="no_speech_detected">No speech detected</string>
    <string name="input_box_hint">+ Ask Panda</string>
    <string name="speech_permission_required">Microphone permission required for voice input</string>
    <string name="processing_voice_command">Processing voice command…</string>
    <string name="performing_task">I will perform the task: %s</string>
    <string name="starting_agent_task">Starting agent task for: %s</string>
    <string name="clarification_needed">Clarification needed</string>
    <string name="dialogue_cancelled">Dialogue cancelled</string>
    <string name="submit_answer">Submit Answer</string>
    <string name="accessibility_permission_details">
    "<b>🤖 Why Panda Needs Accessibility Services:</b>\n"
    "Panda is an AI assistant that helps you control your phone through voice commands. To do this, it requires accessibility permissions to understand and interact with your device.\n\n"
    "<b>📱 What This Permission Allows:</b>\n"
    "<b>• Read Screen Content:</b> Panda can see and analyze what\'s currently displayed on your screen to understand the context and provide relevant assistance.\n\n"
    "<b>• Perform Actions:</b> Execute touch gestures, taps, swipes, and navigation (Back, Home, Recent Apps) on your behalf based on your voice commands.\n\n"
    "<b>• App Interaction:</b> Open apps, fill forms, scroll through content, and navigate between different screens as requested.\n\n"
    "<b>🔒 Privacy &amp; Data Protection:</b>\n"
    "• All processing happens on Gemini API\n"
    "• No personal data is collected or but it is sent to Google Gemini\n"
    "• Screen content is only accessed when you actively use Panda, otherwise Panda doesnt access screen content\n"
    "• We implement safeguards to protect sensitive information, but Panda can still make mistake\n\n"
    "<b>♿ Accessibility Benefits:</b>\n"
    "This service enables hands-free device control, making smartphones more accessible for users with disabilities, visual impairments, or mobility limitations.\n\n"
    "<b>By proceeding, you understand and consent to Panda using accessibility services for AI-powered device automation.</b>"
    </string>
    <string name="app_list_permission_title">App Management</string>
    <string name="app_list_permission_desc">Allows Panda to see the apps you have installed. With this, Panda can open applications for you directly and instantly (e.g., "Open YouTube"), instead of relying on slower methods of searching the screen. This makes the process much faster and more reliable.</string>
<!--    <string name="accessibility_consent_title">Permission Confirmation</string>-->
<!--    <string name="accessibility_consent_message">To enable hands-free control, Panda requires Accessibility permission. This allows the app to:\n\n• <b>Read the content on your screen</b> to understand context.\n\n• <b>Perform actions for you</b> like tapping, scrolling, and navigating.\n\nPanda is designed to assist, especially visually impaired users, by enabling full voice control of the device.\n\nDo you want to proceed to Settings to enable this?</string>-->
<!--    <string name="accept">Accept</string>-->
<!--    <string name="decline">Decline</string>-->
    <string name="cancel">Cancel</string>
    <string name="type_answer_here">Type your answer here…</string>
    <string name="or_use_voice_input">Or use voice input</string>
    <string name="enable_wake_word">Enable Wake Word</string>
    <string name="wake_word_engine">Wake Word Engine</string>
    <string name="stt_engine">STT Engine</string>
    <string name="porcupine_engine">If there is too much demand, our wake word service might be down, in that case we will add button at the bottom left and you can use it to activate panda</string>
    <string name="select_wake_word_engine">Select Wake Word Engine</string>
    <string name="wake_word_enabled">Wake Word enabled with %s</string>
    <string name="wake_word_disabled">Disable Wake Word</string>
    <string name="porcupine_access_key_required">Porcupine Access Key required</string>
    <string name="settings">Settings</string>
    <string name="back">Back</string>
    <string name="tts_voice_settings">TTS Voice Settings</string>
    <string name="select_default_tts_voice">Select your preferred default voice for text-to-speech</string>
    <string name="standard_male_voice">Standard Male Voice</string>
    <string name="standard_male_description">Clear, professional male voice</string>
    <string name="standard_female_voice">Standard Female Voice</string>
    <string name="standard_female_description">Clear, professional female voice</string>
    <string name="neural_male_voice">Neural Male Voice</string>
    <string name="neural_male_description">Natural-sounding male voice with neural technology</string>
    <string name="neural_female_voice">Neural Female Voice</string>
    <string name="neural_female_description">Natural-sounding female voice with neural technology</string>
    <string name="studio_male_voice">Studio Male Voice</string>
    <string name="studio_male_description">High-quality studio male voice</string>
    <string name="test_selected_voice">Test Selected Voice</string>
    <string name="save_settings">Save Settings</string>
    <string name="settings_saved">Settings saved successfully</string>
    <string name="testing_voice">Testing voice…</string>
    <string name="why_permissions_needed"><u>Why are these permissions needed?</u></string>
    <string name="permissions_explained_title">Permissions Explained</string>
    <string name="accessibility_permission_title">Accessibility Service</string>
    <string name="accessibility_permission_desc">🤖 Enable Panda AI to control your phone through voice commands. This permission allows reading screen content and performing actions for hands-free device automation and improved accessibility.</string>
    <string name="microphone_permission_title">Microphone</string>
    <string name="microphone_permission_desc">The microphone is required for the voice command and wake-word features. It allows you to give instructions to Panda by speaking.</string>
    <string name="overlay_permission_title">Display Over Other Apps</string>
    <string name="overlay_permission_desc">This permission is used to show visual feedback, such as the questions that panda have, captions and the voice wave animations, on top of other apps while Panda is working.</string>
    <string name="default_assistant_permission_title">Default Assistant</string>
    <string name="grant_default_assistant_permission_button">Set as Default Assistant</string>
    <string name="at_the_end_of_a_conversation_panda_s_ai_powered_by_google_s_gemini_model_analyzes_the_dialogue_to_identify_lasting_facts_it_s_trained_to_ignore_fleeting_or_unimportant_details_for_example_if_you_say_remind_me_to_call_my_brother_ankit_tomorrow_the_ai_might_create_a_memory_like_the_user_s_brother_is_named_ankit">At the end of a conversation, Panda\'s AI (powered by Google\'s Gemini model) analyzes the dialogue to identify lasting facts. It\'s trained to ignore fleeting or unimportant details. For example, if you say, || remind me to call my brother Ankit tomorrow ||,the AI might create a memory like: || The user\'s brother is named Anita. ||</string>
    <string name="once_a_memory_is_created_e_g_the_user_lives_in_ghaziabad_it_is_stored_in_a_secure_private_database_directly_on_your_phone_this_database_is_part_of_the_panda_app_s_internal_storage_and_is_not_accessible_by_other_apps">Once a memory is created (e.g., The user lives in Ghaziabad.), it is stored in a secure, private database directly on your phone. This database is part of the Panda app\'s internal storage and is not accessible by other apps.</string>
    <string name="accessibility_permission_full_desc">🤖 Panda is an AI assistant that needs accessibility services to control your phone through voice commands.\n\nThis permission allows Panda to:\n\n• Read screen content to understand context\n• Perform touches, swipes, and navigation\n• Automate tasks across all apps\n\n🔒 Your privacy is Google Privacy Rule for Gemini API - Your app calls Gemini API to understand his next action.</string>

    <string name="accessibility_consent_title">🤖 Accessibility Services Required</string>
    <string name="accessibility_consent_message">Panda requires accessibility services to function as your AI assistant.\n\nThis enables voice-controlled automation of your device for hands-free operation and improved accessibility.\n\n🔒 All data processing occurs locally on your device for maximum privacy.</string>
    <string name="accept">Accept</string>
    <string name="decline">Decline</string>

    
    <!-- Battery optimization help -->
    <string name="panda_not_working"><u>Panda not working on your phone?</u></string>
    <string name="battery_optimization_title">Battery Optimization Issues</string>
    <string name="battery_optimization_message">If Panda is not working properly, this might be due to intense battery optimization by your device manufacturer.\n\nManufacturers like Samsung, Huawei, OnePlus, Xiaomi, and others often add aggressive battery optimizations that can break Panda\'s functionality.\n\nTo fix this, you need to disable battery optimizations specifically for Panda in your device settings.</string>
    <string name="learn_how">Learn How</string>
    <string name="get_your_free_picovoice_api_key_you_can_paste_it_here">Get your free Picovoice API Key, you can paste it here.</string>

    <string name="microphone_permission_not_granted">Microphone permission not granted</string>
    <string name="accessibility_permission_needed_for_task">Hey, accessibility permission is needed to execute any task. I know you might have doubt giving this permission to me, but my code is open source, so can always check it out if you have doubts.</string>
    <string name="get_your_free_accesskey_from_the_picovoice_console"><u>Get your free AccessKey from the Picovoice Console</u></string>
    <string name="triggers_not_working_for_you"><u>Triggers not working for you?</u>u></string>
    <string name="sign_out">Sign Out</string>
</resources>



================================================
FILE: app/src/main/res/values/themes.xml
================================================
<!-- res/values/themes.xml -->
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.Blurr" parent="Theme.MaterialComponents.Light.NoActionBar">
        <!-- Required for AppCompat -->
        <item name="colorPrimary">@color/primary</item>
        <item name="colorPrimaryVariant">@color/primary</item>
        <item name="colorOnPrimary">@color/white</item>

        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>

        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <item name="android:windowBackground">@color/background</item>
        <item name="android:colorBackground">@color/background</item>
        
        <!-- Force light status bar content on dark background -->
        <item name="android:windowLightStatusBar" tools:targetApi="m">false</item>
        <item name="android:windowLightNavigationBar" tools:targetApi="o">false</item>
    </style>

    <style name="PermissionHeading" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textColor">#5880F7</item>
        <item name="android:textSize">20sp</item>
        <item name="android:textStyle">bold</item>
        <item name="android:layout_marginTop">16dp</item>
        <item name="android:layout_marginBottom">4dp</item>
    </style>

    <style name="PermissionDescription" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textColor">#CECECE</item>
        <item name="android:textSize">16sp</item>
        <item name="android:lineSpacingMultiplier">1.2</item>
        <item name="android:layout_marginBottom">16dp</item>
    </style>

    <style name="PermissionStatus" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginStart">16dp</item>
        <item name="android:paddingLeft">12dp</item>
        <item name="android:paddingRight">12dp</item>
        <item name="android:paddingTop">4dp</item>
        <item name="android:paddingBottom">4dp</item>
        <item name="android:textStyle">bold</item>
        <item name="android:textSize">14sp</item>
    </style>

    <style name="AppTheme.NumberPicker" parent="Theme.AppCompat.Light">
        <item name="android:textColorPrimary">@android:color/white</item>

        <item name="colorControlNormal">@android:color/transparent</item>
    </style>

</resources>


<!--<resources>-->
<!--<style name="Theme.Blurr" parent="Theme.Material3.Dark.NoActionBar">-->
<!--</style>-->
<!--</resources>-->


================================================
FILE: app/src/main/res/values-night/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="wave_color">#00BCD4</color>
    <color name="background_color">#161616</color> <!-- Dark background -->
    <color name="dark_background">#161616</color>
    <color name="button_blue">#FF3663FF</color>
    <color name="text_gray">#FF8A8A8E</color>
    <color name="gradient_start">#FFC882FF</color>
    <color name="gradient_end">#FFA182FF</color>
    <color name="input_box_background">#161616</color>
    <color name="panel_background">#161616</color>
    
    <!-- Memory management colors -->
    <color name="background">#161616</color>
    <color name="primary">#161616</color>
    <color name="accent">#03DAC5</color>
    <color name="surface">#161616</color>
    <color name="text_primary">#FFFFFF</color>
    <color name="text_secondary">#CCCCCC</color>
</resources>


================================================
FILE: app/src/main/res/values-night/themes.xml
================================================
<!-- res/values-night/themes.xml -->
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.Blurr" parent="Theme.MaterialComponents.Light.NoActionBar">
        <!-- Required for AppCompat -->
        <item name="colorPrimary">@color/primary</item>
        <item name="colorPrimaryVariant">@color/primary</item>
        <item name="colorOnPrimary">@color/white</item>

        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>

        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <item name="android:windowBackground">@color/background</item>
        <item name="android:colorBackground">@color/background</item>
        
        <!-- Force light status bar content on dark background -->
        <item name="android:windowLightStatusBar" tools:targetApi="m">false</item>
        <item name="android:windowLightNavigationBar" tools:targetApi="o">false</item>
    </style>

    <style name="PermissionHeading" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textColor">#5880F7</item>
        <item name="android:textSize">20sp</item>
        <item name="android:textStyle">bold</item>
        <item name="android:layout_marginTop">16dp</item>
        <item name="android:layout_marginBottom">4dp</item>
    </style>

    <style name="PermissionDescription" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:textColor">#CECECE</item>
        <item name="android:textSize">16sp</item>
        <item name="android:lineSpacingMultiplier">1.2</item>
        <item name="android:layout_marginBottom">16dp</item>
    </style>

    <style name="PermissionStatus" parent="Widget.AppCompat.TextView">
        <item name="android:layout_width">wrap_content</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_marginStart">16dp</item>
        <item name="android:paddingLeft">12dp</item>
        <item name="android:paddingRight">12dp</item>
        <item name="android:paddingTop">4dp</item>
        <item name="android:paddingBottom">4dp</item>
        <item name="android:textStyle">bold</item>
        <item name="android:textSize">14sp</item>
    </style>

    <style name="AppTheme.NumberPicker" parent="Theme.AppCompat.Light">
        <item name="android:textColorPrimary">@android:color/white</item>
        <item name="colorControlNormal">@android:color/transparent</item>
    </style>

</resources>


================================================
FILE: app/src/main/res/xml/accessibility_service_config.xml
================================================
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/accessibility_service_description"
    android:accessibilityEventTypes="typeWindowStateChanged|typeViewClicked|typeViewFocused"
    android:accessibilityFlags="flagDefault|flagIncludeNotImportantViews|flagReportViewIds|flagRetrieveInteractiveWindows"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true"
    android:canPerformGestures="true"
    android:canTakeScreenshot="true" />


================================================
FILE: app/src/main/res/xml/backup_rules.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>


================================================
FILE: app/src/main/res/xml/data_extraction_rules.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>


================================================
FILE: app/src/main/res/xml/network_security_config.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">10.0.2.2</domain>
    </domain-config>
</network-security-config>



================================================
FILE: app/src/main/res/xml/panda_widget_info.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:minWidth="110dp"
    android:minHeight="110dp"
    android:updatePeriodMillis="0"
    android:initialLayout="@layout/panda_widget_layout"
    android:description="@string/shortcut_wake_up_long"
    android:previewLayout="@layout/panda_widget_layout"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen">
</appwidget-provider>


================================================
FILE: app/src/main/res/xml/shortcuts.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
    <shortcut
        android:shortcutId="wake_up_panda"
        android:enabled="true"
        android:icon="@drawable/ic_mic"
        android:shortcutShortLabel="@string/shortcut_wake_up_short"
        android:shortcutLongLabel="@string/shortcut_wake_up_long">
        <intent
            android:action="com.blurr.voice.WAKE_UP_PANDA"
            android:targetPackage="com.blurr.voice"
            android:targetClass="com.blurr.voice.MainActivity" />
        <categories android:name="android.shortcut.conversation" />
    </shortcut>
</shortcuts>


================================================
FILE: app/src/main/res/xml/voice_interaction_service.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<voice-interaction-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:sessionService="com.blurr.voice.PandaVoiceInteractionSessionService"
    android:supportsAssist="true" />


================================================
FILE: app/src/test/java/com/blurr/voice/ConversationalAgentServiceTest.kt
================================================
package com.blurr.voice

import org.junit.Test
import org.junit.Assert.*

/**
 * Unit tests for ConversationalAgentService behavior changes
 * Testing that greeting is skipped and listening starts immediately
 */
class ConversationalAgentServiceTest {
    
    @Test
    fun test_hasHeardFirstUtterance_initiallyFalse() {
        // Test that the hasHeardFirstUtterance flag is properly initialized
        // Note: This is a behavioral test - we can't easily test the actual service
        // without extensive mocking of Android components
        
        // Simulating initial state
        val hasHeardFirstUtterance = false
        assertFalse("hasHeardFirstUtterance should be false initially", hasHeardFirstUtterance)
    }
    
    @Test
    fun test_firstUtteranceTriggersMemoryExtraction() {
        // Test that memory extraction is deferred until first utterance
        
        // Simulating the flow:
        var hasHeardFirstUtterance = false
        var memoryExtractionCalled = false
        
        // Simulate service startup (no memory extraction)
        assertFalse("Memory extraction should not be called on startup", memoryExtractionCalled)
        
        // Simulate first user utterance
        if (!hasHeardFirstUtterance) {
            hasHeardFirstUtterance = true
            memoryExtractionCalled = true // This would be the call to updateSystemPromptWithMemories()
        }
        
        assertTrue("hasHeardFirstUtterance should be true after first utterance", hasHeardFirstUtterance)
        assertTrue("Memory extraction should be called after first utterance", memoryExtractionCalled)
    }
    
    @Test
    fun test_subsequentUtterancesDoNotRetriggerMemoryExtraction() {
        // Test that memory extraction is only triggered once
        
        var hasHeardFirstUtterance = false
        var memoryExtractionCallCount = 0
        
        // Simulate first utterance
        if (!hasHeardFirstUtterance) {
            hasHeardFirstUtterance = true
            memoryExtractionCallCount++
        }
        
        // Simulate second utterance
        if (!hasHeardFirstUtterance) {
            hasHeardFirstUtterance = true
            memoryExtractionCallCount++
        }
        
        assertEquals("Memory extraction should only be called once", 1, memoryExtractionCallCount)
    }
    
    @Test 
    fun test_noGreetingOnStartup() {
        // Test that no greeting is sent on service startup
        
        var greetingSent = false
        val conversationHistorySize = 1 // Just the system prompt
        
        // Simulate the old behavior (removed)
        // if (conversationHistory.size == 1) {
        //     greetingSent = true
        // }
        
        // With our changes, no greeting should be sent
        assertFalse("No greeting should be sent on startup", greetingSent)
    }
}


================================================
FILE: app/src/test/java/com/blurr/voice/ExampleUnitTest.kt
================================================
package com.blurr.voice

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}


================================================
FILE: app/src/test/java/com/blurr/voice/VersionManagementTest.kt
================================================
package com.blurr.voice

import org.junit.Test
import org.junit.Assert.*
import org.junit.Before
import org.junit.After
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.util.Properties

/**
 * Unit tests for automated version management functionality.
 * 
 * Tests the version increment logic used in build.gradle.kts for release builds.
 */
class VersionManagementTest {
    
    private lateinit var testVersionFile: File
    private val testVersionFileName = "test_version.properties"
    
    @Before
    fun setUp() {
        testVersionFile = File(testVersionFileName)
        // Create a test version file
        createTestVersionFile(13, "1.0.13")
    }
    
    @After
    fun tearDown() {
        if (testVersionFile.exists()) {
            testVersionFile.delete()
        }
    }
    
    private fun createTestVersionFile(versionCode: Int, versionName: String) {
        val output = FileOutputStream(testVersionFile)
        output.use { fileOutput ->
            fileOutput.write("# Test version configuration\n".toByteArray())
            fileOutput.write("VERSION_CODE=$versionCode\n".toByteArray())
            fileOutput.write("VERSION_NAME=$versionName".toByteArray())
        }
    }
    
    private fun readVersionFromFile(): Pair<Int, String> {
        val props = Properties()
        props.load(FileInputStream(testVersionFile))
        return Pair(
            props.getProperty("VERSION_CODE").toInt(),
            props.getProperty("VERSION_NAME")
        )
    }
    
    @Test
    fun testVersionLoading() {
        val (versionCode, versionName) = readVersionFromFile()
        assertEquals("Version code should be loaded correctly", 13, versionCode)
        assertEquals("Version name should be loaded correctly", "1.0.13", versionName)
    }
    
    @Test
    fun testVersionCodeIncrement() {
        val props = Properties()
        props.load(FileInputStream(testVersionFile))
        
        val currentVersionCode = props.getProperty("VERSION_CODE").toInt()
        val newVersionCode = currentVersionCode + 1
        
        assertEquals("Version code should increment by 1", 14, newVersionCode)
    }
    
    @Test
    fun testVersionNameIncrement() {
        val props = Properties()
        props.load(FileInputStream(testVersionFile))
        
        val currentVersionName = props.getProperty("VERSION_NAME")
        val versionParts = currentVersionName.split(".")
        val newPatchVersion = if (versionParts.size >= 3) {
            versionParts[2].toInt() + 1
        } else {
            1
        }
        val newVersionName = if (versionParts.size >= 2) {
            "${versionParts[0]}.${versionParts[1]}.$newPatchVersion"
        } else {
            "1.0.$newPatchVersion"
        }
        
        assertEquals("Version name should increment patch version", "1.0.14", newVersionName)
    }
    
    @Test
    fun testCompleteVersionIncrement() {
        // Simulate the complete increment logic from build.gradle.kts
        val props = Properties()
        props.load(FileInputStream(testVersionFile))
        
        val currentVersionCode = props.getProperty("VERSION_CODE").toInt()
        val currentVersionName = props.getProperty("VERSION_NAME")
        
        // Increment version code
        val newVersionCode = currentVersionCode + 1
        
        // Increment patch version in semantic versioning (x.y.z -> x.y.z+1)
        val versionParts = currentVersionName.split(".")
        val newPatchVersion = if (versionParts.size >= 3) {
            versionParts[2].toInt() + 1
        } else {
            1
        }
        val newVersionName = if (versionParts.size >= 2) {
            "${versionParts[0]}.${versionParts[1]}.$newPatchVersion"
        } else {
            "1.0.$newPatchVersion"
        }
        
        // Update properties
        props.setProperty("VERSION_CODE", newVersionCode.toString())
        props.setProperty("VERSION_NAME", newVersionName)
        
        // Save back to file
        val output = FileOutputStream(testVersionFile)
        output.use { fileOutput ->
            fileOutput.write("# Test version configuration\n".toByteArray())
            fileOutput.write("VERSION_CODE=$newVersionCode\n".toByteArray())
            fileOutput.write("VERSION_NAME=$newVersionName".toByteArray())
        }
        
        // Verify the increment worked
        val (finalVersionCode, finalVersionName) = readVersionFromFile()
        assertEquals("Final version code should be incremented", 14, finalVersionCode)
        assertEquals("Final version name should be incremented", "1.0.14", finalVersionName)
    }
    
    @Test
    fun testMultipleIncrements() {
        var expectedCode = 13
        var expectedName = "1.0.13"
        
        // Test 3 sequential increments
        for (i in 1..3) {
            val props = Properties()
            props.load(FileInputStream(testVersionFile))
            
            val currentVersionCode = props.getProperty("VERSION_CODE").toInt()
            val currentVersionName = props.getProperty("VERSION_NAME")
            
            assertEquals("Current version code should match expected", expectedCode, currentVersionCode)
            assertEquals("Current version name should match expected", expectedName, currentVersionName)
            
            // Increment
            val newVersionCode = currentVersionCode + 1
            val versionParts = currentVersionName.split(".")
            val newPatchVersion = versionParts[2].toInt() + 1
            val newVersionName = "${versionParts[0]}.${versionParts[1]}.$newPatchVersion"
            
            // Update file
            val output = FileOutputStream(testVersionFile)
            output.use { fileOutput ->
                fileOutput.write("# Test version configuration\n".toByteArray())
                fileOutput.write("VERSION_CODE=$newVersionCode\n".toByteArray())
                fileOutput.write("VERSION_NAME=$newVersionName".toByteArray())
            }
            
            // Update expected values for next iteration
            expectedCode = newVersionCode
            expectedName = newVersionName
        }
        
        // Final verification
        val (finalVersionCode, finalVersionName) = readVersionFromFile()
        assertEquals("Final version code after 3 increments", 16, finalVersionCode)
        assertEquals("Final version name after 3 increments", "1.0.16", finalVersionName)
    }
    
    @Test
    fun testVersionParsingEdgeCases() {
        // Test with different version name formats
        createTestVersionFile(1, "2.5.0")
        val props = Properties()
        props.load(FileInputStream(testVersionFile))
        
        val versionName = props.getProperty("VERSION_NAME")
        val versionParts = versionName.split(".")
        val newPatchVersion = versionParts[2].toInt() + 1
        val newVersionName = "${versionParts[0]}.${versionParts[1]}.$newPatchVersion"
        
        assertEquals("Should handle different major.minor versions", "2.5.1", newVersionName)
    }
    
    @Test
    fun testVersionFileWithDefaults() {
        // Test fallback behavior when properties are missing
        val tempFile = File("temp_empty.properties")
        FileOutputStream(tempFile).use { it.write("".toByteArray()) }
        
        try {
            val props = Properties()
            props.load(FileInputStream(tempFile))
            
            val versionCode = props.getProperty("VERSION_CODE", "13").toInt()
            val versionName = props.getProperty("VERSION_NAME", "1.0.13")
            
            assertEquals("Should use default version code", 13, versionCode)
            assertEquals("Should use default version name", "1.0.13", versionName)
        } finally {
            tempFile.delete()
        }
    }
}


================================================
FILE: app/src/test/java/com/blurr/voice/WakeWordButtonRelocationTest.kt
================================================
package com.blurr.voice

import org.junit.Test
import org.junit.Assert.*

/**
 * Simple test to verify the wake word button relocation changes.
 * This tests the logical flow of the new implementation.
 */
class WakeWordButtonRelocationTest {

    @Test
    fun testWakeWordButtonFlow() {
        // Test that the logical flow makes sense
        
        // 1. MainActivity should no longer handle wake word directly
        // This is verified by the absence of wake word logic in MainActivity
        
        // 2. SettingsActivity should handle wake word management
        // This includes key management and wake word enable/disable
        
        // 3. Key validation should happen before enabling wake word
        // Empty or null keys should prevent wake word activation
        
        val emptyKey = ""
        val nullKey: String? = null
        val validKey = "test_key_123"
        
        assertFalse("Empty key should not be valid", isKeyValid(emptyKey))
        assertFalse("Null key should not be valid", isKeyValid(nullKey))
        assertTrue("Valid key should be accepted", isKeyValid(validKey))
    }
    
    @Test
    fun testUserFlowNavigation() {
        // Test the navigation flow from MainActivity to Settings
        
        // 1. User clicks "Setup Wake Word" in MainActivity
        // 2. App should navigate to SettingsActivity
        // 3. User can manage wake word settings in Settings
        
        val expectedNavigationTarget = "SettingsActivity"
        val actualNavigationTarget = getMainActivityWakeWordButtonTarget()
        
        assertEquals("MainActivity wake word button should navigate to Settings", 
                    expectedNavigationTarget, actualNavigationTarget)
    }
    
    @Test
    fun testErrorHandling() {
        // Test error handling for various scenarios
        
        // 1. No key present - should show dialog
        assertFalse("Should not enable wake word without key", canEnableWakeWordWithoutKey())
        
        // 2. Mobile browser compatibility - should handle gracefully
        assertTrue("Should handle mobile browser issues gracefully", handlesMobileBrowserIssues())
    }
    
    // Helper methods to simulate the logic
    private fun isKeyValid(key: String?): Boolean {
        return !key.isNullOrBlank()
    }
    
    private fun getMainActivityWakeWordButtonTarget(): String {
        // In our implementation, the button now navigates to SettingsActivity
        return "SettingsActivity"
    }
    
    private fun canEnableWakeWordWithoutKey(): Boolean {
        // Our implementation should prevent this
        return false
    }
    
    private fun handlesMobileBrowserIssues(): Boolean {
        // Our implementation includes error handling for mobile browser issues
        return true
    }
}


================================================
FILE: app/src/test/java/com/blurr/voice/agent/v2/SystemPromptTest.kt
================================================
package com.blurr.voice.agent.v2

import com.blurr.voice.agent.v2.prompts.SystemPrompt
import org.junit.Test
import org.junit.Assert.*
import org.junit.Before
import org.junit.After
import java.io.File

class SystemPromptTest {

    private val testActionDescription = "click_button, type_text, scroll_screen"
    private val testMaxActions = 5

    @Before
    fun setUp() {
        // Clean up any test files
        cleanupTestFiles()
    }

    @After
    fun tearDown() {
        // Clean up any test files
        cleanupTestFiles()
    }

    @Test
    fun `test SystemPrompt with default parameters`() {
        val systemPrompt = SystemPrompt(testActionDescription)
        val message = systemPrompt.getSystemMessage()
        
        assertNotNull("Message should not be null", message)
        assertNotNull("Message content should not be null", message.content)
        assertTrue("Message content should contain action description", 
                  message.content.contains(testActionDescription))
        assertTrue("Message content should contain max actions", 
                  message.content.contains(testMaxActions.toString()))
    }

    @Test
    fun `test SystemPrompt with custom maxActionsPerStep`() {
        val customMaxActions = 15
        val systemPrompt = SystemPrompt(testActionDescription, maxActionsPerStep = customMaxActions)
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message content should contain custom max actions", 
                  message.content.contains(customMaxActions.toString()))
    }

    @Test
    fun `test SystemPrompt with overrideSystemMessage`() {
        val overrideMessage = "This is a custom override message"
        val systemPrompt = SystemPrompt(
            actionDescription = testActionDescription,
            overrideSystemMessage = overrideMessage
        )
        val message = systemPrompt.getSystemMessage()
        
        assertEquals("Message content should match override message", overrideMessage, message.content)
        assertFalse("Message content should not contain action description", 
                   message.content.contains(testActionDescription))
    }

    @Test
    fun `test SystemPrompt with extendSystemMessage`() {
        val extendMessage = "Additional instructions for the agent"
        val systemPrompt = SystemPrompt(
            actionDescription = testActionDescription,
            extendSystemMessage = extendMessage
        )
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message content should contain action description", 
                  message.content.contains(testActionDescription))
        assertTrue("Message content should contain extended message", 
                  message.content.contains(extendMessage))
        assertTrue("Extended message should be at the end", 
                  message.content.endsWith(extendMessage))
    }

    @Test
    fun `test SystemPrompt with both override and extend`() {
        val overrideMessage = "Base override message"
        val extendMessage = "Extended message"
        val systemPrompt = SystemPrompt(
            actionDescription = testActionDescription,
            overrideSystemMessage = overrideMessage,
            extendSystemMessage = extendMessage
        )
        val message = systemPrompt.getSystemMessage()
        
        val expectedContent = "$overrideMessage\n$extendMessage"
        assertEquals("Message content should combine override and extend", expectedContent, message.content)
    }

    @Test
    fun `test SystemPrompt template replacement`() {
        val systemPrompt = SystemPrompt(testActionDescription, maxActionsPerStep = 8)
        val message = systemPrompt.getSystemMessage()
        
        // Check that both placeholders are replaced
        assertFalse("Template should not contain {max_actions} placeholder", 
                   message.content.contains("{max_actions}"))
        assertFalse("Template should not contain {actionDescription} placeholder", 
                   message.content.contains("{actionDescription}"))
        
        // Check that values are properly inserted
        assertTrue("Message should contain max actions value", 
                  message.content.contains("8"))
        assertTrue("Message should contain action description", 
                  message.content.contains(testActionDescription))
    }

    @Test
    fun `test SystemPrompt with empty action description`() {
        val systemPrompt = SystemPrompt("")
        val message = systemPrompt.getSystemMessage()
        
        assertNotNull("Message should not be null", message)
        assertNotNull("Message content should not be null", message.content)
        assertTrue("Message content should be empty for action description", 
                  message.content.contains(""))
    }

    @Test
    fun `test SystemPrompt with special characters in action description`() {
        val specialActionDescription = "click_button[0], type_text(\"hello\"), scroll_screen{up}"
        val systemPrompt = SystemPrompt(specialActionDescription)
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message should contain special characters", 
                  message.content.contains(specialActionDescription))
    }

    @Test
    fun `test SystemPrompt with very long action description`() {
        val longActionDescription = "action1, action2, action3, action4, action5, action6, action7, action8, action9, action10"
        val systemPrompt = SystemPrompt(longActionDescription)
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message should contain long action description", 
                  message.content.contains(longActionDescription))
    }

    @Test
    fun `test SystemPrompt message content structure`() {
        val systemPrompt = SystemPrompt(testActionDescription)
        val message = systemPrompt.getSystemMessage()
        
        val content = message.content
        
        // Check that the message contains expected sections
        assertTrue("Message should contain Functions section", 
                  content.contains("Functions:"))
        assertTrue("Message should contain Example section", 
                  content.contains("Example:"))
        assertTrue("Message should contain AVAILABLE ACTIONS", 
                  content.contains("AVAILABLE ACTIONS:"))
    }

    @Test
    fun `test SystemPrompt with zero max actions`() {
        val systemPrompt = SystemPrompt(testActionDescription, maxActionsPerStep = 0)
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message should contain zero max actions", 
                  message.content.contains("0"))
    }

    @Test
    fun `test SystemPrompt with negative max actions`() {
        val systemPrompt = SystemPrompt(testActionDescription, maxActionsPerStep = -5)
        val message = systemPrompt.getSystemMessage()
        
        assertTrue("Message should contain negative max actions", 
                  message.content.contains("-5"))
    }

    @Test
    fun `test SystemPrompt multiple instances`() {
        val systemPrompt1 = SystemPrompt("action1, action2")
        val systemPrompt2 = SystemPrompt("action3, action4")
        
        val message1 = systemPrompt1.getSystemMessage()
        val message2 = systemPrompt2.getSystemMessage()
        
        assertNotEquals("Different instances should have different messages", 
                       message1.content, message2.content)
        assertTrue("First message should contain first actions", 
                  message1.content.contains("action1, action2"))
        assertTrue("Second message should contain second actions", 
                  message2.content.contains("action3, action4"))
    }

    private fun cleanupTestFiles() {
        // Clean up any test files that might have been created
        val testFile = File("test_system_prompt.md")
        if (testFile.exists()) {
            testFile.delete()
        }
    }
}



================================================
FILE: app/src/test/java/com/blurr/voice/utilities/PandaStateManagerTest.kt
================================================
package com.blurr.voice.utilities

import android.content.Context
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.junit.MockitoJUnitRunner
import org.junit.Assert.*

@RunWith(MockitoJUnitRunner::class)
class PandaStateManagerTest {

    @Mock
    private lateinit var mockContext: Context

    private lateinit var stateManager: PandaStateManager

    @Before
    fun setUp() {
        // Note: In a real test environment, we would need to properly mock the dependencies
        // For now, this is a basic structure to verify the classes compile correctly
    }

    @Test
    fun testPandaStateEnum() {
        // Test that all required states exist
        val states = PandaState.values()
        
        assertTrue("IDLE state should exist", states.contains(PandaState.IDLE))
        assertTrue("LISTENING state should exist", states.contains(PandaState.LISTENING))
        assertTrue("PROCESSING state should exist", states.contains(PandaState.PROCESSING))
        assertTrue("SPEAKING state should exist", states.contains(PandaState.SPEAKING))
        assertTrue("ERROR state should exist", states.contains(PandaState.ERROR))
        
        // Verify we have exactly 5 states as required
        assertEquals("Should have exactly 5 states", 5, states.size)
    }

    @Test
    fun testStateColors() {
        // Test that state colors are defined correctly according to requirements
        // These colors should match the requirements:
        // IDLE: white, LISTENING: orange/amber, PROCESSING: blue, SPEAKING: green, ERROR: red
        
        // Note: In a real implementation, we would get these from the state manager
        // For now, just verify the color constants exist and are reasonable
        val whiteColor = 0xFFFFFFFF.toInt()
        val orangeColor = 0xFFFF9800.toInt()
        val blueColor = 0xFF2196F3.toInt()
        val greenColor = 0xFF4CAF50.toInt()
        val redColor = 0xFFF44336.toInt()
        
        // Basic sanity checks
        assertNotEquals("Colors should be different", whiteColor, orangeColor)
        assertNotEquals("Colors should be different", blueColor, greenColor)
        assertNotEquals("Colors should be different", greenColor, redColor)
    }
}


================================================
FILE: docs/ACCESSIBILITY_DISCLOSURE_IMPROVEMENTS.md
================================================
# Accessibility Services Disclosure Improvements

## Overview
This document outlines the improvements made to the accessibility services disclosure in the Panda app to ensure compliance with Google Play policies and provide users with comprehensive information about why and how accessibility services are used.

## Problem Statement
The original issue stated: "The prominent disclosure in your app must explain why your app requires use of the AccessibilityServices API, and how it's used. There is a disclosure present in the onboarding page, you must improve that disclosure."

## Changes Made

### 1. Enhanced Main Disclosure (`accessibility_permission_details`)

**Before:**
- Basic bullet points about seeing and interacting with screen
- Brief privacy mention
- Simple accessibility benefit statement

**After:**
- **Clear purpose explanation**: Why Panda needs accessibility services (AI assistant for voice control)
- **Detailed capabilities**: Comprehensive list of what the permission allows
- **Privacy emphasis**: Prominent section on data protection and local processing
- **Accessibility benefits**: Specific mention of disability support and mobility limitations
- **Explicit consent**: Clear statement requiring user understanding and consent
- **Visual improvements**: Added emojis for better readability and prominence

### 2. Improved Onboarding Description (`accessibility_permission_full_desc`)

**Before:**
```
This permission is required to read on-screen content and perform actions on your behalf.

This allows the app to automate tasks and provide voice commands for any app. We do not collect personal data.
```

**After:**
```
🤖 Panda is an AI assistant that needs accessibility services to control your phone through voice commands.

This permission allows Panda to:
• Read screen content to understand context
• Perform touches, swipes, and navigation
• Automate tasks across all apps

🔒 Your privacy is protected - all processing happens locally on your device.
```

### 3. Enhanced Service Description (`accessibility_service_description`)

**Before:**
```
To enable "Panda", our digital assistant, this service allows the app to listen for commands and perform actions like tapping and swiping. This is essential for controlling your phone with your voice.
```

**After:**
```
Panda AI Assistant uses accessibility services to provide voice-controlled device automation. This allows hands-free operation of your phone through AI-powered commands, making technology more accessible. The service reads screen content and performs actions only when actively requested by you.
```

### 4. Updated Consent Dialog (`accessibility_consent_title` & `accessibility_consent_message`)

**Before:**
- Generic "Accessibility Permission" title
- Basic explanation of settings activation

**After:**
- **Prominent title**: "🤖 Accessibility Services Required"
- **Clear purpose**: Explains AI assistant functionality
- **Benefits highlight**: Voice-controlled automation for accessibility
- **Privacy assurance**: Local processing emphasis

### 5. Main Permission Description (`accessibility_permission_desc`)

**Before:**
```
Panda needs this permission to see the elements on your screen and to perform actions like tapping and swiping on your behalf. This is the core permission that allows the agent to operate your phone.
```

**After:**
```
🤖 Enable Panda AI to control your phone through voice commands. This permission allows reading screen content and performing actions for hands-free device automation and improved accessibility.
```

## Visual Preview

![Improved Accessibility Disclosure](improved_accessibility_disclosure_preview.png)

The visual preview shows:
1. **Enhanced onboarding stepper** with clear AI assistant branding and accessibility focus
2. **Comprehensive consent dialog** with structured sections, visual prominence, and detailed information

## Key Improvements Summary

1. **Prominence**: Added visual elements (emojis) and structured formatting for better visibility
2. **Clarity**: Clear explanation of purpose (AI assistant for voice control)
3. **Comprehensive**: Detailed breakdown of specific capabilities and use cases
4. **Privacy-focused**: Prominent privacy section emphasizing local processing
5. **Accessibility-centered**: Clear benefits for users with disabilities
6. **Consent-explicit**: Direct statement requiring user understanding and consent
7. **Purpose-driven**: Links all capabilities back to the core AI assistant functionality

## Compliance Benefits

These improvements address Google Play policy requirements by:

- **Explaining WHY**: Clear explanation that Panda is an AI assistant requiring these permissions for voice control
- **Detailing HOW**: Specific breakdown of reading screen content and performing actions
- **Emphasizing Benefits**: Accessibility improvements for users with disabilities
- **Ensuring Privacy**: Clear statements about local processing and data protection
- **Requiring Consent**: Explicit user acknowledgment and consent

## Files Modified

- `app/src/main/res/values/strings.xml`: Updated all accessibility-related string resources

## Implementation Details

The improved disclosure appears in multiple places throughout the app:

1. **Onboarding Stepper**: Short, clear description with AI assistant branding
2. **Consent Dialog**: Comprehensive disclosure with structured sections
3. **System Settings**: Enhanced service description for Android accessibility settings
4. **Permission Requests**: Updated descriptions for all accessibility-related permissions

All changes maintain consistency in messaging while providing the appropriate level of detail for each context.


================================================
FILE: docs/AUTOMATED_VERSION_MANAGEMENT.md
================================================
# Automated Version Management

This document explains the automated version management system implemented for the Blurr Android app.

## Overview

The app now automatically increments version numbers **only for release builds**, not debug builds. This eliminates the need to manually update version codes and names before each release.

## How It Works

### Files Involved

1. **`version.properties`** - Stores current version numbers
2. **`app/build.gradle.kts`** - Modified to read versions from properties file and includes auto-increment task

### Version Storage

The `version.properties` file contains:
```properties
VERSION_CODE=13           # Integer that increments by 1 each release
VERSION_NAME=1.0.13      # Semantic version (x.y.z) - patch number increments
```

### Auto-Increment Logic

- **Version Code**: Increments by 1 (13 → 14 → 15...)
- **Version Name**: Increments patch version (1.0.13 → 1.0.14 → 1.0.15...)

### Build Behavior

| Build Type | Version Increment | Command |
|------------|------------------|---------|
| **Debug** | ❌ No increment | `./gradlew assembleDebug` |
| **Release** | ✅ Auto increment | `./gradlew assembleRelease` |
| **Release Bundle** | ✅ Auto increment | `./gradlew bundleRelease` |

## Usage

### Building Debug (No Version Change)
```bash
./gradlew assembleDebug
# Version stays the same - no increment
```

### Building Release (Auto Increment)
```bash
./gradlew assembleRelease
# Automatically increments version before building
# Updates version.properties file
```

### Manual Version Increment (if needed)
```bash
./gradlew incrementVersion
# Manually increment version without building
```

## What Changed

### Before
```kotlin
defaultConfig {
    versionCode = 13
    versionName = "1.0.13"
}
```

### After
```kotlin
defaultConfig {
    versionCode = versionProps.getProperty("VERSION_CODE", "13").toInt()
    versionName = versionProps.getProperty("VERSION_NAME", "1.0.13")
}
```

## Benefits

1. **No Manual Updates**: Version numbers update automatically for releases
2. **Debug Safety**: Debug builds don't change version numbers
3. **Git Trackable**: Version changes are committed with the release
4. **Semantic Versioning**: Follows standard x.y.z pattern
5. **Rollback Safe**: Can manually edit version.properties if needed

## Troubleshooting

### If Version Doesn't Increment
- Ensure you're running a release build (`assembleRelease` or `bundleRelease`)
- Check that `version.properties` file exists and is writable

### If Build Fails
- Verify `version.properties` has valid integer values
- Check that file permissions allow writing to `version.properties`

### Manual Reset
To manually set version numbers, edit `version.properties`:
```properties
VERSION_CODE=20
VERSION_NAME=1.1.0
```

## Technical Details

The implementation uses:
- Gradle task registration for `incrementVersion`
- Task dependencies to hook into release builds only
- Properties file I/O for persistent version storage
- Semantic versioning logic for automatic patch increments


================================================
FILE: docs/DIRECT_APP_OPENING.md
================================================
# Direct App Opening Feature

## Overview

The Direct App Opening feature allows the agent to open apps directly using the Android package manager, bypassing the traditional UI navigation. This feature is designed for debugging purposes and can significantly speed up app opening operations.

## ⚠️ Important Notes

- **Play Store Compliance**: This feature uses the `QUERY_ALL_PACKAGES` permission, which is restricted by Google Play Store policies. It should be disabled for production releases.
- **Debug Only**: This feature is intended for debugging and development purposes only.
- **Permission Required**: The app requires the `QUERY_ALL_PACKAGES` permission to function.

## How It Works

1. **Traditional Method**: The agent searches for app icons/text on the screen and taps them
2. **Direct Method**: The agent uses the package manager to launch apps directly by package name

## Configuration

### Build Configuration

The feature is controlled by a build configuration flag in `app/build.gradle.kts`:

```kotlin
// For debug builds (development)
debug {
    buildConfigField("boolean", "ENABLE_DIRECT_APP_OPENING", "true")
}

// For release builds (production)
release {
    buildConfigField("boolean", "ENABLE_DIRECT_APP_OPENING", "false")
}
```

### Runtime Configuration

The feature is also controlled by the `AgentConfig.enableDirectAppOpening` flag:

```kotlin
val config = AgentConfigFactory.create(
    context = context,
    visionMode = visionMode,
    apiKey = apiKey,
    enableDirectAppOpening = BuildConfig.ENABLE_DIRECT_APP_OPENING
)
```

## Usage

When the feature is enabled, the agent can use the `Open_App` action:

```json
{
    "name": "Open_App",
    "arguments": {
        "app_name": "Chrome"
    }
}
```

The agent can also use the `Speak` action to communicate with the user:

```json
{
    "name": "Speak",
    "arguments": {
        "message": "I found the Chrome app and I'm opening it now."
    }
}
```

And the `Ask` action to get user input:

```json
{
    "name": "Ask",
    "arguments": {
        "question": "I found multiple apps with similar names. Which one do you want me to open?"
    }
}
```

## Implementation Details

### 1. AgentConfig Changes
- Added `enableDirectAppOpening` flag to control the feature
- Default value is `false` for safety

### 2. Finger Class Changes
- Added `openApp(packageName: String)` method
- Uses `PackageManager.getLaunchIntentForPackage()` to launch apps
- Includes proper error handling and logging

### 3. Operator Class Changes
- Updated `getAtomicActionSignatures()` to conditionally include `Open_App` action
- Enhanced `execute()` method to handle direct app opening
- Added fallback to traditional UI navigation if direct opening fails
- Added helper method `findPackageNameFromAppName()` to map app names to package names

### 4. Atomic Action Signatures
The `Open_App` action is only available when `enableDirectAppOpening` is `true`:

```kotlin
"Open_App" to AtomicActionSignature(
    listOf("app_name")
) { "Open the app named \"app_name\" directly using package manager. This is a debug feature that bypasses the traditional UI navigation." }
```

The `Speak` action is always available and allows the agent to communicate with the user:

```kotlin
"Speak" to AtomicActionSignature(
    listOf("message")
) { "Speak the \"message\" to the user. Use this when you need to communicate important information, provide status updates, or give instructions to the user. This message will be spoken on loud speaker, so dont say private information." }
```

The `Ask` action is always available and allows the agent to get user input:

```kotlin
"Ask" to AtomicActionSignature(
    listOf("question")
) { "Ask the \"question\" to the user and wait for their response. Use this when you need clarification, more information, or user input to proceed with the task. The user's response will be added to the instruction to help you complete the task." }
```

## Behavior

When the `enableDirectAppOpening` flag is enabled:
- The `Open_App` action becomes available to the agent
- The agent can directly open apps using package manager
- No fallback to traditional UI navigation is performed

When the flag is disabled:
- The `Open_App` action is completely unavailable
- The agent must use traditional UI navigation (Tap, Swipe, etc.) to open apps

The `Speak` action is always available regardless of any flags and allows the agent to communicate directly with the user.

The `Ask` action is always available and allows the agent to get user input and update the instruction accordingly.

## Error Handling

When the Open_App action is used:
- Missing app name: Prints "Missing app_name for Open_App action"
- Package name not found: Prints "Could not find package name for app"
- Launch failure: Prints "Failed to open app"

When the Open_App action is disabled:
- Action not available: The action is not included in the available actions list
- If somehow called: Prints "Open_App action is disabled"

When the Speak action is used:
- Missing message: Prints "Missing message for Speak action"
- Message will always be spoken using `speakToUser()` regardless of debug settings

When the Ask action is used:
- Missing question: Prints "Missing question for Ask action"
- Question will be spoken using `speakToUser()`
- User response will be captured and added to the instruction
- Instruction will be updated with both the question and response

## Security Considerations

- The `QUERY_ALL_PACKAGES` permission allows the app to see all installed packages
- This permission is restricted by Google Play Store for privacy reasons
- Only enable this feature for debugging and development builds
- Always set `ENABLE_DIRECT_APP_OPENING` to `false` for production releases

## Testing

To test the feature:

1. Set `ENABLE_DIRECT_APP_OPENING` to `true` in debug build
2. Give the agent an instruction like "Open Chrome"
3. The agent should use the `Open_App` action instead of searching for the Chrome icon

## Troubleshooting

- **Permission Denied**: Ensure `QUERY_ALL_PACKAGES` permission is granted
- **App Not Found**: Check if the app name matches exactly or try partial matches
- **Launch Failed**: Verify the app has a launch intent and is properly installed
- **Feature Not Working**: Check that `enableDirectAppOpening` is set to `true` in the configuration 


================================================
FILE: docs/INTERACTIVE_DIALOGUE_SYSTEM.md
================================================
# Interactive Dialogue System

## Overview
The Interactive Dialogue System enhances the Blurr app by automatically detecting unclear user instructions and asking clarifying questions before executing tasks. This ensures more accurate and effective task execution.

## Features

### Automatic Clarification Detection
- **Instruction Analysis**: AI analyzes user instructions for clarity
- **Smart Question Generation**: Automatically generates relevant clarifying questions
- **Context-Aware**: Considers the type of task and required information

### Interactive Dialogue Interface
- **Modal Interface**: Clean, focused dialogue screen
- **Progress Tracking**: Shows question progress (e.g., "2 of 3")
- **Dual Input Methods**: Both text and voice input support
- **TTS Integration**: Questions are spoken aloud for accessibility

### Seamless Integration
- **Automatic Flow**: No manual intervention required
- **Enhanced Instructions**: Answers are automatically added to the original instruction
- **Error Handling**: Graceful handling of cancellations and errors

## How It Works

### 1. Instruction Analysis
When a user provides an instruction (via voice or text), the system:
1. Analyzes the instruction using the `ClarificationAgent`
2. Determines if additional information is needed
3. Generates specific clarifying questions if required

### 2. Clarification Process
If clarification is needed:
1. **Dialogue Launch**: Opens the `DialogueActivity`
2. **Question Presentation**: Shows questions one by one
3. **User Response**: User can answer via text or voice
4. **Progress Tracking**: Shows current question number
5. **Enhanced Instruction**: Combines original instruction with answers

### 3. Task Execution
After clarification:
1. **Enhanced Instruction**: Original instruction + clarification answers
2. **Automatic Execution**: Task is executed with complete information
3. **TTS Feedback**: Results are announced via text-to-speech

## Example Scenarios

### Scenario 1: Messaging Task
**User Input**: "Message my brother happy birthday"

**System Analysis**: Needs clarification
- Missing: Brother's name in contacts
- Missing: Preferred messaging app

**Clarification Questions**:
1. "What is the name of your brother saved in the phone?"
2. "Which messaging app would you prefer to use?"

**Enhanced Instruction**:
```
Message my brother happy birthday

Additional information:
- What is the name of your brother saved in the phone?: John Smith
- Which messaging app would you prefer to use?: WhatsApp
```

### Scenario 2: Clear Instruction
**User Input**: "Open WhatsApp"

**System Analysis**: Clear instruction
- No clarification needed
- Task executed directly

## Technical Implementation

### Key Components

#### ClarificationAgent
- **Purpose**: Analyzes instructions and generates clarifying questions
- **Input**: User instruction
- **Output**: Status (CLEAR/NEEDS_CLARIFICATION) and questions list

#### DialogueActivity
- **Purpose**: Handles the interactive clarification process
- **Features**: 
  - Question display
  - Voice and text input
  - Progress tracking
  - TTS integration

#### MainActivity Integration
- **Clarification Check**: Automatically checks if clarification is needed
- **Dialogue Launch**: Seamlessly launches dialogue when required
- **Enhanced Execution**: Executes tasks with complete information

### File Structure
```
app/src/main/java/com/example/blurr/
├── agent/
│   └── ClarificationAgent.kt          # Instruction analysis
├── DialogueActivity.kt                # Dialogue interface
├── MainActivity.kt                    # Integration logic
└── res/
    ├── layout/
    │   └── activity_dialogue.xml      # Dialogue UI
    └── values/
        └── strings.xml                # Dialogue strings
```

## User Experience Flow

### Voice Command Flow
1. **User**: Presses and holds microphone button
2. **User**: Speaks instruction
3. **System**: Analyzes instruction
4. **If Clear**: Executes task directly
5. **If Unclear**: 
   - Announces "I need to ask some questions"
   - Opens dialogue interface
   - Asks questions one by one
   - User answers via voice or text
   - Executes enhanced task

### Text Input Flow
1. **User**: Types instruction in input field
2. **User**: Presses "Perform Task" button
3. **System**: Analyzes instruction
4. **If Clear**: Executes task directly
5. **If Unclear**: 
   - Opens dialogue interface
   - Asks questions one by one
   - User answers via voice or text
   - Executes enhanced task

## Benefits

### For Users
- **Better Accuracy**: Tasks are executed with complete information
- **Reduced Errors**: Fewer failed attempts due to unclear instructions
- **Natural Interaction**: Feels like talking to a helpful assistant
- **Accessibility**: Voice input and TTS support

### For System
- **Higher Success Rate**: More tasks completed successfully
- **Better User Satisfaction**: Users get what they intended
- **Reduced Frustration**: Fewer failed task attempts
- **Learning Capability**: Can improve over time with more examples

## Future Enhancements

### Potential Improvements
1. **Context Memory**: Remember user preferences from previous interactions
2. **Smart Defaults**: Suggest common answers based on user history
3. **Multi-turn Dialogue**: Handle complex multi-step clarifications
4. **Learning System**: Improve question generation based on user feedback
5. **Customization**: Allow users to set default preferences

### Advanced Features
1. **Predictive Questions**: Anticipate common clarification needs
2. **Contextual Awareness**: Consider current app state and recent actions
3. **Natural Language Understanding**: Better understanding of user intent
4. **Proactive Suggestions**: Suggest related tasks or optimizations 


================================================
FILE: docs/MEMORY_STATUS.md
================================================
# Memory System Status

## Current Status: Temporarily Disabled

⚠️ **Panda memory is turned off as of yet.**

The memory functionality in Panda has been temporarily disabled while we work on improvements and optimizations. This means:

## What's Affected

- **Conversational Memory**: Panda will not remember information from previous conversations
- **Personal Information Storage**: No personal details will be stored or recalled
- **Learning from Interactions**: Panda won't learn from your preferences or habits
- **Memory Management UI**: The memories screen will show a disabled state

## Why Is Memory Disabled?

The memory system is being temporarily disabled to:
- Ensure optimal performance during development
- Implement enhanced privacy and security measures
- Rebuild the memory architecture for better reliability
- Focus on core conversation and task execution features

## What Still Works

- **Voice Conversations**: Full conversational capabilities remain available
- **Task Execution**: All automation and device control features work normally
- **Screen Understanding**: Panda can still see and interact with your screen
- **Real-time Context**: Current screen context is still processed for each interaction

## When Will Memory Return?

Memory functionality will be restored in a future update. We're working to make it:
- More accurate and reliable
- Better at understanding context
- More respectful of your privacy
- Faster and more efficient

## Current Workarounds

While memory is disabled:
- Provide context in each conversation when needed
- Use specific names and details in your requests
- Remember that Panda won't recall previous interactions

---

*Last updated: December 2024*
*For questions about memory functionality, please check our Discord or GitHub issues.*


================================================
FILE: docs/PORCUPINE_SETUP.md
================================================
# Porcupine Wake Word Setup

This app now supports two wake word detection engines:

1. **STT Engine (Default)**: Uses Android's Speech-to-Text to listen for "Panda"
2. **Porcupine Engine**: Uses Picovoice's Porcupine library to listen for "Panda" (custom wake word)

## Setting up Porcupine Wake Word Detection

### 1. Automatic Key Management

The app now automatically fetches and manages Picovoice access keys from a secure API endpoint. The key is:
- Fetched automatically when needed
- Cached locally for 24 hours
- Only fetched when not present in local storage
- Handled transparently by the app

**No manual configuration required!** The app will automatically:
1. Fetch the access key from the secure API when Porcupine is first used
2. Cache the key locally for future use
3. Refresh the key automatically when it expires (24 hours)
4. Fall back to STT-based detection if the key cannot be obtained

### 2. Using the Wake Word Feature

1. Open the app
2. Select your preferred wake word engine:
   - **STT Engine**: Listens for "Panda" (works offline)
   - **Porcupine Engine**: Listens for "Panda" (more accurate, requires internet)
3. Tap "ENABLE WAKE WORD" to start listening
4. Say the wake word to activate the app

### 3. Custom Wake Words

The app is already configured to use a custom "Panda" wake word. The `Panda_en_android_v3_0_0.ppn` file is included in the assets folder.

To use different custom wake words:

1. Create a custom wake word in the [Picovoice Console](https://console.picovoice.ai/)
2. Download the `.ppn` file
3. Place it in `app/src/main/assets/`
4. Update the `PorcupineWakeWordDetector.kt` file to use the custom keyword path

Example:
```kotlin
porcupineManager = PorcupineManager.Builder()
    .setAccessKey(accessKey)
    .setKeywordPaths(arrayOf("your_custom_wake_word.ppn"))
    .build(context, wakeWordCallback)
```

### 4. Troubleshooting

- **Wake word not detected**: Check your microphone permissions
- **Service not starting**: Ensure you have the required permissions (RECORD_AUDIO, INTERNET)
- **Porcupine not working**: The app will automatically fall back to STT-based detection

#### App Crashes When Starting Wake Word Service

If the app crashes when you try to enable the wake word service:

1. **Check Permissions:**
   - Ensure microphone permission is granted
   - Check that internet permission is available

2. **Check Logs:**
   - Look for error messages containing "Porcupine" or "PicovoiceKeyManager"
   - The app will automatically fall back to STT-based detection if Porcupine fails

3. **Fallback Behavior:**
   - If Porcupine fails to initialize, the app will automatically use STT-based wake word detection
   - This ensures the wake word feature still works even if there are issues with the key fetching

4. **Manual Fallback:**
   - If you prefer to use STT-based detection, select "STT Engine" in the UI
   - This will use the built-in Android speech recognition for wake word detection

### 5. Built-in Wake Words

Porcupine supports several built-in wake words. You can change the wake word by modifying the `PorcupineWakeWordDetector.kt` file:

```kotlin
// Available built-in keywords:
// - Porcupine.BuiltInKeyword.PORCUPINE
// - Porcupine.BuiltInKeyword.BUMBLEBEE
// - Porcupine.BuiltInKeyword.PICOVOICE
// - And many more...

.setKeywords(arrayOf(Porcupine.BuiltInKeyword.BUMBLEBEE))
```

## Security Note

The Picovoice access key is now managed automatically by the app and is fetched from a secure API endpoint. The key is cached locally for performance but is not stored in version control or exposed in the app's configuration files. 


================================================
FILE: docs/SPEECH_COORDINATOR_IMPLEMENTATION.md
================================================
# Speech Coordinator Implementation

## Overview

The `SpeechCoordinator` class provides centralized coordination between Text-to-Speech (TTS) and Speech-to-Text (STT) operations to prevent them from running simultaneously. This ensures a better user experience by avoiding audio conflicts and providing a smooth, natural interaction flow.

## Problem Solved

### Before SpeechCoordinator
- TTS and STT could run simultaneously
- Users experienced audio conflicts and poor interaction quality
- No coordination between speech operations
- Potential for feedback loops and audio interference

### After SpeechCoordinator
- TTS and STT never run simultaneously
- Smooth, coordinated speech interactions
- Better user experience with clear turn-taking
- Proper resource management and cleanup

## Architecture

### Design Pattern
- **Singleton Pattern**: Ensures single instance across the app
- **Coordinator Pattern**: Manages interaction between multiple components
- **Mutex-based Synchronization**: Thread-safe coordination using Kotlin coroutines

### Key Components
1. **TTSManager Integration**: Uses existing TTSManager singleton
2. **STTManager Integration**: Creates and manages STTManager instances
3. **State Tracking**: Monitors speaking and listening states
4. **Mutex Locking**: Ensures exclusive access to speech operations

## Features

### 1. Coordinated Speech Operations
- **TTS Priority**: When TTS is speaking, STT waits for completion
- **STT Priority**: When STT is listening, TTS stops and waits
- **Automatic Coordination**: No manual coordination required

### 2. Smart Timing
- **TTS Duration Estimation**: Estimates speaking duration based on text length
- **Graceful Delays**: Appropriate pauses between operations
- **Timeout Handling**: Prevents infinite waiting

### 3. State Management
- **Real-time State Tracking**: Monitors current speech operations
- **State Queries**: Check if speaking, listening, or any speech active
- **Completion Waiting**: Wait for speech operations to complete

### 4. Error Handling
- **Graceful Degradation**: Handles failures without crashing
- **Resource Cleanup**: Proper cleanup on errors
- **Logging**: Comprehensive logging for debugging

## API Reference

### Core Methods

#### `speakText(text: String, forceSpeak: Boolean = false)`
Speaks text using TTS, ensuring STT is not listening.
```kotlin
// Normal speaking
speechCoordinator.speakText("Hello, how can I help you?")

// Force speaking (stops any ongoing listening)
speechCoordinator.speakText("Important message", forceSpeak = true)
```

#### `speakToUser(text: String, forceSpeak: Boolean = false)`
Speaks text to user (always spoken regardless of debug mode).
```kotlin
// Always speak to user
speechCoordinator.speakToUser("Please respond to my question")
```

#### `startListening(onResult, onError, onListeningStateChange, waitForTTS = true)`
Starts STT listening, ensuring TTS is not speaking.
```kotlin
speechCoordinator.startListening(
    onResult = { text -> println("Recognized: $text") },
    onError = { error -> println("Error: $error") },
    onListeningStateChange = { listening -> println("Listening: $listening") }
)
```

### Utility Methods

#### `stopListening()`
Stops any ongoing STT listening.
```kotlin
speechCoordinator.stopListening()
```

#### `isCurrentlySpeaking(): Boolean`
Checks if TTS is currently speaking.
```kotlin
if (speechCoordinator.isCurrentlySpeaking()) {
    println("TTS is active")
}
```

#### `isCurrentlyListening(): Boolean`
Checks if STT is currently listening.
```kotlin
if (speechCoordinator.isCurrentlyListening()) {
    println("STT is active")
}
```

#### `isSpeechActive(): Boolean`
Checks if any speech operation is in progress.
```kotlin
if (speechCoordinator.isSpeechActive()) {
    println("Speech operation in progress")
}
```

#### `waitForSpeechCompletion()`
Waits for any ongoing speech operations to complete.
```kotlin
speechCoordinator.waitForSpeechCompletion()
```

## Usage Examples

### 1. Basic Question-Answer Flow
```kotlin
// Ask a question
speechCoordinator.speakToUser("What is your name?")

// Listen for response
speechCoordinator.startListening(
    onResult = { name -> 
        println("User said: $name")
        speechCoordinator.speakToUser("Nice to meet you, $name")
    },
    onError = { error -> 
        println("Error: $error")
    },
    onListeningStateChange = { listening -> 
        println("Listening state: $listening")
    }
)
```

### 2. Agent Task Service Integration
```kotlin
// In AgentTaskService
val speechCoordinator = SpeechCoordinator.getInstance(this)

// Speak subgoal
speechCoordinator.speakText("Current subgoal: $subgoal")

// Later, when asking user questions
speechCoordinator.speakToUser("Please confirm this action")
```

### 3. User Input Manager Integration
```kotlin
// In UserInputManager
private val speechCoordinator = SpeechCoordinator.getInstance(context)

// Re-ask question between attempts
speechCoordinator.speakToUser("Please try again. $question")

// Start listening for response
speechCoordinator.startListening(
    onResult = { response -> /* handle response */ },
    onError = { error -> /* handle error */ },
    onListeningStateChange = { listening -> /* update UI */ }
)
```

## Integration Points

### 1. UserInputManager
- **Before**: Direct STTManager usage
- **After**: SpeechCoordinator for all speech operations
- **Benefits**: Automatic coordination, no conflicts

### 2. Operator (Agent Actions)
- **Before**: Direct TTSManager usage for "Speak" and "Ask" actions
- **After**: SpeechCoordinator for coordinated speech
- **Benefits**: Smooth agent-user interactions

### 3. AgentTaskService
- **Before**: Direct TTSManager usage for status updates
- **After**: SpeechCoordinator for all TTS operations
- **Benefits**: No interference with user input

### 4. WakeWordDetector
- **Note**: WakeWordDetector still uses STTManager directly
- **Reason**: Wake word detection needs to run continuously
- **Future**: Could be integrated with SpeechCoordinator for better coordination

## Configuration

### Timing Settings
```kotlin
// In SpeechCoordinator
private const val TTS_DELAY_AFTER_STT = 500L // ms
private const val STT_DELAY_AFTER_TTS = 500L // ms
private const val TTS_CHECK_INTERVAL = 100L // ms
```

### Duration Estimation
```kotlin
// Rough estimate: 100ms per character
val estimatedDuration = text.length * 100L
val minDuration = 1000L // Minimum 1 second
```

## Benefits

### 1. User Experience
- **No Audio Conflicts**: TTS and STT never overlap
- **Natural Flow**: Smooth turn-taking between system and user
- **Clear Communication**: Users always know when to speak

### 2. System Reliability
- **Thread Safety**: Mutex-based synchronization
- **Resource Management**: Proper cleanup and state tracking
- **Error Resilience**: Graceful handling of failures

### 3. Developer Experience
- **Simple API**: Easy to use coordination methods
- **Automatic Management**: No manual coordination required
- **Comprehensive Logging**: Easy debugging and monitoring

### 4. Performance
- **Efficient Coordination**: Minimal overhead for coordination
- **Smart Timing**: Appropriate delays without excessive waiting
- **Resource Optimization**: Proper cleanup prevents resource leaks

## Testing

### Test Scenarios
1. **TTS → STT Flow**: Verify TTS completes before STT starts
2. **STT → TTS Flow**: Verify STT stops before TTS starts
3. **Concurrent Requests**: Verify proper queuing and coordination
4. **Error Handling**: Verify graceful degradation on failures
5. **State Management**: Verify accurate state tracking

### Test Commands
```kotlin
// Test basic coordination
speechCoordinator.speakToUser("Test message")
speechCoordinator.startListening(/* callbacks */)

// Test state queries
assert(!speechCoordinator.isCurrentlySpeaking())
assert(speechCoordinator.isCurrentlyListening())

// Test completion waiting
speechCoordinator.waitForSpeechCompletion()
assert(!speechCoordinator.isSpeechActive())
```

## Future Enhancements

### 1. Advanced Coordination
- **Priority System**: Different priorities for different speech operations
- **Queue Management**: Queue multiple speech operations
- **Context Awareness**: Remember conversation context

### 2. Performance Optimizations
- **Better Duration Estimation**: More accurate TTS duration prediction
- **Adaptive Delays**: Dynamic delays based on device performance
- **Background Processing**: Non-blocking speech operations

### 3. Integration Improvements
- **Wake Word Integration**: Coordinate with wake word detection
- **Audio Session Management**: Better audio session handling
- **Multi-language Support**: Coordinate different language TTS/STT

### 4. Monitoring and Analytics
- **Usage Metrics**: Track speech operation patterns
- **Performance Monitoring**: Monitor coordination efficiency
- **User Feedback**: Collect user experience data 


================================================
FILE: docs/STT_IMPLEMENTATION.md
================================================
# Speech-to-Text (STT) Implementation

## Overview
This implementation adds voice command functionality to the Blurr app, allowing users to speak their instructions and have them automatically executed. The feature follows a press-and-hold pattern similar to popular voice assistants, with automatic task execution and TTS feedback.

## Features

### Press & Hold Voice Command
- **Press & Hold**: User presses and holds the microphone button
- **Record**: App starts recording audio from the microphone
- **Visual Feedback**: Button changes color and status text updates
- **Speak**: User speaks their instruction
- **Release**: User releases the button
- **Process**: App stops recording and processes the speech
- **Announce**: TTS announces the task being performed
- **Execute**: App automatically executes the task
- **Feedback**: Results are announced via TTS

## Implementation Details

### Files Added/Modified

#### New Files:
1. **`STTManager.kt`** - Core speech recognition manager
2. **`voice_input_button_bg.xml`** - Button background with press states
3. **`ic_mic.xml`** - Microphone icon (updated)

#### Modified Files:
1. **`MainActivity.kt`** - Added voice input integration
2. **`activity_main.xml`** - Added voice input UI components
3. **`strings.xml`** - Added voice input strings
4. **`AndroidManifest.xml`** - Added speech recognition permission

### Key Components

#### STTManager Class
- Handles Android's SpeechRecognizer API
- Manages recording states and callbacks
- Provides error handling and logging
- Supports press-and-hold functionality

#### UI Components
- **Voice Input Button**: Circular microphone button with press states
- **Status Text**: Shows current state ("Hold to Speak" / "Listening...")
- **Visual Feedback**: Button changes color when pressed

#### Permissions
- `RECORD_AUDIO` - Required for microphone access
- `RECOGNIZE_SPEECH` - Required for speech recognition

## Usage Flow

1. **User presses and holds** the microphone button
2. **Button turns red** and status shows "Listening..."
3. **User speaks** their instruction (e.g., "Add milk to my shopping list")
4. **User releases** the button
5. **App processes** the speech and converts to text
6. **TTS announces** the task being performed
7. **App automatically executes** the task without user intervention
8. **Results are announced** via TTS

## Error Handling

The implementation includes comprehensive error handling for:
- Speech recognition not available
- Microphone permission denied
- Network errors
- No speech detected
- Recognition timeouts
- Server errors

## Integration with Existing Features

The voice command seamlessly integrates with existing features:
- **Deep Search**: Voice commands work with the deep search functionality
- **Agent Tasks**: Voice instructions automatically trigger agent tasks
- **Vision Modes**: Voice commands work with both XML and Screenshot modes
- **TTS**: Provides automatic feedback and task announcements
- **Automatic Execution**: No manual button press required after voice input

## Technical Notes

- Uses Android's built-in SpeechRecognizer API
- Supports multiple languages (uses device default)
- Handles partial results for real-time feedback
- Properly manages lifecycle and cleanup
- Thread-safe UI updates using runOnUiThread

## Future Enhancements

Potential improvements could include:
- Real-time speech visualization
- Multiple language support
- Offline speech recognition
- Voice command shortcuts
- Custom wake words 


================================================
FILE: docs/STT_MULTIPLE_ATTEMPTS_UPDATE.md
================================================
# STT Multiple Attempts Feature

## Overview
Enhanced the `UserInputManager` to provide up to 3 speech recognition attempts when no speech is detected, improving user experience and reducing failed interactions.

## Problem
Previously, if speech recognition failed or no speech was detected, the system would immediately fall back to a simulated response. This could be frustrating for users who might need a second chance to provide their input.

## Solution
Implemented a retry mechanism that gives users multiple opportunities to provide speech input.

## Key Changes

### 1. UserInputManager.kt Updates

#### New Constants
```kotlin
private const val MAX_SPEECH_ATTEMPTS = 3 // Maximum number of speech recognition attempts
```

#### Enhanced Speech Recognition Logic
- **Multiple Attempts**: Up to 3 attempts for speech recognition
- **Re-asking**: The system re-asks the question between attempts
- **User Feedback**: Provides clear feedback about attempt progress
- **Graceful Degradation**: Falls back to simulated response only after all attempts fail

#### Attempt Flow
1. **First Attempt**: Initial speech recognition with 30-second timeout
2. **Subsequent Attempts**: 
   - 2-second delay for user preparation
   - Re-asks the question via TTS: "Please try again. [Original Question]"
   - 1-second pause after re-asking
   - Another 30-second speech recognition attempt
3. **Final Fallback**: If all 3 attempts fail, uses fallback response

### 2. Enhanced Logging
- Tracks attempt number in all log messages
- Provides detailed feedback about which attempt succeeded or failed
- Clear indication when all attempts are exhausted

### 3. User Experience Improvements
- **Clear Communication**: Users know they have multiple chances
- **Reduced Frustration**: No immediate failure on first attempt
- **Better Accessibility**: Accommodates users who may need time to respond
- **Natural Interaction**: Mimics human conversation patterns

## Configuration

### Timeout Settings
```kotlin
private const val SPEECH_TIMEOUT_MS = 30000L // 30 seconds per attempt
private const val FALLBACK_TIMEOUT_MS = 5000L // 5 seconds for fallback
private const val MAX_SPEECH_ATTEMPTS = 3 // Maximum attempts
```

### Timing
- **Per Attempt**: 30 seconds to speak
- **Between Attempts**: 2 seconds preparation time
- **Re-ask Delay**: 1 second after re-asking question
- **Total Maximum Time**: ~95 seconds (3 × 30s + 2 × 2s + 2 × 1s + 5s fallback)

## Usage Examples

### Successful First Attempt
```
Agent: "What is your name?"
User: "John" (speaks immediately)
Result: "John" (recognized on first attempt)
```

### Successful Second Attempt
```
Agent: "What is your name?"
User: (remains silent for 30s)
Agent: "Please try again. What is your name?"
User: "John" (speaks on second attempt)
Result: "John" (recognized on second attempt)
```

### All Attempts Failed
```
Agent: "What is your name?"
User: (remains silent for all 3 attempts)
Result: "User provided fallback response after 3 failed speech recognition attempts for: What is your name?"
```

## Benefits

1. **Improved Success Rate**: Multiple attempts increase the likelihood of successful speech recognition
2. **Better User Experience**: Users feel more supported and less frustrated
3. **Accessibility**: Accommodates users with speech difficulties or environmental challenges
4. **Robustness**: Handles temporary issues like background noise or network problems
5. **Natural Interaction**: More closely mimics human conversation patterns

## Testing Scenarios

1. **Immediate Response**: User speaks on first attempt
2. **Delayed Response**: User speaks on second or third attempt
3. **No Response**: User remains silent for all attempts
4. **Partial Recognition**: Some attempts partially recognize speech
5. **Network Issues**: Intermittent connectivity problems

## Integration

The feature integrates seamlessly with existing code:
- **Operator.kt**: No changes needed, uses existing `askQuestion()` method
- **AgentTaskService**: No changes needed, works with existing agent flow
- **TTSManager**: Uses existing `speakToUser()` method for re-asking
- **STTManager**: No changes needed, handles individual recognition attempts

## Future Enhancements

1. **Configurable Attempts**: Make number of attempts configurable per question
2. **Adaptive Timeouts**: Adjust timeout based on question complexity
3. **Voice Activity Detection**: Better detection of when user is about to speak
4. **Context Awareness**: Remember previous successful patterns for similar questions
5. **User Preferences**: Allow users to set their preferred number of attempts 


================================================
FILE: docs/STT_THREAD_SAFETY_FIX.md
================================================
# STT Thread Safety Fix

## Problem
The `STTManager` was crashing with the error:
```
SpeechRecognizer should be used only from the application's main thread
```

This occurred because `SpeechRecognizer.createSpeechRecognizer()` was being called from a background thread (IO dispatcher) in the `AgentTaskService`.

## Root Cause
- `UserInputManager` was being instantiated from `AgentTaskService.runAgentLogic()` which runs on `Dispatchers.IO`
- `UserInputManager` constructor creates an `STTManager` instance
- `STTManager` constructor immediately calls `initializeSpeechRecognizer()` which calls `SpeechRecognizer.createSpeechRecognizer()`
- `SpeechRecognizer` APIs must be called from the main thread

## Solution
Modified `STTManager` to use lazy initialization on the main thread:

### Changes Made:

1. **Removed constructor initialization**: The `SpeechRecognizer` is no longer created in the constructor
2. **Added lazy initialization**: `initializeSpeechRecognizer()` is now called only when `startListening()` is invoked
3. **Main thread enforcement**: All `SpeechRecognizer` operations are now performed on the main thread using `CoroutineScope(Dispatchers.Main)`
4. **Error handling**: Added proper exception handling for initialization failures
5. **State tracking**: Added `isInitialized` flag to prevent multiple initialization attempts

### Key Changes in STTManager.kt:

```kotlin
// Before: Immediate initialization in constructor
init {
    initializeSpeechRecognizer()
}

// After: Lazy initialization on main thread
fun startListening(...) {
    CoroutineScope(Dispatchers.Main).launch {
        initializeSpeechRecognizer()
        // ... rest of listening logic
    }
}
```

## Benefits
- **Thread safety**: All `SpeechRecognizer` operations now happen on the main thread
- **Lazy loading**: Resources are only allocated when actually needed
- **Error resilience**: Better error handling for initialization failures
- **Backward compatibility**: Existing code continues to work without changes

## Testing
The fix ensures that:
1. `UserInputManager` can be created from any thread
2. `STTManager` initialization happens safely on the main thread
3. Speech recognition works properly in the agent system
4. No crashes occur when using the "Ask" atomic action

## Usage
No changes required in calling code. The `UserInputManager` and `STTManager` APIs remain the same, but now work correctly from any thread. 


================================================
FILE: docs/STT_USER_INPUT_IMPLEMENTATION.md
================================================
# STT User Input Implementation

## Overview

The `UserInputManager` class has been updated to use Speech-to-Text (STT) for handling user responses to agent questions. This implementation provides a more natural interaction method for users to communicate with the AI agent.

## Features

### 1. Speech Recognition Integration
- Uses Android's built-in `SpeechRecognizer` API
- Integrates with the existing `STTManager` class
- Supports real-time speech recognition with timeout handling
- **Multiple Attempts**: Up to 3 speech recognition attempts if no speech is detected

### 2. Robust Error Handling
- Checks if speech recognition is available on the device
- Provides fallback responses when all STT attempts fail
- Handles network errors, timeouts, and recognition failures gracefully
- Re-asks the question between attempts for better user experience

### 3. Timeout Management
- **Speech Timeout**: 30 seconds per attempt for speech input
- **Fallback Timeout**: 5 seconds for fallback response
- **Attempt Delay**: 2-second delay between attempts
- Automatic cleanup of resources

## How It Works

### 1. Question Flow
```kotlin
// Agent asks a question
val userResponse = userInputManager.askQuestion("What is your name?")
```

### 2. Speech Recognition Process
1. **Availability Check**: Verifies if speech recognition is available
2. **Multiple Attempts**: Up to 3 attempts for speech recognition
3. **Start Listening**: Activates microphone and starts recognition
4. **Timeout Handling**: Waits up to 30 seconds per attempt for user speech
5. **Re-ask Question**: Re-asks the question between attempts if needed
6. **Result Processing**: Processes recognized text or handles errors
7. **Fallback**: Uses fallback response if all STT attempts fail

### 3. Response Handling
- **Success**: Returns the recognized speech text
- **Failure**: Returns a fallback response
- **Error**: Logs errors and provides graceful degradation

## Usage in Agent Actions

The `Ask` atomic action in the `Operator` class uses this implementation:

```kotlin
"ask" -> {
    val question = args["question"]?.toString()?.trim()
    if (question != null) {
        // Speak the question to the user
        ttsManager.speakToUser(question)
        
        // Get user response using STT
        val userInputManager = UserInputManager(context)
        val userResponse = userInputManager.askQuestion(question)
        
        // Update the instruction with the user's response
        val updatedInstruction = "${infoPool.instruction}\n\n[Agent asked: $question]\n[User responded: $userResponse]"
        infoPool.instruction = updatedInstruction
    }
}
```

## Permissions Required

The following permissions are already included in `AndroidManifest.xml`:
- `RECORD_AUDIO`: For microphone access
- `RECOGNIZE_SPEECH`: For speech recognition functionality

## Error Scenarios and Handling

### 1. Speech Recognition Not Available
- **Cause**: Device doesn't support speech recognition
- **Handling**: Uses fallback response immediately
- **User Experience**: Seamless degradation

### 2. Network Errors
- **Cause**: No internet connection or server issues
- **Handling**: Falls back to simulated response
- **User Experience**: Continues operation

### 3. Timeout
- **Cause**: User doesn't speak within 30 seconds across all 3 attempts
- **Handling**: Uses fallback response after all attempts fail
- **User Experience**: Multiple chances to provide input, no hanging or freezing

### 4. Recognition Errors
- **Cause**: Poor audio quality, background noise, etc.
- **Handling**: Attempts recognition, falls back if needed
- **User Experience**: Graceful error handling

## Configuration

### Timeout Settings
```kotlin
private const val SPEECH_TIMEOUT_MS = 30000L // 30 seconds per attempt
private const val FALLBACK_TIMEOUT_MS = 5000L // 5 seconds
private const val MAX_SPEECH_ATTEMPTS = 3 // Maximum number of attempts
```

### Language Settings
Currently uses the device's default locale. Can be customized in `STTManager` if needed.

## Testing

To test the implementation:

1. **Normal Flow**: Ask a question and speak a response
2. **Multiple Attempts Test**: Ask a question, remain silent for first attempt, then speak on second attempt
3. **Timeout Test**: Ask a question and remain silent for all 3 attempts
4. **Error Test**: Test on devices without speech recognition
5. **Network Test**: Test with poor network conditions

## Future Enhancements

1. **Multiple Language Support**: Add language selection options
2. **Voice Activity Detection**: Improve speech detection accuracy
3. **Custom Wake Words**: Integrate with existing wake word detection
4. **Offline Recognition**: Add offline speech recognition capabilities
5. **Response Validation**: Add validation for user responses

## Integration with Existing Code

The implementation is designed to work seamlessly with:
- **TTSManager**: For speaking questions to users
- **AgentTaskService**: For running agent tasks
- **Operator**: For executing atomic actions
- **InfoPool**: For updating agent context with user responses

## Debugging

Enable debug logging to monitor the speech recognition process:
```kotlin
Log.d(TAG, "Speech recognized: $recognizedText")
Log.e(TAG, "Speech recognition error: $errorMessage")
Log.w(TAG, "Speech recognition failed or timed out, using fallback")
``` 


================================================
FILE: docs/TRIGGER_SYSTEM.md
================================================
# Trigger System

## Overview
The Trigger System allows Panda to be initiated from various entry points, enabling proactive and automated task execution. Instead of waiting for a direct voice command, users can configure triggers, such as a specific time of day or an incoming notification from another app, to launch a Panda task. This infrastructure is designed to be flexible and extensible for future trigger types.

## Features

### Multiple Trigger Types
- **Scheduled Time**: Execute tasks at a precise time. Supports day-of-the-week selection (e.g., only on weekdays).
- **Notification**: Execute tasks when a notification is received from a user-specified application.

### Robust Scheduling
- **Exact Alarms**: Uses Android's `setExactAndAllowWhileIdle` to ensure time-based triggers fire precisely when scheduled, even in low-power modes.
- **Persistent Scheduling**: A `BootReceiver` automatically reschedules all active alarms after the device reboots, ensuring no triggers are missed.

### Seamless Integration
- **Direct Task Execution**: Triggers directly invoke the `AgentService` to perform tasks without needing to go through the conversational UI.
- **Centralized Management**: A `TriggerManager` handles all trigger-related logic, including creation, storage, and scheduling.

### User-Friendly UI
- **Intuitive Flow**: A dedicated screen allows users to choose the type of trigger they want to create from a list of cards.
- **Easy Configuration**: Simple UI for setting the time, selecting days of the week, or choosing an application to monitor.
- **Unified List**: A single screen to view, enable/disable, and delete all configured triggers.
- **Permission Handling**: The UI includes dialogs to guide the user in granting the necessary special permissions for exact alarms and notification listening.

## How It Works

### 1. Trigger Creation
1.  The user navigates to the "Triggers" screen from `MainActivity`.
2.  Tapping the "+" button opens `ChooseTriggerTypeActivity`, where the user selects the trigger type (e.g., "Scheduled Time").
3.  This opens `CreateTriggerActivity`, which displays the relevant configuration options.
  *   For a **Scheduled Time** trigger, the user sets a time and selects the days of the week.
  *   For a **Notification** trigger, the user selects an application from a list of installed apps.
4.  The user provides the task instruction (e.g., "send a good morning text to Mom").
5.  Upon saving, the new `Trigger` object is passed to the `TriggerManager`.

### 2. Trigger Management
- The `TriggerManager` saves the trigger configuration to `SharedPreferences` (as a JSON string).
- If it's a scheduled trigger, the `TriggerManager` uses the `AlarmManager` to schedule a one-time exact alarm for the next valid trigger time.
- If it's a notification trigger, no alarm is scheduled. The `PandaNotificationListenerService` is responsible for monitoring it.

### 3. Trigger Execution
#### For Scheduled Triggers:
1.  The `AlarmManager` fires a `PendingIntent` at the scheduled time.
2.  The `Intent` is received by the `TriggerReceiver`.
3.  The `TriggerReceiver` starts the `AgentService`, passing the task instruction.
4.  It then immediately calls the `TriggerManager` to reschedule the alarm for the next valid day.

#### For Notification Triggers:
1.  The `PandaNotificationListenerService` is constantly running in the background (once enabled by the user).
2.  When a notification is posted by any app, the service's `onNotificationPosted` method is called.
3.  The service checks if the notification's source package name matches any enabled notification triggers stored in the `TriggerManager`.
4.  If a match is found, it fires an `Intent` to the `TriggerReceiver`.
5.  The `TriggerReceiver` starts the `AgentService` with the corresponding task instruction.

## Technical Implementation

### Key Components

#### `Trigger` (data class)
- **Purpose**: A flexible data class to hold the configuration for any trigger type.
- **Key Fields**: `id`, `type` (enum: `SCHEDULED_TIME`, `NOTIFICATION`), `instruction`, `isEnabled`, and nullable fields for type-specific data (`hour`, `minute`, `daysOfWeek`, `packageName`, `appName`).

#### `TriggerManager` (singleton)
- **Purpose**: The central brain for all trigger-related logic.
- **Responsibilities**:
  - CRUD operations (add, remove, update, get) for triggers.
  - Persistence using `SharedPreferences` and `Gson`.
  - Scheduling and canceling exact alarms via `AlarmManager`.
  - Calculating the next valid trigger time for scheduled alarms based on selected days.

#### `TriggerReceiver` (BroadcastReceiver)
- **Purpose**: A single entry point for all trigger events.
- **Responsibilities**:
  - Receives `Intent` broadcasts from both `AlarmManager` and `PandaNotificationListenerService`.
  - Extracts the task instruction.
  - Starts the `v2.AgentService` to execute the task.
  - Calls back to the `TriggerManager` to reschedule a time-based alarm after it has fired.

#### `BootReceiver` (BroadcastReceiver)
- **Purpose**: Ensures scheduled triggers persist across device reboots.
- **Responsibilities**:
  - Listens for the `ACTION_BOOT_COMPLETED` system broadcast.
  - Calls the `TriggerManager` to reschedule all active, time-based triggers.

#### `PandaNotificationListenerService` (NotificationListenerService)
- **Purpose**: Listens for system-wide notifications.
- **Responsibilities**:
  - Compares the package name of incoming notifications against stored notification triggers.
  - Broadcasts an `Intent` to the `TriggerReceiver` when a match is found.

#### UI Activities
- **`TriggersActivity`**: Displays a list of all configured triggers. Handles enabling/disabling and deleting triggers.
- **`ChooseTriggerTypeActivity`**: A new screen that provides a card-based UI for selecting a trigger type.
- **`CreateTriggerActivity`**: A dynamic screen that shows the correct configuration UI based on the type chosen in the previous step.

### File Structure
```
app/src/main/java/com/blurr/voice/triggers/
├── ui/
│   ├── AppAdapter.kt
│   ├── AppInfo.kt
│   ├── ChooseTriggerTypeActivity.kt
│   ├── CreateTriggerActivity.kt
│   ├── TriggerAdapter.kt
│   └── TriggersActivity.kt
├── BootReceiver.kt
├── PandaNotificationListenerService.kt
├── PermissionUtils.kt
├── Trigger.kt
├── TriggerManager.kt
└── TriggerReceiver.kt

app/src/main/res/
├── layout/
│   ├── activity_choose_trigger_type.xml
│   ├── activity_create_trigger.xml
│   ├── activity_triggers.xml
│   ├── item_app.xml
│   └── item_trigger.xml
└── ...
```

### Permissions
- `android.permission.RECEIVE_BOOT_COMPLETED`: Required for the `BootReceiver` to function.
- `android.permission.SCHEDULE_EXACT_ALARM`: Required to schedule precise alarms on modern Android versions.
- `android.permission.BIND_NOTIFICATION_LISTENER_SERVICE`: Required for the `PandaNotificationListenerService` to read notifications. This permission must be granted manually by the user in system settings.



================================================
FILE: docs/TTS_DEBUG_MODE.md
================================================
# TTS Debug Mode Feature

## Overview

The TTS (Text-to-Speech) Debug Mode feature allows you to control when TTS output is active. This is useful for debugging purposes where you want to hear TTS feedback during development but disable it in production or when you don't need it.

## How It Works

The TTSManager automatically detects if the app is running in debug mode using `BuildConfig.DEBUG`:

- **Debug Builds**: TTS is enabled by default
- **Release Builds**: TTS is disabled by default

## Behavior

### When Debug Mode is Enabled (Default in Debug Builds)
- All `speakText()` calls will actually speak the text
- Console logs show: `"TTS: Speaking 'your text here'"`
- TTS initialization log shows: `"TTS Singleton is ready with Audio Session ID: X (Debug Mode: true)"`

### When Debug Mode is Disabled (Default in Release Builds)
- All `speakText()` calls are silently ignored
- Console logs show: `"TTS: Skipping speech in release mode - 'your text here'"`
- TTS initialization log shows: `"TTS Singleton is ready with Audio Session ID: X (Debug Mode: false)"`

## Usage

### Automatic Mode (Recommended)
The TTSManager automatically uses the build configuration:

```kotlin
// This will speak only in debug builds
ttsManager.speakText("Hello World")
```

### User-Facing Messages (Always Spoken)
For important messages that should always be spoken to the user:

```kotlin
// This will always speak regardless of debug mode
ttsManager.speakToUser("Task completed successfully")
```

### Manual Override
You can manually control the debug mode at runtime:

```kotlin
val ttsManager = TTSManager.getInstance(context)

// Disable TTS even in debug builds
ttsManager.setDebugMode(false)

// Enable TTS even in release builds
ttsManager.setDebugMode(true)

// Check current status
val isEnabled = ttsManager.isDebugModeEnabled()
```

## Implementation Details

### TTSManager Changes
- Added `isDebugMode` property that reads from `BuildConfig.SPEAK_INSTRUCTIONS`
- Modified `speakText()` method to check debug mode before speaking
- Added `speakToUser()` method that always speaks regardless of debug mode
- Added `setDebugMode()` method for manual override
- Added `isDebugModeEnabled()` method to check current status
- Enhanced logging to show debug mode status

### Fallback Behavior
If `BuildConfig.DEBUG` is not available (e.g., during development), the system defaults to `true` (enabled) for safety.

## Benefits

1. **Development**: Full TTS feedback during debugging
2. **Production**: No unwanted TTS output in release builds
3. **Flexibility**: Can be overridden at runtime if needed
4. **Performance**: Avoids unnecessary TTS processing in release mode
5. **User Experience**: No unexpected speech in production apps

## Example Scenarios

### Scenario 1: Development Debugging
```kotlin
// In debug builds, this will speak
ttsManager.speakText("Agent started to perform task...")
// Output: "TTS: Speaking 'Agent started to perform task...'"
```

### Scenario 2: Production Release
```kotlin
// In release builds, this will be ignored
ttsManager.speakText("Agent started to perform task...")
// Output: "TTS: Skipping speech in release mode - 'Agent started to perform task...'"
```

### Scenario 3: Manual Control
```kotlin
// Force disable TTS
ttsManager.setDebugMode(false)
ttsManager.speakText("This won't speak")
// Output: "TTS: Skipping speech in release mode - 'This won't speak'"

// Force enable TTS
ttsManager.setDebugMode(true)
ttsManager.speakText("This will speak")
// Output: "TTS: Speaking 'This will speak'"
```

### Scenario 4: User-Facing Messages
```kotlin
// This always speaks regardless of debug mode
ttsManager.speakToUser("Your task has been completed")
// Output: "TTS: Speaking to user - 'Your task has been completed'"

// Even with debug mode disabled
ttsManager.setDebugMode(false)
ttsManager.speakToUser("Important message for user")
// Output: "TTS: Speaking to user - 'Important message for user'"
```

## Migration

No code changes are required for existing TTS calls. The feature is backward compatible:

- Existing `speakText()` calls will automatically respect the debug mode
- No need to modify any existing code
- All TTS calls will work as before in debug builds
- All TTS calls will be silently ignored in release builds

## Troubleshooting

- **TTS not speaking in debug builds**: Check if `BuildConfig.DEBUG` is properly set
- **TTS speaking in release builds**: Verify the build configuration
- **Manual override not working**: Ensure you're calling `setDebugMode()` before `speakText()` 


================================================
FILE: docs/WAKE_WORD_BUTTON_RELOCATION.md
================================================
# Wake Word Button Relocation - Implementation Summary

## Issue #234: Move the enable wake word btn on the main activity to the settings, replacing it with the save key btn

### Changes Made

#### 1. MainActivity Changes
- **Removed**: "Enable Wake Word" button functionality
- **Added**: "Setup Wake Word" button that navigates to SettingsActivity
- **Updated**: Button click handler now navigates to settings instead of managing wake word service
- **Cleaned**: Removed wake word state management from main UI update loop

#### 2. SettingsActivity Changes
- **Added**: Complete wake word management section including:
  - Picovoice key input field
  - Save key functionality with validation
  - Link to Picovoice Console with mobile browser warning
  - Enable/Disable wake word button
  - Key validation before enabling wake word service

#### 3. User Flow Improvements
- **Before**: User had to enable wake word directly from main screen without key management
- **After**: User first sets up their key in settings, then can enable wake word
- **Validation**: App now prevents enabling wake word without a valid key
- **Error Handling**: Clear feedback when key is missing or when mobile browser issues occur

#### 4. Technical Implementation
- **Permission Launcher**: Moved to SettingsActivity for wake word microphone permissions
- **Key Management**: Integrated PicovoiceKeyManager for user-provided key storage
- **Dialog System**: Added informative popup for key requirements with Picovoice dashboard link
- **Mobile Compatibility**: Added specific handling for mobile browser limitations

### Screenshots
![UI Changes](wake-word-ui-changes.png)

### Testing
- Added unit test `WakeWordButtonRelocationTest.kt` to verify the new flow
- Manual testing plan documented for UI verification
- Error handling scenarios covered

### User Benefits
1. **Clearer Flow**: Key setup is now separate from wake word activation
2. **Better Error Handling**: Users get clear guidance when key is missing
3. **Mobile Friendly**: Warns about potential mobile browser issues with Picovoice dashboard
4. **Organized Settings**: All wake word configuration is now centralized in settings
5. **Validation**: Prevents enabling wake word without proper configuration

The implementation fully addresses the requirements from issue #234, improving the user experience while maintaining all existing functionality.


================================================
FILE: gradle/libs.versions.toml
================================================
[versions]
agp = "8.9.2"
coreKtxVersion = "1.17.0"
kotlin = "2.0.21"
ksp = "2.0.21-1.0.28"
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.9.0"
activityCompose = "1.10.1"
composeBom = "2024.09.00"
appcompat = "1.7.0"
generativeai = "0.9.0"
firebaseBom = "34.3.0"
playServicesAuth = "21.4.0"
playServicesBasement = "18.9.0"

[libraries]
androidx-core = { module = "androidx.core:core", version.ref = "coreKtxVersion" }
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-core-ktx-v1170 = { module = "androidx.core:core-ktx", version.ref = "coreKtxVersion" }
firebase-firestore = { module = "com.google.firebase:firebase-firestore" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
generativeai = { group = "com.google.ai.client.generativeai", name = "generativeai", version.ref = "generativeai" }
firebase-bom = { group = "com.google.firebase", name = "firebase-bom", version.ref = "firebaseBom" }
firebase-auth = { group = "com.google.firebase", name = "firebase-auth" } # Use the KTX version
play-services-auth = { group = "com.google.android.gms", name = "play-services-auth", version.ref = "playServicesAuth" }
play-services-basement = { module = "com.google.android.gms:play-services-basement", version.ref = "playServicesBasement" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }




================================================
FILE: gradle/wrapper/gradle-wrapper.properties
================================================
-#Wed Jun 04 04:33:39 IST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



================================================
FILE: .github/copilot-instructions.md
================================================
# Panda (Blurr) - AI Phone Operator Android App

Panda is an Android application written in Kotlin that serves as a proactive, on-device AI agent for Android. It uses accessibility services to understand and operate phone UI, supporting voice commands and AI-powered task automation.

Always reference these instructions first and fallback to search or bash commands only when you encounter unexpected information that does not match the info here.

## Working Effectively

### Version Management
- **Android Gradle Plugin (AGP)**: Version 8.9.2 is specified in `gradle/libs.versions.toml`
- **CRITICAL**: AGP version must remain 8.9.2 - this is the latest stable version
- **NEVER** change AGP version to 8.5.2 - this is an older, outdated version
- **NEVER** downgrade AGP version without explicit project requirements
- **ALWAYS** verify version compatibility before making changes to dependency versions
- Current AGP 8.9.2 is the latest stable version and should remain unchanged

### Prerequisites and Environment Setup
- **CRITICAL**: This project requires Android Studio (latest version) or Android command-line tools
- **CRITICAL**: Android SDK must be installed and accessible at `/usr/local/lib/android/sdk` or equivalent
- **CRITICAL**: Only builds on systems with proper Android development environment - will NOT build in basic Linux CI environments
- Target Android API 35, minimum SDK 24
- Requires JDK 11+ (OpenJDK 17 recommended)
- **CRITICAL**: Android Gradle Plugin (AGP) version is 8.9.2 (defined in `gradle/libs.versions.toml`) - DO NOT change this to 8.5.2 or downgrade to any older version

### Initial Setup Commands
1. **Install Android Studio or Android Command Line Tools**
   - Download from https://developer.android.com/studio
   - Ensure Android SDK is properly configured
   - Verify SDK path: `ls $ANDROID_SDK_ROOT` or `ls /usr/local/lib/android/sdk`

2. **Clone and configure API keys:**
   ```bash
   git clone https://github.com/Ayush0Chaudhary/blurr.git
   cd blurr
   cp local.properties.template local.properties
   ```

3. **Configure local.properties with real API keys:**
   ```properties
   sdk.dir=/path/to/your/android/sdk
   GEMINI_API_KEYS=your_comma_separated_gemini_keys
   PICOVOICE_ACCESS_KEY=your_picovoice_key
   TAVILY_API=your_tavily_api_key
   MEM0_API=your_mem0_api_key
   GOOGLE_TTS_API_KEY=your_google_tts_key
   GCLOUD_GATEWAY_PICOVOICE_KEY=your_gateway_key
   GCLOUD_GATEWAY_URL=your_gateway_url
   GCLOUD_PROXY_URL=your_proxy_url
   GCLOUD_PROXY_URL_KEY=your_proxy_key
   ```

### Build Commands
- **NEVER CANCEL builds** - Android builds can take 10-30 minutes on first run
- **ALWAYS use minimum 45-minute timeouts** for initial builds
- **Subsequent builds** typically take 3-8 minutes after dependencies cached

```bash
# Clean build (first time may take 20-30 minutes)
./gradlew clean build --no-daemon
# NEVER CANCEL - Set timeout to 60+ minutes

# Faster incremental build
./gradlew assembleDebug
# Takes 3-8 minutes typically

# Build specific variant
./gradlew assembleRelease
```

### Testing Commands
```bash
# Run unit tests (2-5 minutes)
./gradlew test --no-daemon
# NEVER CANCEL - Set timeout to 15+ minutes

# Run all tests including instrumented (requires emulator/device)
./gradlew connectedAndroidTest
# NEVER CANCEL - Set timeout to 30+ minutes

# Specific test classes
./gradlew test --tests="com.blurr.voice.agent.v2.SystemPromptTest"
```

### Development Workflow
```bash
# Install app to connected device/emulator
./gradlew installDebug

# Install and launch
./gradlew installDebug && adb shell am start -n com.blurr.voice/.MainActivity

# View live logs (useful for debugging)
adb logcat | grep GeminiApi
```

## Validation Requirements

### ALWAYS run these before committing changes:
1. **Build validation**: `./gradlew assembleDebug` (wait for completion - 3-8 minutes)
2. **Unit tests**: `./gradlew test` (wait for completion - 5-15 minutes)  
3. **Code inspection**: Review any lint warnings in Android Studio

### Manual Testing Requirements
When making changes to core functionality:
1. **Install on device**: Use `./gradlew installDebug`
2. **Grant accessibility permission**: Enable "Panda" in Settings > Accessibility
3. **Test voice commands**: Press microphone, speak a command
4. **Test task execution**: Verify AI agent can interact with UI
5. **Check TTS output**: Ensure voice feedback works correctly

## Project Structure

### Key Directories
```
app/src/main/java/com/blurr/voice/
├── agent/               # AI agent logic and prompts
├── api/                 # API integrations (Gemini, etc.)
├── services/            # Android services (AgentTaskService, etc.)
├── ui/                  # UI components and activities
├── v2/                  # Version 2 agent implementation
└── utils/               # Utility classes
```

### Important Files
- `app/src/main/java/com/blurr/voice/services/AgentTaskService.kt` - Core agent execution service
- `app/src/main/java/com/blurr/voice/api/GeminiApi.kt` - Gemini AI integration
- `app/src/main/java/com/blurr/voice/v2/llm/GeminiAPI.kt` - Enhanced Gemini API v2
- `app/src/main/AndroidManifest.xml` - App permissions and services
- `local.properties` - API keys and SDK configuration (never commit)
- `gradle/libs.versions.toml` - Dependency versions

### Documentation
Check `/docs` directory for detailed feature documentation:
- `INTERACTIVE_DIALOGUE_SYSTEM.md` - Clarification system
- `TTS_DEBUG_MODE.md` - Text-to-speech debugging
- `STT_IMPLEMENTATION.md` - Speech-to-text features

## Common Issues and Solutions

### Copilot Guidelines - DO NOT IGNORE
- **NEVER suggest changing AGP version from 8.9.2 to 8.5.2** - 8.5.2 is outdated
- **NEVER downgrade Android Gradle Plugin** without explicit requirements
- **ALWAYS maintain current dependency versions** unless security updates are needed
- **VERIFY compatibility** before suggesting version changes

### Build Failures
- **"Plugin not found" errors**: Ensure Android SDK is properly installed and gradle can access Google Maven
- **"API key missing" errors**: Verify all required keys are in `local.properties`
- **Memory issues**: Increase JVM heap in `gradle.properties`: `org.gradle.jvmargs=-Xmx4g`

### Runtime Issues
- **Accessibility service not working**: Must manually enable in Android Settings
- **Voice commands not responding**: Check microphone permissions and TTS configuration
- **API call failures**: Verify internet connectivity and API key validity

### Network Requirements
- Internet access required for AI API calls
- Google Maven repository access needed for builds
- Firebase services connectivity required

## Development Notes

### API Dependencies
This app integrates with multiple external services:
- **Gemini AI**: Core reasoning and language processing
- **Picovoice**: Wake word detection ("Hey Panda")  
- **Google Cloud TTS**: High-quality speech synthesis
- **Tavily**: Web search capabilities
- **Mem0**: Persistent memory system

### Performance Considerations
- Initial app launch may take 10-30 seconds on first run
- AI responses typically take 2-8 seconds depending on complexity
- Screenshot processing adds 1-3 seconds to task execution
- Multiple API keys improve response speed through load balancing

### Testing Notes
- Unit tests focus on prompt generation and agent logic
- Integration tests require Android emulator or physical device
- Manual testing essential for accessibility service functionality
- Real API keys required for full feature testing

## Emergency Procedures

### If Build System Breaks
1. `./gradlew clean` - Clear all build artifacts
2. Delete `.gradle` directory in user home: `rm -rf ~/.gradle`
3. Re-sync in Android Studio: File > Sync Project with Gradle Files
4. If still failing, check Android SDK installation and update

### If App Crashes on Device
1. Check logs: `adb logcat | grep -E "(FATAL|ERROR|AndroidRuntime)"`
2. Verify API keys are valid
3. Check device has sufficient storage (2GB+ recommended)
4. Ensure accessibility permission is granted

## Quick Reference

### Essential Commands
```bash
# Setup
cp local.properties.template local.properties
# Edit local.properties with real API keys

# Build (45+ min first time)
./gradlew assembleDebug

# Test (15+ min)  
./gradlew test

# Install to device
./gradlew installDebug

# View logs
adb logcat | grep GeminiApi
```

### Required API Services
- Gemini API: https://makersuite.google.com/app/apikey
- Picovoice: https://console.picovoice.ai/
- Google Cloud TTS: https://cloud.google.com/text-to-speech
- Tavily: https://tavily.com/
- Mem0: https://mem0.ai/

### File Locations
- Main source: `app/src/main/java/com/blurr/voice/`
- Tests: `app/src/test/java/com/blurr/voice/`
- Resources: `app/src/main/res/`
- Build config: `app/build.gradle.kts`
- Dependencies: `gradle/libs.versions.toml` (AGP version 8.9.2 - NEVER change to 8.5.2)


================================================
FILE: .kiro/specs/main-ui-redesign/design.md
================================================
# Design Document

## Overview

The main UI redesign transforms the Panda app's interface into a cleaner, more focused experience centered around a large delta (triangle) symbol that serves as the primary visual indicator of the app's state. The design removes clutter while maintaining essential functionality and adds a Pro upgrade banner for better monetization visibility.

## Architecture

### Current Structure Analysis
- **Base Navigation**: `activity_base_navigation.xml` provides the bottom navigation framework
- **Main Content**: `activity_main.xml` and `activity_main_content.xml` contain the current UI elements
- **Navigation**: Bottom navigation with 5 tabs (Triggers, Moments, Home/Triangle, Upgrade, Settings)

### New Structure
The redesign will modify the main content area while preserving the navigation framework and essential functionality.

## Components and Interfaces

### 1. Pro Upgrade Banner
**Location**: Top of the main screen
**Design**:
- Horizontal banner with subtle background (using existing `panel_background` color)
- Left-aligned text: "Get more with Panda Pro"
- Right-aligned "Upgrade" button with accent styling
- Height: 56dp for comfortable touch target
- Margins: 16dp horizontal, 8dp vertical

### 2. Central Delta Symbol
**Location**: Center of the main screen
**Design**:
- Large triangle outline (120dp x 120dp)
- Stroke width: 3dp
- State-based colors:
  - Idle: `#FFFFFF` (white)
  - Listening: `#FF9800` (orange/amber)
  - Processing: `#2196F3` (blue)
  - Error: `#F44336` (red)
- Positioned using center gravity in parent container
- Replaces current wave animation

### 3. Status Text
**Location**: Below the delta symbol
**Design**:
- Text like "Listening...", "Ready", "Processing"
- Color: `#FFFFFF`
- Size: 16sp
- Centered horizontally
- 24dp margin from delta symbol

### 4. Essential UI Elements (Preserved)
**Bottom Section**:
- "How to wake up Panda" link - positioned at bottom with existing styling
- Permission buttons - maintain current visibility logic
- Developer email link - keep existing position and styling
- Free tasks remaining text - maintain current styling and position

### 5. Removed Elements
- "Hey Panda here" text (`karan_textview_gradient`)
- "Assistant at your command" text (`subtitle_textview`)
- "Start Conversation" button (`startConversationButton`)
- "Setup Wake Word" button (`saveKeyButton`)

## Data Models

### State Management Integration
The delta symbol will integrate with the existing `ConversationalAgentService` and `SpeechCoordinator` to reflect real-time app status:

```kotlin
enum class PandaState {
    IDLE,           // App ready, no active conversation
    LISTENING,      // STT active, listening for user input
    PROCESSING,     // LLM processing user request
    SPEAKING,       // TTS active, Panda is speaking
    THINKING,       // Showing thinking indicator
    ERROR           // Error state (STT errors, service issues)
}

data class DeltaState(
    val state: PandaState,
    val color: Int,
    val statusText: String
)
```

### Service Integration Points
- **ConversationalAgentService.isRunning**: Determines if service is active
- **SpeechCoordinator.isListening**: Indicates STT listening state
- **SpeechCoordinator.isSpeaking**: Indicates TTS speaking state
- **VisualFeedbackManager.showThinkingIndicator()**: Processing state
- **STT/TTS error callbacks**: Error state triggers

### Color Mapping
```kotlin
object StateColors {
    const val IDLE = 0xFFFFFFFF        // White - ready state
    const val LISTENING = 0xFFFF9800   // Orange/Amber - listening
    const val PROCESSING = 0xFF2196F3  // Blue - thinking/processing
    const val SPEAKING = 0xFF4CAF50    // Green - speaking
    const val ERROR = 0xFFF44336       // Red - error state
}
```

## Layout Structure

### New Main Layout Hierarchy
```
RelativeLayout (root)
├── LinearLayout (pro_banner)
│   ├── TextView (banner_text)
│   └── Button (upgrade_button)
├── LinearLayout (center_content)
│   ├── ImageView (delta_symbol)
│   └── TextView (status_text)
├── ScrollView (bottom_content)
│   ├── TextView (wake_word_help_link)
│   ├── TextView (tasks_remaining_textview)
│   └── TextView (developer_email_link)
└── LinearLayout (permission_section)
    ├── TextView (permission_status)
    └── Button (manage_permissions)
```

## Error Handling

### State Transition Errors
- Invalid state transitions should default to IDLE state
- Color application failures should fall back to white (#FFFFFF)
- Missing status text should display "Ready"

### UI Rendering Errors
- Delta symbol rendering failures should show a fallback circle
- Banner visibility issues should gracefully hide the banner
- Permission section errors should maintain current error handling

## Testing Strategy

### Unit Tests
NO TEST

## Implementation Considerations

### Service Integration
- **State Monitoring**: Create a `PandaStateManager` that observes service states
- **Callback Integration**: Hook into existing STT/TTS callbacks for real-time updates
- **Service Lifecycle**: Handle service start/stop events for state transitions
- **Error Handling**: Monitor service errors and reflect in delta color

### Performance
- Use vector drawables for delta symbol to ensure crisp rendering
- Implement smooth color transitions using ValueAnimator (300ms duration)
- Minimize layout redraws during state changes
- Cache color values to avoid repeated calculations

### State Transition Logic
```kotlin
class PandaStateManager {
    fun updateState() {
        val newState = when {
            !ConversationalAgentService.isRunning -> PandaState.IDLE
            speechCoordinator.isSpeaking -> PandaState.SPEAKING
            speechCoordinator.isListening -> PandaState.LISTENING
            visualFeedbackManager.isThinkingIndicatorVisible -> PandaState.PROCESSING
            hasRecentError -> PandaState.ERROR
            else -> PandaState.IDLE
        }
        updateDeltaColor(newState)
    }
}
```

### Accessibility
- Add proper content descriptions for delta symbol states
- Ensure color changes are accompanied by text changes
- Maintain existing accessibility features for preserved elements
- Add haptic feedback for state changes

### Backward Compatibility
- Preserve existing navigation behavior
- Maintain current permission handling logic
- Keep existing settings and preferences intact
- Ensure existing service callbacks continue to work

## Visual Design Specifications

### Typography
- Banner text: 16sp, medium weight
- Status text: 16sp, regular weight
- Preserved elements: maintain current specifications

### Spacing
- Banner margins: 16dp horizontal, 8dp top
- Delta symbol: centered with 32dp margins
- Status text: 24dp below delta symbol
- Bottom elements: maintain current spacing

### Colors
- Background: existing `background_color` (#101010)
- Banner background: existing `panel_background` (#1C1C1E)
- Text colors: maintain existing white (#FFFFFF) and accent colors


================================================
FILE: .kiro/specs/main-ui-redesign/requirements.md
================================================
# Requirements Document

## Introduction

This feature redesigns the main interface of the Panda app to create a cleaner, more focused user experience. The redesign centers around a large delta (triangle) symbol that serves as the primary visual indicator of the app's state, while streamlining the UI by removing unnecessary elements and adding a Pro upgrade banner.

## Requirements

### Requirement 1

**User Story:** As a user, I want to see a large delta symbol in the center of the main screen that changes color based on the app's current state, so that I can quickly understand what the app is doing. Also dar a small delta symbol with black circle bg at the bottom that mimics the large delta. this should be drawn over other apps so that it is visible when the app closes. 

#### Acceptance Criteria

1. WHEN the app is in listening state THEN the delta symbol SHALL be displayed in orange/amber color
2. WHEN the app is in idle state THEN the delta symbol SHALL be displayed in a white color
3. WHEN the app is processing THEN the delta symbol SHALL be displayed in a green color
3. WHEN the app is speaking THEN the delta symbol SHALL be displayed in a blue color
5. The delta symbol SHALL be large and prominently positioned in the center of the screen
6. The delta symbol SHALL replace the current wave animation at the bottom
7. Right side of the delta symbol should be thicker than the other sides, like in a delta symbol


### Requirement 2

**User Story:** As a user, I want to see a Pro upgrade banner at the top of the screen, so that I can easily access premium features.

#### Acceptance Criteria

1. WHEN the user is on the main screen THEN a Pro upgrade banner SHALL be displayed at the top
2. The banner SHALL contain text like "Get more with Panda Pro" and an "Upgrade" button
3. WHEN the user taps the upgrade button THEN the app SHALL navigate to the Pro upgrade screen
4. The banner SHALL be visually distinct but not intrusive to the main interface
5. If the user is Pro, dont show this banner. 

### Requirement 3

**User Story:** As a user, I want to see only essential UI elements on the main screen, so that the interface is clean and focused.

#### Acceptance Criteria

1. The "Setup Wake Word" button SHALL be removed from the main interface
2. The "Start Conversation" button SHALL be removed from the main interface
3. Text elements like "Hey Panda here" and "Assistant at your command" SHALL be removed
4. The "How to wake up Panda" text SHALL remain at the bottom of the screen
5. Permission buttons SHALL remain visible following current visibility logic
6. The developer button SHALL be removed and moved to bottom of the setting btn
7. The "Free tasks left" text SHALL only visible when 3 tasks left, otherwise dont show

### Requirement 4

**User Story:** As a user, I want the bottom navigation to remain functional with the new design, so that I can still access all app sections.

#### Acceptance Criteria

1. WHEN viewing the main screen THEN the bottom navigation SHALL remain visible
2. The bottom navigation SHALL contain: Triggers, Moments, Delta (center), Upgrade, Settings
3. The center navigation item SHALL be updated to show a delta symbol instead of current icon
4. WHEN the user taps navigation items THEN the app SHALL navigate to respective screens
5. The navigation SHALL maintain current functionality and styling

### Requirement 5

**User Story:** As a user, I want the state text (like "Listening...") to be positioned appropriately with the new delta design, so that I understand the current app status.

#### Acceptance Criteria

1. WHEN the app displays status text THEN it SHALL be positioned below the delta symbol
2. The status text SHALL be clearly readable against the background
3. The status text SHALL update appropriately based on app state
4. The text positioning SHALL not interfere with the delta symbol visibility


================================================
FILE: .kiro/specs/main-ui-redesign/tasks.md
================================================
# Implementation Plan

- [ ] 1. Create state management system for delta symbol
  - Create `PandaState` enum with IDLE, LISTENING, PROCESSING, SPEAKING, ERROR states
  - Create `PandaStateManager` class to monitor ConversationalAgentService status
  - Implement state transition logic based on service callbacks
  - _Requirements: 1.1, 1.2, 1.3, 1.4_

- [x] 2. Design and implement delta symbol drawable
  - Create vector drawable for triangle outline with configurable stroke color
  - Implement smooth color transition animations using ValueAnimator
  - Create state-to-color mapping utility class
  - _Requirements: 1.5, 1.6_

- [x] 3. Create Pro upgrade banner component
  - Design banner layout with "Get more with Panda Pro" text and "Upgrade" button
  - Implement banner styling using existing panel_background color
  - Add click handler to navigate to Pro purchase screen
  - _Requirements: 2.1, 2.2, 2.3, 2.4_

- [x] 4. Modify main activity layout structure
  - Remove "Hey Panda here" and "Assistant at your command" text elements
  - Remove "Start Conversation" and "Setup Wake Word" buttons
  - Add Pro banner at top of layout
  - Add centered delta symbol container
  - _Requirements: 3.1, 3.2, 3.3_

- [x] 5. Preserve essential UI elements
  - Keep "How to wake up Panda" link at bottom with existing styling
  - Maintain permission buttons with current visibility logic
  - Keep developer email link in existing position
  - Preserve "Free tasks left" text display
  - _Requirements: 3.4, 3.5, 3.6, 3.7_

- [x] 6. Integrate delta symbol with service state monitoring
  - Hook into ConversationalAgentService lifecycle callbacks
  - Connect to SpeechCoordinator listening/speaking state changes
  - Monitor VisualFeedbackManager thinking indicator visibility
  - Implement error state detection from STT/TTS failures
  - _Requirements: 1.1, 1.2, 1.3, 1.4_

- [x] 7. Implement status text display below delta symbol
  - Create TextView for status messages like "Listening...", "Ready", "Processing"
  - Position text 24dp below delta symbol with center alignment
  - Update text content based on current PandaState
  - Style text with white color and 16sp size
  - _Requirements: 5.1, 5.2, 5.3, 5.4_

- [x] 8. Update MainActivity to use new layout and state management
  - Modify MainActivity.kt to initialize PandaStateManager
  - Remove click handlers for deleted buttons
  - Add Pro banner click handler for navigation
  - Integrate state monitoring with activity lifecycle
  - _Requirements: 2.3, 3.1, 3.2_

- [x] 9. Update bottom navigation delta icon
  - Replace current home triangle icon with delta symbol
  - Ensure navigation functionality remains intact
  - Update navigation item styling if needed
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5_

- [ ] 10. Test state transitions and visual feedback
  - Write unit tests for PandaStateManager state logic
  - Test delta color changes during service state transitions
  - Verify smooth animations and proper status text updates
  - Test error state handling and recovery
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_

- [ ] 11. Test UI layout and preserved functionality
  - Verify Pro banner displays correctly and navigates to purchase screen
  - Test that permission buttons maintain current visibility logic
  - Confirm essential links and text elements remain functional
  - Test responsive layout on different screen sizes
  - _Requirements: 2.1, 2.2, 2.3, 3.4, 3.5, 3.6, 3.7_

- [ ] 12. Integration testing with ConversationalAgentService
  - Test delta symbol updates during actual voice conversations
  - Verify state changes during STT listening and TTS speaking
  - Test error state display during service failures
  - Confirm status text updates match actual service state
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 5.1, 5.2, 5.3_

